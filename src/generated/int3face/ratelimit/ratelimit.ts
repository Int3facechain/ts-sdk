// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: int3face/ratelimit/ratelimit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "int3face.ratelimit";

/**
 * TransferDirection defines whether the transfer is being sent from
 * this chain or is being received on this chain
 */
export enum TransferDirection {
  TRANSFER_IN = 0,
  TRANSFER_OUT = 1,
  UNRECOGNIZED = -1,
}

export function transferDirectionFromJSON(object: any): TransferDirection {
  switch (object) {
    case 0:
    case "TRANSFER_IN":
      return TransferDirection.TRANSFER_IN;
    case 1:
    case "TRANSFER_OUT":
      return TransferDirection.TRANSFER_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferDirection.UNRECOGNIZED;
  }
}

export function transferDirectionToJSON(object: TransferDirection): string {
  switch (object) {
    case TransferDirection.TRANSFER_IN:
      return "TRANSFER_IN";
    case TransferDirection.TRANSFER_OUT:
      return "TRANSFER_OUT";
    case TransferDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AssetID defines a pair of the source chain name and its Int3face
 * representation denoted by denom. AssetID is a primary key for Asset.
 */
export interface AssetID {
  /** SourceChain is a source chain name */
  sourceChain: string;
  /** Denom is the Int3face representation of the SourceChain */
  denom: string;
}

export interface Flow {
  /**
   * Inflow defines the total amount of inbound transfers for the given
   * rate limit in the current window
   */
  inflow: string;
  /**
   * Outflow defines the total amount of outbound transfers for the given
   * rate limit in the current window
   */
  outflow: string;
}

/**
 * EpochFlow links an epoch number with its corresponding flow data (inflow,
 * outflow, supply).
 */
export interface EpochFlow {
  /** EpochNumber identifies the specific epoch. */
  epochNumber: Long;
  /**
   * Flow defines the flow state (inflow, outflow, supply) recorded *during*
   * this specific epoch.
   */
  flow:
    | Flow
    | undefined;
  /**
   * SupplyValue stores the total supply of the denom at the START of
   * the rate limit. This is used as the denominator when checking
   * the rate limit threshold
   * The ChannelValue is fixed for the duration of the rate limit window
   */
  supplyValue: string;
}

/** RateLimitQuota defines the rate limit thresholds for transfer packets */
export interface RateLimitQuota {
  chain: string;
  assetId:
    | AssetID
    | undefined;
  /** Clean inflow limit (% of global supply) */
  maxInflowPercent: string;
  /** Clean outflow limit (% of global supply) */
  maxOutflowPercent: string;
  /**
   * Specifies the number of hours before the rate limit
   * is reset (e.g. 24 indicates that the rate limit is reset each day)
   */
  epochWindowHours: Long;
}

/**
 * RateLimit stores the configuration and potentially the current aggregated
 * flow for a specific rate limit identified by AssetID and chain. Detailed
 * historical epoch data is stored separately in EpochStore.
 */
export interface RateLimitFlow {
  chain: string;
  assetId: AssetID | undefined;
  totalFlow: Flow | undefined;
  epochFlows: EpochFlow[];
}

export interface RateLimitFlowQuota {
  rateLimitFlow: RateLimitFlow | undefined;
  rateLimitQuota: RateLimitQuota | undefined;
}

function createBaseAssetID(): AssetID {
  return { sourceChain: "", denom: "" };
}

export const AssetID: MessageFns<AssetID> = {
  encode(message: AssetID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceChain !== "") {
      writer.uint32(10).string(message.sourceChain);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceChain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetID {
    return {
      sourceChain: isSet(object.sourceChain) ? globalThis.String(object.sourceChain) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
    };
  },

  toJSON(message: AssetID): unknown {
    const obj: any = {};
    if (message.sourceChain !== "") {
      obj.sourceChain = message.sourceChain;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetID>): AssetID {
    return AssetID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetID>): AssetID {
    const message = createBaseAssetID();
    message.sourceChain = object.sourceChain ?? "";
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseFlow(): Flow {
  return { inflow: "", outflow: "" };
}

export const Flow: MessageFns<Flow> = {
  encode(message: Flow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inflow !== "") {
      writer.uint32(10).string(message.inflow);
    }
    if (message.outflow !== "") {
      writer.uint32(18).string(message.outflow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Flow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inflow = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outflow = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Flow {
    return {
      inflow: isSet(object.inflow) ? globalThis.String(object.inflow) : "",
      outflow: isSet(object.outflow) ? globalThis.String(object.outflow) : "",
    };
  },

  toJSON(message: Flow): unknown {
    const obj: any = {};
    if (message.inflow !== "") {
      obj.inflow = message.inflow;
    }
    if (message.outflow !== "") {
      obj.outflow = message.outflow;
    }
    return obj;
  },

  create(base?: DeepPartial<Flow>): Flow {
    return Flow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Flow>): Flow {
    const message = createBaseFlow();
    message.inflow = object.inflow ?? "";
    message.outflow = object.outflow ?? "";
    return message;
  },
};

function createBaseEpochFlow(): EpochFlow {
  return { epochNumber: Long.UZERO, flow: undefined, supplyValue: "" };
}

export const EpochFlow: MessageFns<EpochFlow> = {
  encode(message: EpochFlow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.epochNumber.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.epochNumber.toString());
    }
    if (message.flow !== undefined) {
      Flow.encode(message.flow, writer.uint32(18).fork()).join();
    }
    if (message.supplyValue !== "") {
      writer.uint32(26).string(message.supplyValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpochFlow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.flow = Flow.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.supplyValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpochFlow {
    return {
      epochNumber: isSet(object.epochNumber) ? Long.fromValue(object.epochNumber) : Long.UZERO,
      flow: isSet(object.flow) ? Flow.fromJSON(object.flow) : undefined,
      supplyValue: isSet(object.supplyValue) ? globalThis.String(object.supplyValue) : "",
    };
  },

  toJSON(message: EpochFlow): unknown {
    const obj: any = {};
    if (!message.epochNumber.equals(Long.UZERO)) {
      obj.epochNumber = (message.epochNumber || Long.UZERO).toString();
    }
    if (message.flow !== undefined) {
      obj.flow = Flow.toJSON(message.flow);
    }
    if (message.supplyValue !== "") {
      obj.supplyValue = message.supplyValue;
    }
    return obj;
  },

  create(base?: DeepPartial<EpochFlow>): EpochFlow {
    return EpochFlow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EpochFlow>): EpochFlow {
    const message = createBaseEpochFlow();
    message.epochNumber = (object.epochNumber !== undefined && object.epochNumber !== null)
      ? Long.fromValue(object.epochNumber)
      : Long.UZERO;
    message.flow = (object.flow !== undefined && object.flow !== null) ? Flow.fromPartial(object.flow) : undefined;
    message.supplyValue = object.supplyValue ?? "";
    return message;
  },
};

function createBaseRateLimitQuota(): RateLimitQuota {
  return { chain: "", assetId: undefined, maxInflowPercent: "", maxOutflowPercent: "", epochWindowHours: Long.UZERO };
}

export const RateLimitQuota: MessageFns<RateLimitQuota> = {
  encode(message: RateLimitQuota, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.maxInflowPercent !== "") {
      writer.uint32(26).string(message.maxInflowPercent);
    }
    if (message.maxOutflowPercent !== "") {
      writer.uint32(34).string(message.maxOutflowPercent);
    }
    if (!message.epochWindowHours.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.epochWindowHours.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitQuota {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitQuota();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxInflowPercent = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxOutflowPercent = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.epochWindowHours = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitQuota {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      maxInflowPercent: isSet(object.maxInflowPercent) ? globalThis.String(object.maxInflowPercent) : "",
      maxOutflowPercent: isSet(object.maxOutflowPercent) ? globalThis.String(object.maxOutflowPercent) : "",
      epochWindowHours: isSet(object.epochWindowHours) ? Long.fromValue(object.epochWindowHours) : Long.UZERO,
    };
  },

  toJSON(message: RateLimitQuota): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.maxInflowPercent !== "") {
      obj.maxInflowPercent = message.maxInflowPercent;
    }
    if (message.maxOutflowPercent !== "") {
      obj.maxOutflowPercent = message.maxOutflowPercent;
    }
    if (!message.epochWindowHours.equals(Long.UZERO)) {
      obj.epochWindowHours = (message.epochWindowHours || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<RateLimitQuota>): RateLimitQuota {
    return RateLimitQuota.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RateLimitQuota>): RateLimitQuota {
    const message = createBaseRateLimitQuota();
    message.chain = object.chain ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.maxInflowPercent = object.maxInflowPercent ?? "";
    message.maxOutflowPercent = object.maxOutflowPercent ?? "";
    message.epochWindowHours = (object.epochWindowHours !== undefined && object.epochWindowHours !== null)
      ? Long.fromValue(object.epochWindowHours)
      : Long.UZERO;
    return message;
  },
};

function createBaseRateLimitFlow(): RateLimitFlow {
  return { chain: "", assetId: undefined, totalFlow: undefined, epochFlows: [] };
}

export const RateLimitFlow: MessageFns<RateLimitFlow> = {
  encode(message: RateLimitFlow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.totalFlow !== undefined) {
      Flow.encode(message.totalFlow, writer.uint32(26).fork()).join();
    }
    for (const v of message.epochFlows) {
      EpochFlow.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitFlow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalFlow = Flow.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.epochFlows.push(EpochFlow.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitFlow {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      totalFlow: isSet(object.totalFlow) ? Flow.fromJSON(object.totalFlow) : undefined,
      epochFlows: globalThis.Array.isArray(object?.epochFlows)
        ? object.epochFlows.map((e: any) => EpochFlow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RateLimitFlow): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.totalFlow !== undefined) {
      obj.totalFlow = Flow.toJSON(message.totalFlow);
    }
    if (message.epochFlows?.length) {
      obj.epochFlows = message.epochFlows.map((e) => EpochFlow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RateLimitFlow>): RateLimitFlow {
    return RateLimitFlow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RateLimitFlow>): RateLimitFlow {
    const message = createBaseRateLimitFlow();
    message.chain = object.chain ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.totalFlow = (object.totalFlow !== undefined && object.totalFlow !== null)
      ? Flow.fromPartial(object.totalFlow)
      : undefined;
    message.epochFlows = object.epochFlows?.map((e) => EpochFlow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRateLimitFlowQuota(): RateLimitFlowQuota {
  return { rateLimitFlow: undefined, rateLimitQuota: undefined };
}

export const RateLimitFlowQuota: MessageFns<RateLimitFlowQuota> = {
  encode(message: RateLimitFlowQuota, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rateLimitFlow !== undefined) {
      RateLimitFlow.encode(message.rateLimitFlow, writer.uint32(10).fork()).join();
    }
    if (message.rateLimitQuota !== undefined) {
      RateLimitQuota.encode(message.rateLimitQuota, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitFlowQuota {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitFlowQuota();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rateLimitFlow = RateLimitFlow.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rateLimitQuota = RateLimitQuota.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitFlowQuota {
    return {
      rateLimitFlow: isSet(object.rateLimitFlow) ? RateLimitFlow.fromJSON(object.rateLimitFlow) : undefined,
      rateLimitQuota: isSet(object.rateLimitQuota) ? RateLimitQuota.fromJSON(object.rateLimitQuota) : undefined,
    };
  },

  toJSON(message: RateLimitFlowQuota): unknown {
    const obj: any = {};
    if (message.rateLimitFlow !== undefined) {
      obj.rateLimitFlow = RateLimitFlow.toJSON(message.rateLimitFlow);
    }
    if (message.rateLimitQuota !== undefined) {
      obj.rateLimitQuota = RateLimitQuota.toJSON(message.rateLimitQuota);
    }
    return obj;
  },

  create(base?: DeepPartial<RateLimitFlowQuota>): RateLimitFlowQuota {
    return RateLimitFlowQuota.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RateLimitFlowQuota>): RateLimitFlowQuota {
    const message = createBaseRateLimitFlowQuota();
    message.rateLimitFlow = (object.rateLimitFlow !== undefined && object.rateLimitFlow !== null)
      ? RateLimitFlow.fromPartial(object.rateLimitFlow)
      : undefined;
    message.rateLimitQuota = (object.rateLimitQuota !== undefined && object.rateLimitQuota !== null)
      ? RateLimitQuota.fromPartial(object.rateLimitQuota)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
