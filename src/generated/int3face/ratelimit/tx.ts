// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: int3face/ratelimit/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { AssetID } from "./ratelimit";

export const protobufPackage = "int3face.ratelimit";

/** Gov tx to add a new rate limit */
export interface MsgAddBridgeRateLimit {
  /** Authority defines the x/gov module account */
  authority: string;
  /** AssetID is the ID of the rate limit */
  assetId:
    | AssetID
    | undefined;
  /**
   * MaxPercentSend defines the threshold for outflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   */
  maxInflowPercent: string;
  /**
   * MaxPercentSend defines the threshold for inflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   */
  maxOutflowPercent: string;
  /**
   * DurationHours specifies the number of hours before the rate limit
   * is reset (e.g. 24 indicates that the rate limit is reset each day)
   */
  durationHours: Long;
  chain: string;
}

export interface MsgAddBridgeRateLimitResponse {
}

/** Gov tx to update an existing rate limit */
export interface MsgUpdateBridgeRateLimit {
  /** Authority defines the x/gov module account */
  authority: string;
  /** AssetID is the ID of the rate limit */
  assetId:
    | AssetID
    | undefined;
  /**
   * MaxPercentSend defines the threshold for outflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   */
  maxInflowPercent: string;
  /**
   * MaxPercentSend defines the threshold for inflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   */
  maxOutflowPercent: string;
  /**
   * DurationHours specifies the number of hours before the rate limit
   * is reset (e.g. 24 indicates that the rate limit is reset each day)
   */
  durationHours: Long;
  chain: string;
}

export interface MsgUpdateBridgeRateLimitResponse {
}

/** Gov tx to remove a rate limit */
export interface MsgRemoveBridgeRateLimit {
  /** Authority defines the x/gov module account */
  authority: string;
  /** AssetID is the ID of the rate limit */
  assetId: AssetID | undefined;
  chain: string;
}

export interface MsgRemoveBridgeRateLimitResponse {
}

/** Gov tx to reset the flow on a rate limit */
export interface MsgResetBridgeRateLimit {
  /** Authority defines the x/gov module account */
  authority: string;
  /** AssetID is the ID of the rate limit */
  assetId: AssetID | undefined;
  chain: string;
}

export interface MsgResetBridgeRateLimitResponse {
}

function createBaseMsgAddBridgeRateLimit(): MsgAddBridgeRateLimit {
  return {
    authority: "",
    assetId: undefined,
    maxInflowPercent: "",
    maxOutflowPercent: "",
    durationHours: Long.UZERO,
    chain: "",
  };
}

export const MsgAddBridgeRateLimit: MessageFns<MsgAddBridgeRateLimit> = {
  encode(message: MsgAddBridgeRateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.maxInflowPercent !== "") {
      writer.uint32(26).string(message.maxInflowPercent);
    }
    if (message.maxOutflowPercent !== "") {
      writer.uint32(34).string(message.maxOutflowPercent);
    }
    if (!message.durationHours.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.durationHours.toString());
    }
    if (message.chain !== "") {
      writer.uint32(58).string(message.chain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddBridgeRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddBridgeRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxInflowPercent = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxOutflowPercent = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.durationHours = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddBridgeRateLimit {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      maxInflowPercent: isSet(object.maxInflowPercent) ? globalThis.String(object.maxInflowPercent) : "",
      maxOutflowPercent: isSet(object.maxOutflowPercent) ? globalThis.String(object.maxOutflowPercent) : "",
      durationHours: isSet(object.durationHours) ? Long.fromValue(object.durationHours) : Long.UZERO,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
    };
  },

  toJSON(message: MsgAddBridgeRateLimit): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.maxInflowPercent !== "") {
      obj.maxInflowPercent = message.maxInflowPercent;
    }
    if (message.maxOutflowPercent !== "") {
      obj.maxOutflowPercent = message.maxOutflowPercent;
    }
    if (!message.durationHours.equals(Long.UZERO)) {
      obj.durationHours = (message.durationHours || Long.UZERO).toString();
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAddBridgeRateLimit>): MsgAddBridgeRateLimit {
    return MsgAddBridgeRateLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAddBridgeRateLimit>): MsgAddBridgeRateLimit {
    const message = createBaseMsgAddBridgeRateLimit();
    message.authority = object.authority ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.maxInflowPercent = object.maxInflowPercent ?? "";
    message.maxOutflowPercent = object.maxOutflowPercent ?? "";
    message.durationHours = (object.durationHours !== undefined && object.durationHours !== null)
      ? Long.fromValue(object.durationHours)
      : Long.UZERO;
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseMsgAddBridgeRateLimitResponse(): MsgAddBridgeRateLimitResponse {
  return {};
}

export const MsgAddBridgeRateLimitResponse: MessageFns<MsgAddBridgeRateLimitResponse> = {
  encode(_: MsgAddBridgeRateLimitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddBridgeRateLimitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddBridgeRateLimitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddBridgeRateLimitResponse {
    return {};
  },

  toJSON(_: MsgAddBridgeRateLimitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAddBridgeRateLimitResponse>): MsgAddBridgeRateLimitResponse {
    return MsgAddBridgeRateLimitResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAddBridgeRateLimitResponse>): MsgAddBridgeRateLimitResponse {
    const message = createBaseMsgAddBridgeRateLimitResponse();
    return message;
  },
};

function createBaseMsgUpdateBridgeRateLimit(): MsgUpdateBridgeRateLimit {
  return {
    authority: "",
    assetId: undefined,
    maxInflowPercent: "",
    maxOutflowPercent: "",
    durationHours: Long.UZERO,
    chain: "",
  };
}

export const MsgUpdateBridgeRateLimit: MessageFns<MsgUpdateBridgeRateLimit> = {
  encode(message: MsgUpdateBridgeRateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.maxInflowPercent !== "") {
      writer.uint32(26).string(message.maxInflowPercent);
    }
    if (message.maxOutflowPercent !== "") {
      writer.uint32(34).string(message.maxOutflowPercent);
    }
    if (!message.durationHours.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.durationHours.toString());
    }
    if (message.chain !== "") {
      writer.uint32(50).string(message.chain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateBridgeRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateBridgeRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxInflowPercent = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxOutflowPercent = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.durationHours = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateBridgeRateLimit {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      maxInflowPercent: isSet(object.maxInflowPercent) ? globalThis.String(object.maxInflowPercent) : "",
      maxOutflowPercent: isSet(object.maxOutflowPercent) ? globalThis.String(object.maxOutflowPercent) : "",
      durationHours: isSet(object.durationHours) ? Long.fromValue(object.durationHours) : Long.UZERO,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
    };
  },

  toJSON(message: MsgUpdateBridgeRateLimit): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.maxInflowPercent !== "") {
      obj.maxInflowPercent = message.maxInflowPercent;
    }
    if (message.maxOutflowPercent !== "") {
      obj.maxOutflowPercent = message.maxOutflowPercent;
    }
    if (!message.durationHours.equals(Long.UZERO)) {
      obj.durationHours = (message.durationHours || Long.UZERO).toString();
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateBridgeRateLimit>): MsgUpdateBridgeRateLimit {
    return MsgUpdateBridgeRateLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateBridgeRateLimit>): MsgUpdateBridgeRateLimit {
    const message = createBaseMsgUpdateBridgeRateLimit();
    message.authority = object.authority ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.maxInflowPercent = object.maxInflowPercent ?? "";
    message.maxOutflowPercent = object.maxOutflowPercent ?? "";
    message.durationHours = (object.durationHours !== undefined && object.durationHours !== null)
      ? Long.fromValue(object.durationHours)
      : Long.UZERO;
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseMsgUpdateBridgeRateLimitResponse(): MsgUpdateBridgeRateLimitResponse {
  return {};
}

export const MsgUpdateBridgeRateLimitResponse: MessageFns<MsgUpdateBridgeRateLimitResponse> = {
  encode(_: MsgUpdateBridgeRateLimitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateBridgeRateLimitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateBridgeRateLimitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateBridgeRateLimitResponse {
    return {};
  },

  toJSON(_: MsgUpdateBridgeRateLimitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateBridgeRateLimitResponse>): MsgUpdateBridgeRateLimitResponse {
    return MsgUpdateBridgeRateLimitResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateBridgeRateLimitResponse>): MsgUpdateBridgeRateLimitResponse {
    const message = createBaseMsgUpdateBridgeRateLimitResponse();
    return message;
  },
};

function createBaseMsgRemoveBridgeRateLimit(): MsgRemoveBridgeRateLimit {
  return { authority: "", assetId: undefined, chain: "" };
}

export const MsgRemoveBridgeRateLimit: MessageFns<MsgRemoveBridgeRateLimit> = {
  encode(message: MsgRemoveBridgeRateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.chain !== "") {
      writer.uint32(26).string(message.chain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveBridgeRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveBridgeRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveBridgeRateLimit {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
    };
  },

  toJSON(message: MsgRemoveBridgeRateLimit): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveBridgeRateLimit>): MsgRemoveBridgeRateLimit {
    return MsgRemoveBridgeRateLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveBridgeRateLimit>): MsgRemoveBridgeRateLimit {
    const message = createBaseMsgRemoveBridgeRateLimit();
    message.authority = object.authority ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseMsgRemoveBridgeRateLimitResponse(): MsgRemoveBridgeRateLimitResponse {
  return {};
}

export const MsgRemoveBridgeRateLimitResponse: MessageFns<MsgRemoveBridgeRateLimitResponse> = {
  encode(_: MsgRemoveBridgeRateLimitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveBridgeRateLimitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveBridgeRateLimitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveBridgeRateLimitResponse {
    return {};
  },

  toJSON(_: MsgRemoveBridgeRateLimitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveBridgeRateLimitResponse>): MsgRemoveBridgeRateLimitResponse {
    return MsgRemoveBridgeRateLimitResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveBridgeRateLimitResponse>): MsgRemoveBridgeRateLimitResponse {
    const message = createBaseMsgRemoveBridgeRateLimitResponse();
    return message;
  },
};

function createBaseMsgResetBridgeRateLimit(): MsgResetBridgeRateLimit {
  return { authority: "", assetId: undefined, chain: "" };
}

export const MsgResetBridgeRateLimit: MessageFns<MsgResetBridgeRateLimit> = {
  encode(message: MsgResetBridgeRateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.chain !== "") {
      writer.uint32(26).string(message.chain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResetBridgeRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResetBridgeRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgResetBridgeRateLimit {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
    };
  },

  toJSON(message: MsgResetBridgeRateLimit): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgResetBridgeRateLimit>): MsgResetBridgeRateLimit {
    return MsgResetBridgeRateLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgResetBridgeRateLimit>): MsgResetBridgeRateLimit {
    const message = createBaseMsgResetBridgeRateLimit();
    message.authority = object.authority ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseMsgResetBridgeRateLimitResponse(): MsgResetBridgeRateLimitResponse {
  return {};
}

export const MsgResetBridgeRateLimitResponse: MessageFns<MsgResetBridgeRateLimitResponse> = {
  encode(_: MsgResetBridgeRateLimitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResetBridgeRateLimitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResetBridgeRateLimitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgResetBridgeRateLimitResponse {
    return {};
  },

  toJSON(_: MsgResetBridgeRateLimitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgResetBridgeRateLimitResponse>): MsgResetBridgeRateLimitResponse {
    return MsgResetBridgeRateLimitResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgResetBridgeRateLimitResponse>): MsgResetBridgeRateLimitResponse {
    const message = createBaseMsgResetBridgeRateLimitResponse();
    return message;
  },
};

/** Msg defines the ratelimit module's gRPC message service. */
export interface Msg {
  /** Gov tx to add a new rate limit */
  AddBridgeRateLimit(request: MsgAddBridgeRateLimit): Promise<MsgAddBridgeRateLimitResponse>;
  /** Gov tx to update an existing rate limit */
  UpdateBridgeRateLimit(request: MsgUpdateBridgeRateLimit): Promise<MsgUpdateBridgeRateLimitResponse>;
  /** Gov tx to remove a rate limit */
  RemoveBridgeRateLimit(request: MsgRemoveBridgeRateLimit): Promise<MsgRemoveBridgeRateLimitResponse>;
  /** Gov tx to reset the flow on a rate limit */
  ResetBridgeRateLimit(request: MsgResetBridgeRateLimit): Promise<MsgResetBridgeRateLimitResponse>;
}

export const MsgServiceName = "int3face.ratelimit.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.AddBridgeRateLimit = this.AddBridgeRateLimit.bind(this);
    this.UpdateBridgeRateLimit = this.UpdateBridgeRateLimit.bind(this);
    this.RemoveBridgeRateLimit = this.RemoveBridgeRateLimit.bind(this);
    this.ResetBridgeRateLimit = this.ResetBridgeRateLimit.bind(this);
  }
  AddBridgeRateLimit(request: MsgAddBridgeRateLimit): Promise<MsgAddBridgeRateLimitResponse> {
    const data = MsgAddBridgeRateLimit.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddBridgeRateLimit", data);
    return promise.then((data) => MsgAddBridgeRateLimitResponse.decode(new BinaryReader(data)));
  }

  UpdateBridgeRateLimit(request: MsgUpdateBridgeRateLimit): Promise<MsgUpdateBridgeRateLimitResponse> {
    const data = MsgUpdateBridgeRateLimit.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateBridgeRateLimit", data);
    return promise.then((data) => MsgUpdateBridgeRateLimitResponse.decode(new BinaryReader(data)));
  }

  RemoveBridgeRateLimit(request: MsgRemoveBridgeRateLimit): Promise<MsgRemoveBridgeRateLimitResponse> {
    const data = MsgRemoveBridgeRateLimit.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveBridgeRateLimit", data);
    return promise.then((data) => MsgRemoveBridgeRateLimitResponse.decode(new BinaryReader(data)));
  }

  ResetBridgeRateLimit(request: MsgResetBridgeRateLimit): Promise<MsgResetBridgeRateLimitResponse> {
    const data = MsgResetBridgeRateLimit.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResetBridgeRateLimit", data);
    return promise.then((data) => MsgResetBridgeRateLimitResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
