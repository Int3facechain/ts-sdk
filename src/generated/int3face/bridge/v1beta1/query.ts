// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: int3face/bridge/v1beta1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Asset, AssetID, BridgeProposal, Chain, InboundTransfer, KeyGen, OutboundTransfer, Params } from "./bridge";

export const protobufPackage = "int3face.bridge.v1beta1";

/** QueryParamsRequest is the request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  params: Params | undefined;
}

/** QueryChainsRequest is the request type for the Query/Chains RPC method. */
export interface QueryChainsRequest {
}

/** QueryChainsResponse is the response type for the Query/Chains RPC method. */
export interface QueryChainsResponse {
  chains: Chain[];
}

/** QueryProposalRequest is the request type for the Query/Proposal RPC method. */
export interface QueryProposalRequest {
  proposalId: Long;
}

/** QueryProposalResponse is the response type for the Query/Proposal RPC method. */
export interface QueryProposalResponse {
  proposal: BridgeProposal | undefined;
}

/** QueryProposalsRequest is the request type for the Query/Proposals RPC method. */
export interface QueryProposalsRequest {
  pagination: PageRequest | undefined;
}

/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC
 * method.
 */
export interface QueryProposalsResponse {
  proposals: BridgeProposal[];
  pagination: PageResponse | undefined;
}

/** QueryChainRequest is the request type for the Query/Chain RPC method. */
export interface QueryChainRequest {
  chainId: string;
}

/** QueryChainResponse is the response type for the Query/Chain RPC method. */
export interface QueryChainResponse {
  chain: Chain | undefined;
}

/** QueryAssetsRequest is the request type for the Query/Assets RPC method. */
export interface QueryAssetsRequest {
}

/** QueryAssetsResponse is the response type for the Query/Assets RPC method. */
export interface QueryAssetsResponse {
  assets: Asset[];
}

/** QueryAssetRequest is the request type for the Query/Asset RPC method. */
export interface QueryAssetRequest {
  assetId: string;
}

/** QueryAssetResponse is the response type for the Query/Asset RPC method. */
export interface QueryAssetResponse {
  asset: Asset | undefined;
}

/**
 * LastTransferHeightRequest is the request type for the
 * Query/LastTransferHeight RPC method.
 */
export interface LastTransferHeightRequest {
  assetId: AssetID | undefined;
}

/**
 * LastTransferHeightResponse is the response type for the
 * Query/LastTransferHeight RPC method.
 */
export interface LastTransferHeightResponse {
  lastTransferHeight: Long;
}

/**
 * LastTssKeyGenRequest is the request type for the Query/LastTssKeyGen RPC
 * method.
 */
export interface LastTssKeyGenRequest {
}

/**
 * LastTssKeyGenResponse is the response type for the Query/LastTssKeyGen RPC
 * method.
 */
export interface LastTssKeyGenResponse {
  keygen: KeyGen | undefined;
}

/**
 * QueryTssKeyGenRequest is the request type for the Query/TssKeyGen RPC
 * method.
 */
export interface QueryTssKeyGenRequest {
  keygenId: string;
}

/**
 * QueryTssKeyGenResponse is the response type for the Query/TssKeyGen RPC
 * method.
 */
export interface QueryTssKeyGenResponse {
  keygen: KeyGen | undefined;
}

/**
 * QueryTssKeyGensRequest is the request type for the Query/TssKeyGens RPC
 * method.
 */
export interface QueryTssKeyGensRequest {
  pagination: PageRequest | undefined;
  finalizedOnly: boolean;
}

/**
 * QueryTssKeyGensResponse is the response type for the Query/TssKeyGens RPC
 * method.
 */
export interface QueryTssKeyGensResponse {
  keygens: KeyGen[];
  pagination: PageResponse | undefined;
}

export interface ChainBalancesRequest {
  chainId: string;
}

export interface ChainBalancesResponse {
  chainWallet: string;
  balances: Coin[];
}

/**
 * QueryInboundTransferRequest is the request type for the Query/InboundTransfer
 * RPC method.
 */
export interface QueryInboundTransferRequest {
  /**
   * Transfer Id is string representation of the inbound transfer ID,
   * Separator of id parts is "#".
   * If BITFROST inbound: external_id + # + external_height
   * If IBC inbound: source_channel + # + destination_channel + # + sequence
   */
  transferId: string;
}

/**
 * QueryInboundTransferResponse is the response type for the
 * Query/InboundTransfer RPC method.
 */
export interface QueryInboundTransferResponse {
  inboundTransfer: InboundTransfer | undefined;
}

/**
 * QueryInboundTransfersRequest is the request type for the
 * Query/InboundTransfers RPC method.
 */
export interface QueryInboundTransfersRequest {
  pagination: PageRequest | undefined;
}

/**
 * QueryInboundTransfersResponse is the response type for the
 * Query/InboundTransfers RPC method.
 */
export interface QueryInboundTransfersResponse {
  transfers: InboundTransfer[];
  pagination: PageResponse | undefined;
}

/**
 * QueryOutboundTransferRequest is the request type for the
 * Query/OutboundTransfer RPC method.
 */
export interface QueryOutboundTransferRequest {
  /**
   * TxHash is the int3face transaction hash of the outbound transfer occurred
   * on the int3face chain.
   */
  txHash: string;
}

/**
 * QueryOutboundTransferResponse is the response type for the
 * Query/OutboundTransfer RPC method.
 */
export interface QueryOutboundTransferResponse {
  outboundTransfer: OutboundTransfer | undefined;
}

/**
 * QueryOutboundTransfersRequest is the request type for the
 * Query/OutboundTransfers RPC method.
 */
export interface QueryOutboundTransfersRequest {
  pagination: PageRequest | undefined;
}

/**
 * QueryOutboundTransfersResponse is the response type for the
 * Query/OutboundTransfers RPC method.
 */
export interface QueryOutboundTransfersResponse {
  transfers: OutboundTransfer[];
  pagination: PageResponse | undefined;
}

/** CanTransferRequest is the request type for the Query/CanTransfer RPC method. */
export interface CanTransferRequest {
  srcChainId: string;
  destChainId: string;
  assetId: string;
  amount: string;
}

/**
 * CanTransferResponse is the response type for the Query/CanTransfer RPC
 * method.
 */
export interface CanTransferResponse {
  canTransfer: boolean;
  reason: string;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryParamsRequest>): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueryParamsRequest>): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryParamsResponse>): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryParamsResponse>): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryChainsRequest(): QueryChainsRequest {
  return {};
}

export const QueryChainsRequest: MessageFns<QueryChainsRequest> = {
  encode(_: QueryChainsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryChainsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryChainsRequest {
    return {};
  },

  toJSON(_: QueryChainsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryChainsRequest>): QueryChainsRequest {
    return QueryChainsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueryChainsRequest>): QueryChainsRequest {
    const message = createBaseQueryChainsRequest();
    return message;
  },
};

function createBaseQueryChainsResponse(): QueryChainsResponse {
  return { chains: [] };
}

export const QueryChainsResponse: MessageFns<QueryChainsResponse> = {
  encode(message: QueryChainsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chains) {
      Chain.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryChainsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chains.push(Chain.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryChainsResponse {
    return { chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => Chain.fromJSON(e)) : [] };
  },

  toJSON(message: QueryChainsResponse): unknown {
    const obj: any = {};
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => Chain.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryChainsResponse>): QueryChainsResponse {
    return QueryChainsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryChainsResponse>): QueryChainsResponse {
    const message = createBaseQueryChainsResponse();
    message.chains = object.chains?.map((e) => Chain.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryProposalRequest(): QueryProposalRequest {
  return { proposalId: Long.UZERO };
}

export const QueryProposalRequest: MessageFns<QueryProposalRequest> = {
  encode(message: QueryProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.proposalId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.proposalId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.proposalId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposalRequest {
    return { proposalId: isSet(object.proposalId) ? Long.fromValue(object.proposalId) : Long.UZERO };
  },

  toJSON(message: QueryProposalRequest): unknown {
    const obj: any = {};
    if (!message.proposalId.equals(Long.UZERO)) {
      obj.proposalId = (message.proposalId || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryProposalRequest>): QueryProposalRequest {
    return QueryProposalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryProposalRequest>): QueryProposalRequest {
    const message = createBaseQueryProposalRequest();
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.UZERO;
    return message;
  },
};

function createBaseQueryProposalResponse(): QueryProposalResponse {
  return { proposal: undefined };
}

export const QueryProposalResponse: MessageFns<QueryProposalResponse> = {
  encode(message: QueryProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposal !== undefined) {
      BridgeProposal.encode(message.proposal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposal = BridgeProposal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposalResponse {
    return { proposal: isSet(object.proposal) ? BridgeProposal.fromJSON(object.proposal) : undefined };
  },

  toJSON(message: QueryProposalResponse): unknown {
    const obj: any = {};
    if (message.proposal !== undefined) {
      obj.proposal = BridgeProposal.toJSON(message.proposal);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryProposalResponse>): QueryProposalResponse {
    return QueryProposalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryProposalResponse>): QueryProposalResponse {
    const message = createBaseQueryProposalResponse();
    message.proposal = (object.proposal !== undefined && object.proposal !== null)
      ? BridgeProposal.fromPartial(object.proposal)
      : undefined;
    return message;
  },
};

function createBaseQueryProposalsRequest(): QueryProposalsRequest {
  return { pagination: undefined };
}

export const QueryProposalsRequest: MessageFns<QueryProposalsRequest> = {
  encode(message: QueryProposalsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProposalsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposalsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryProposalsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryProposalsRequest>): QueryProposalsRequest {
    return QueryProposalsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryProposalsRequest>): QueryProposalsRequest {
    const message = createBaseQueryProposalsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryProposalsResponse(): QueryProposalsResponse {
  return { proposals: [], pagination: undefined };
}

export const QueryProposalsResponse: MessageFns<QueryProposalsResponse> = {
  encode(message: QueryProposalsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.proposals) {
      BridgeProposal.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryProposalsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposals.push(BridgeProposal.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposalsResponse {
    return {
      proposals: globalThis.Array.isArray(object?.proposals)
        ? object.proposals.map((e: any) => BridgeProposal.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryProposalsResponse): unknown {
    const obj: any = {};
    if (message.proposals?.length) {
      obj.proposals = message.proposals.map((e) => BridgeProposal.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryProposalsResponse>): QueryProposalsResponse {
    return QueryProposalsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryProposalsResponse>): QueryProposalsResponse {
    const message = createBaseQueryProposalsResponse();
    message.proposals = object.proposals?.map((e) => BridgeProposal.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryChainRequest(): QueryChainRequest {
  return { chainId: "" };
}

export const QueryChainRequest: MessageFns<QueryChainRequest> = {
  encode(message: QueryChainRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryChainRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryChainRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: QueryChainRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryChainRequest>): QueryChainRequest {
    return QueryChainRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryChainRequest>): QueryChainRequest {
    const message = createBaseQueryChainRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseQueryChainResponse(): QueryChainResponse {
  return { chain: undefined };
}

export const QueryChainResponse: MessageFns<QueryChainResponse> = {
  encode(message: QueryChainResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chain !== undefined) {
      Chain.encode(message.chain, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryChainResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chain = Chain.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryChainResponse {
    return { chain: isSet(object.chain) ? Chain.fromJSON(object.chain) : undefined };
  },

  toJSON(message: QueryChainResponse): unknown {
    const obj: any = {};
    if (message.chain !== undefined) {
      obj.chain = Chain.toJSON(message.chain);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryChainResponse>): QueryChainResponse {
    return QueryChainResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryChainResponse>): QueryChainResponse {
    const message = createBaseQueryChainResponse();
    message.chain = (object.chain !== undefined && object.chain !== null) ? Chain.fromPartial(object.chain) : undefined;
    return message;
  },
};

function createBaseQueryAssetsRequest(): QueryAssetsRequest {
  return {};
}

export const QueryAssetsRequest: MessageFns<QueryAssetsRequest> = {
  encode(_: QueryAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryAssetsRequest {
    return {};
  },

  toJSON(_: QueryAssetsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryAssetsRequest>): QueryAssetsRequest {
    return QueryAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueryAssetsRequest>): QueryAssetsRequest {
    const message = createBaseQueryAssetsRequest();
    return message;
  },
};

function createBaseQueryAssetsResponse(): QueryAssetsResponse {
  return { assets: [] };
}

export const QueryAssetsResponse: MessageFns<QueryAssetsResponse> = {
  encode(message: QueryAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAssetsResponse {
    return { assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [] };
  },

  toJSON(message: QueryAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAssetsResponse>): QueryAssetsResponse {
    return QueryAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAssetsResponse>): QueryAssetsResponse {
    const message = createBaseQueryAssetsResponse();
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAssetRequest(): QueryAssetRequest {
  return { assetId: "" };
}

export const QueryAssetRequest: MessageFns<QueryAssetRequest> = {
  encode(message: QueryAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAssetRequest {
    return { assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "" };
  },

  toJSON(message: QueryAssetRequest): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAssetRequest>): QueryAssetRequest {
    return QueryAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAssetRequest>): QueryAssetRequest {
    const message = createBaseQueryAssetRequest();
    message.assetId = object.assetId ?? "";
    return message;
  },
};

function createBaseQueryAssetResponse(): QueryAssetResponse {
  return { asset: undefined };
}

export const QueryAssetResponse: MessageFns<QueryAssetResponse> = {
  encode(message: QueryAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAssetResponse {
    return { asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined };
  },

  toJSON(message: QueryAssetResponse): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAssetResponse>): QueryAssetResponse {
    return QueryAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAssetResponse>): QueryAssetResponse {
    const message = createBaseQueryAssetResponse();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    return message;
  },
};

function createBaseLastTransferHeightRequest(): LastTransferHeightRequest {
  return { assetId: undefined };
}

export const LastTransferHeightRequest: MessageFns<LastTransferHeightRequest> = {
  encode(message: LastTransferHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastTransferHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastTransferHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastTransferHeightRequest {
    return { assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined };
  },

  toJSON(message: LastTransferHeightRequest): unknown {
    const obj: any = {};
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    return obj;
  },

  create(base?: DeepPartial<LastTransferHeightRequest>): LastTransferHeightRequest {
    return LastTransferHeightRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LastTransferHeightRequest>): LastTransferHeightRequest {
    const message = createBaseLastTransferHeightRequest();
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    return message;
  },
};

function createBaseLastTransferHeightResponse(): LastTransferHeightResponse {
  return { lastTransferHeight: Long.UZERO };
}

export const LastTransferHeightResponse: MessageFns<LastTransferHeightResponse> = {
  encode(message: LastTransferHeightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.lastTransferHeight.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.lastTransferHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastTransferHeightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastTransferHeightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lastTransferHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastTransferHeightResponse {
    return {
      lastTransferHeight: isSet(object.lastTransferHeight) ? Long.fromValue(object.lastTransferHeight) : Long.UZERO,
    };
  },

  toJSON(message: LastTransferHeightResponse): unknown {
    const obj: any = {};
    if (!message.lastTransferHeight.equals(Long.UZERO)) {
      obj.lastTransferHeight = (message.lastTransferHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<LastTransferHeightResponse>): LastTransferHeightResponse {
    return LastTransferHeightResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LastTransferHeightResponse>): LastTransferHeightResponse {
    const message = createBaseLastTransferHeightResponse();
    message.lastTransferHeight = (object.lastTransferHeight !== undefined && object.lastTransferHeight !== null)
      ? Long.fromValue(object.lastTransferHeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseLastTssKeyGenRequest(): LastTssKeyGenRequest {
  return {};
}

export const LastTssKeyGenRequest: MessageFns<LastTssKeyGenRequest> = {
  encode(_: LastTssKeyGenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastTssKeyGenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastTssKeyGenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LastTssKeyGenRequest {
    return {};
  },

  toJSON(_: LastTssKeyGenRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<LastTssKeyGenRequest>): LastTssKeyGenRequest {
    return LastTssKeyGenRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<LastTssKeyGenRequest>): LastTssKeyGenRequest {
    const message = createBaseLastTssKeyGenRequest();
    return message;
  },
};

function createBaseLastTssKeyGenResponse(): LastTssKeyGenResponse {
  return { keygen: undefined };
}

export const LastTssKeyGenResponse: MessageFns<LastTssKeyGenResponse> = {
  encode(message: LastTssKeyGenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keygen !== undefined) {
      KeyGen.encode(message.keygen, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastTssKeyGenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastTssKeyGenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keygen = KeyGen.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastTssKeyGenResponse {
    return { keygen: isSet(object.keygen) ? KeyGen.fromJSON(object.keygen) : undefined };
  },

  toJSON(message: LastTssKeyGenResponse): unknown {
    const obj: any = {};
    if (message.keygen !== undefined) {
      obj.keygen = KeyGen.toJSON(message.keygen);
    }
    return obj;
  },

  create(base?: DeepPartial<LastTssKeyGenResponse>): LastTssKeyGenResponse {
    return LastTssKeyGenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LastTssKeyGenResponse>): LastTssKeyGenResponse {
    const message = createBaseLastTssKeyGenResponse();
    message.keygen = (object.keygen !== undefined && object.keygen !== null)
      ? KeyGen.fromPartial(object.keygen)
      : undefined;
    return message;
  },
};

function createBaseQueryTssKeyGenRequest(): QueryTssKeyGenRequest {
  return { keygenId: "" };
}

export const QueryTssKeyGenRequest: MessageFns<QueryTssKeyGenRequest> = {
  encode(message: QueryTssKeyGenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keygenId !== "") {
      writer.uint32(10).string(message.keygenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTssKeyGenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTssKeyGenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTssKeyGenRequest {
    return { keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "" };
  },

  toJSON(message: QueryTssKeyGenRequest): unknown {
    const obj: any = {};
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTssKeyGenRequest>): QueryTssKeyGenRequest {
    return QueryTssKeyGenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTssKeyGenRequest>): QueryTssKeyGenRequest {
    const message = createBaseQueryTssKeyGenRequest();
    message.keygenId = object.keygenId ?? "";
    return message;
  },
};

function createBaseQueryTssKeyGenResponse(): QueryTssKeyGenResponse {
  return { keygen: undefined };
}

export const QueryTssKeyGenResponse: MessageFns<QueryTssKeyGenResponse> = {
  encode(message: QueryTssKeyGenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keygen !== undefined) {
      KeyGen.encode(message.keygen, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTssKeyGenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTssKeyGenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keygen = KeyGen.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTssKeyGenResponse {
    return { keygen: isSet(object.keygen) ? KeyGen.fromJSON(object.keygen) : undefined };
  },

  toJSON(message: QueryTssKeyGenResponse): unknown {
    const obj: any = {};
    if (message.keygen !== undefined) {
      obj.keygen = KeyGen.toJSON(message.keygen);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTssKeyGenResponse>): QueryTssKeyGenResponse {
    return QueryTssKeyGenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTssKeyGenResponse>): QueryTssKeyGenResponse {
    const message = createBaseQueryTssKeyGenResponse();
    message.keygen = (object.keygen !== undefined && object.keygen !== null)
      ? KeyGen.fromPartial(object.keygen)
      : undefined;
    return message;
  },
};

function createBaseQueryTssKeyGensRequest(): QueryTssKeyGensRequest {
  return { pagination: undefined, finalizedOnly: false };
}

export const QueryTssKeyGensRequest: MessageFns<QueryTssKeyGensRequest> = {
  encode(message: QueryTssKeyGensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    if (message.finalizedOnly !== false) {
      writer.uint32(16).bool(message.finalizedOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTssKeyGensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTssKeyGensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finalizedOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTssKeyGensRequest {
    return {
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
      finalizedOnly: isSet(object.finalizedOnly) ? globalThis.Boolean(object.finalizedOnly) : false,
    };
  },

  toJSON(message: QueryTssKeyGensRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    if (message.finalizedOnly !== false) {
      obj.finalizedOnly = message.finalizedOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTssKeyGensRequest>): QueryTssKeyGensRequest {
    return QueryTssKeyGensRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTssKeyGensRequest>): QueryTssKeyGensRequest {
    const message = createBaseQueryTssKeyGensRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    message.finalizedOnly = object.finalizedOnly ?? false;
    return message;
  },
};

function createBaseQueryTssKeyGensResponse(): QueryTssKeyGensResponse {
  return { keygens: [], pagination: undefined };
}

export const QueryTssKeyGensResponse: MessageFns<QueryTssKeyGensResponse> = {
  encode(message: QueryTssKeyGensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keygens) {
      KeyGen.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTssKeyGensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTssKeyGensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keygens.push(KeyGen.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTssKeyGensResponse {
    return {
      keygens: globalThis.Array.isArray(object?.keygens) ? object.keygens.map((e: any) => KeyGen.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryTssKeyGensResponse): unknown {
    const obj: any = {};
    if (message.keygens?.length) {
      obj.keygens = message.keygens.map((e) => KeyGen.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTssKeyGensResponse>): QueryTssKeyGensResponse {
    return QueryTssKeyGensResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTssKeyGensResponse>): QueryTssKeyGensResponse {
    const message = createBaseQueryTssKeyGensResponse();
    message.keygens = object.keygens?.map((e) => KeyGen.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseChainBalancesRequest(): ChainBalancesRequest {
  return { chainId: "" };
}

export const ChainBalancesRequest: MessageFns<ChainBalancesRequest> = {
  encode(message: ChainBalancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainBalancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainBalancesRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: ChainBalancesRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create(base?: DeepPartial<ChainBalancesRequest>): ChainBalancesRequest {
    return ChainBalancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainBalancesRequest>): ChainBalancesRequest {
    const message = createBaseChainBalancesRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseChainBalancesResponse(): ChainBalancesResponse {
  return { chainWallet: "", balances: [] };
}

export const ChainBalancesResponse: MessageFns<ChainBalancesResponse> = {
  encode(message: ChainBalancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainWallet !== "") {
      writer.uint32(10).string(message.chainWallet);
    }
    for (const v of message.balances) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainBalancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainBalancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainWallet = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.balances.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainBalancesResponse {
    return {
      chainWallet: isSet(object.chainWallet) ? globalThis.String(object.chainWallet) : "",
      balances: globalThis.Array.isArray(object?.balances) ? object.balances.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChainBalancesResponse): unknown {
    const obj: any = {};
    if (message.chainWallet !== "") {
      obj.chainWallet = message.chainWallet;
    }
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChainBalancesResponse>): ChainBalancesResponse {
    return ChainBalancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainBalancesResponse>): ChainBalancesResponse {
    const message = createBaseChainBalancesResponse();
    message.chainWallet = object.chainWallet ?? "";
    message.balances = object.balances?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryInboundTransferRequest(): QueryInboundTransferRequest {
  return { transferId: "" };
}

export const QueryInboundTransferRequest: MessageFns<QueryInboundTransferRequest> = {
  encode(message: QueryInboundTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryInboundTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInboundTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryInboundTransferRequest {
    return { transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "" };
  },

  toJSON(message: QueryInboundTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryInboundTransferRequest>): QueryInboundTransferRequest {
    return QueryInboundTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryInboundTransferRequest>): QueryInboundTransferRequest {
    const message = createBaseQueryInboundTransferRequest();
    message.transferId = object.transferId ?? "";
    return message;
  },
};

function createBaseQueryInboundTransferResponse(): QueryInboundTransferResponse {
  return { inboundTransfer: undefined };
}

export const QueryInboundTransferResponse: MessageFns<QueryInboundTransferResponse> = {
  encode(message: QueryInboundTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inboundTransfer !== undefined) {
      InboundTransfer.encode(message.inboundTransfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryInboundTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInboundTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inboundTransfer = InboundTransfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryInboundTransferResponse {
    return {
      inboundTransfer: isSet(object.inboundTransfer) ? InboundTransfer.fromJSON(object.inboundTransfer) : undefined,
    };
  },

  toJSON(message: QueryInboundTransferResponse): unknown {
    const obj: any = {};
    if (message.inboundTransfer !== undefined) {
      obj.inboundTransfer = InboundTransfer.toJSON(message.inboundTransfer);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryInboundTransferResponse>): QueryInboundTransferResponse {
    return QueryInboundTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryInboundTransferResponse>): QueryInboundTransferResponse {
    const message = createBaseQueryInboundTransferResponse();
    message.inboundTransfer = (object.inboundTransfer !== undefined && object.inboundTransfer !== null)
      ? InboundTransfer.fromPartial(object.inboundTransfer)
      : undefined;
    return message;
  },
};

function createBaseQueryInboundTransfersRequest(): QueryInboundTransfersRequest {
  return { pagination: undefined };
}

export const QueryInboundTransfersRequest: MessageFns<QueryInboundTransfersRequest> = {
  encode(message: QueryInboundTransfersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryInboundTransfersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInboundTransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryInboundTransfersRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryInboundTransfersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryInboundTransfersRequest>): QueryInboundTransfersRequest {
    return QueryInboundTransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryInboundTransfersRequest>): QueryInboundTransfersRequest {
    const message = createBaseQueryInboundTransfersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryInboundTransfersResponse(): QueryInboundTransfersResponse {
  return { transfers: [], pagination: undefined };
}

export const QueryInboundTransfersResponse: MessageFns<QueryInboundTransfersResponse> = {
  encode(message: QueryInboundTransfersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transfers) {
      InboundTransfer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryInboundTransfersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInboundTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfers.push(InboundTransfer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryInboundTransfersResponse {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => InboundTransfer.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryInboundTransfersResponse): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => InboundTransfer.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryInboundTransfersResponse>): QueryInboundTransfersResponse {
    return QueryInboundTransfersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryInboundTransfersResponse>): QueryInboundTransfersResponse {
    const message = createBaseQueryInboundTransfersResponse();
    message.transfers = object.transfers?.map((e) => InboundTransfer.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryOutboundTransferRequest(): QueryOutboundTransferRequest {
  return { txHash: "" };
}

export const QueryOutboundTransferRequest: MessageFns<QueryOutboundTransferRequest> = {
  encode(message: QueryOutboundTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutboundTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutboundTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutboundTransferRequest {
    return { txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "" };
  },

  toJSON(message: QueryOutboundTransferRequest): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOutboundTransferRequest>): QueryOutboundTransferRequest {
    return QueryOutboundTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryOutboundTransferRequest>): QueryOutboundTransferRequest {
    const message = createBaseQueryOutboundTransferRequest();
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseQueryOutboundTransferResponse(): QueryOutboundTransferResponse {
  return { outboundTransfer: undefined };
}

export const QueryOutboundTransferResponse: MessageFns<QueryOutboundTransferResponse> = {
  encode(message: QueryOutboundTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outboundTransfer !== undefined) {
      OutboundTransfer.encode(message.outboundTransfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutboundTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutboundTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outboundTransfer = OutboundTransfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutboundTransferResponse {
    return {
      outboundTransfer: isSet(object.outboundTransfer) ? OutboundTransfer.fromJSON(object.outboundTransfer) : undefined,
    };
  },

  toJSON(message: QueryOutboundTransferResponse): unknown {
    const obj: any = {};
    if (message.outboundTransfer !== undefined) {
      obj.outboundTransfer = OutboundTransfer.toJSON(message.outboundTransfer);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOutboundTransferResponse>): QueryOutboundTransferResponse {
    return QueryOutboundTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryOutboundTransferResponse>): QueryOutboundTransferResponse {
    const message = createBaseQueryOutboundTransferResponse();
    message.outboundTransfer = (object.outboundTransfer !== undefined && object.outboundTransfer !== null)
      ? OutboundTransfer.fromPartial(object.outboundTransfer)
      : undefined;
    return message;
  },
};

function createBaseQueryOutboundTransfersRequest(): QueryOutboundTransfersRequest {
  return { pagination: undefined };
}

export const QueryOutboundTransfersRequest: MessageFns<QueryOutboundTransfersRequest> = {
  encode(message: QueryOutboundTransfersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutboundTransfersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutboundTransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutboundTransfersRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryOutboundTransfersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOutboundTransfersRequest>): QueryOutboundTransfersRequest {
    return QueryOutboundTransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryOutboundTransfersRequest>): QueryOutboundTransfersRequest {
    const message = createBaseQueryOutboundTransfersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryOutboundTransfersResponse(): QueryOutboundTransfersResponse {
  return { transfers: [], pagination: undefined };
}

export const QueryOutboundTransfersResponse: MessageFns<QueryOutboundTransfersResponse> = {
  encode(message: QueryOutboundTransfersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transfers) {
      OutboundTransfer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOutboundTransfersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOutboundTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfers.push(OutboundTransfer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOutboundTransfersResponse {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => OutboundTransfer.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryOutboundTransfersResponse): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => OutboundTransfer.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOutboundTransfersResponse>): QueryOutboundTransfersResponse {
    return QueryOutboundTransfersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryOutboundTransfersResponse>): QueryOutboundTransfersResponse {
    const message = createBaseQueryOutboundTransfersResponse();
    message.transfers = object.transfers?.map((e) => OutboundTransfer.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseCanTransferRequest(): CanTransferRequest {
  return { srcChainId: "", destChainId: "", assetId: "", amount: "" };
}

export const CanTransferRequest: MessageFns<CanTransferRequest> = {
  encode(message: CanTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.srcChainId !== "") {
      writer.uint32(10).string(message.srcChainId);
    }
    if (message.destChainId !== "") {
      writer.uint32(18).string(message.destChainId);
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CanTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CanTransferRequest {
    return {
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: CanTransferRequest): unknown {
    const obj: any = {};
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<CanTransferRequest>): CanTransferRequest {
    return CanTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CanTransferRequest>): CanTransferRequest {
    const message = createBaseCanTransferRequest();
    message.srcChainId = object.srcChainId ?? "";
    message.destChainId = object.destChainId ?? "";
    message.assetId = object.assetId ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseCanTransferResponse(): CanTransferResponse {
  return { canTransfer: false, reason: "" };
}

export const CanTransferResponse: MessageFns<CanTransferResponse> = {
  encode(message: CanTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canTransfer !== false) {
      writer.uint32(8).bool(message.canTransfer);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CanTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.canTransfer = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CanTransferResponse {
    return {
      canTransfer: isSet(object.canTransfer) ? globalThis.Boolean(object.canTransfer) : false,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CanTransferResponse): unknown {
    const obj: any = {};
    if (message.canTransfer !== false) {
      obj.canTransfer = message.canTransfer;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<CanTransferResponse>): CanTransferResponse {
    return CanTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CanTransferResponse>): CanTransferResponse {
    const message = createBaseCanTransferResponse();
    message.canTransfer = object.canTransfer ?? false;
    message.reason = object.reason ?? "";
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Params returns x/bridge module params. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** GetChains returns the list of chains that are supported by the bridge. */
  GetChains(request: QueryChainsRequest): Promise<QueryChainsResponse>;
  /** GetChain returns the chain with the given chain id. */
  GetChain(request: QueryChainRequest): Promise<QueryChainResponse>;
  /** GetAssets returns the list of assets that are supported by the bridge. */
  GetAssets(request: QueryAssetsRequest): Promise<QueryAssetsResponse>;
  /** GetAsset returns the asset with the given asset id. */
  GetAsset(request: QueryAssetRequest): Promise<QueryAssetResponse>;
  /**
   * LastTransferHeight returns the height of the external chain at which
   * the last transfer with the given asset was successfully completed
   * (finalized).
   */
  LastTransferHeight(request: LastTransferHeightRequest): Promise<LastTransferHeightResponse>;
  /** LastTssKeyGen returns the last TSS key generation. */
  LastTssKeyGen(request: LastTssKeyGenRequest): Promise<LastTssKeyGenResponse>;
  TssKeyGen(request: QueryTssKeyGenRequest): Promise<QueryTssKeyGenResponse>;
  /** GetTssKeyGens returns the list of TSS key generations. */
  TssKeyGens(request: QueryTssKeyGensRequest): Promise<QueryTssKeyGensResponse>;
  /**
   * ChainBalances returns the balance of the locked coins on the given
   * chain.
   */
  ChainBalances(request: ChainBalancesRequest): Promise<ChainBalancesResponse>;
  /** InboundTransfer returns the inbound transfer with the given TransferId */
  InboundTransfer(request: QueryInboundTransferRequest): Promise<QueryInboundTransferResponse>;
  /** InboundTransfers returns all inbound transfers */
  InboundTransfers(request: QueryInboundTransfersRequest): Promise<QueryInboundTransfersResponse>;
  /**
   * OutboundTransfer returns the outbound transfer with the given int3face
   * transaction hash
   */
  OutboundTransfer(request: QueryOutboundTransferRequest): Promise<QueryOutboundTransferResponse>;
  /** OutboundTransfers returns all outbound transfers */
  OutboundTransfers(request: QueryOutboundTransfersRequest): Promise<QueryOutboundTransfersResponse>;
  /**
   * CanTransfer returns true if the asset can be transferred to the given
   * destination chain from the given source chain.
   */
  CanTransfer(request: CanTransferRequest): Promise<CanTransferResponse>;
  /** Proposal returns the proposal with the given proposal id. */
  Proposal(request: QueryProposalRequest): Promise<QueryProposalResponse>;
  /** Proposals returns the bridge module proposal with pagination. */
  Proposals(request: QueryProposalsRequest): Promise<QueryProposalsResponse>;
}

export const QueryServiceName = "int3face.bridge.v1beta1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.GetChains = this.GetChains.bind(this);
    this.GetChain = this.GetChain.bind(this);
    this.GetAssets = this.GetAssets.bind(this);
    this.GetAsset = this.GetAsset.bind(this);
    this.LastTransferHeight = this.LastTransferHeight.bind(this);
    this.LastTssKeyGen = this.LastTssKeyGen.bind(this);
    this.TssKeyGen = this.TssKeyGen.bind(this);
    this.TssKeyGens = this.TssKeyGens.bind(this);
    this.ChainBalances = this.ChainBalances.bind(this);
    this.InboundTransfer = this.InboundTransfer.bind(this);
    this.InboundTransfers = this.InboundTransfers.bind(this);
    this.OutboundTransfer = this.OutboundTransfer.bind(this);
    this.OutboundTransfers = this.OutboundTransfers.bind(this);
    this.CanTransfer = this.CanTransfer.bind(this);
    this.Proposal = this.Proposal.bind(this);
    this.Proposals = this.Proposals.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  GetChains(request: QueryChainsRequest): Promise<QueryChainsResponse> {
    const data = QueryChainsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChains", data);
    return promise.then((data) => QueryChainsResponse.decode(new BinaryReader(data)));
  }

  GetChain(request: QueryChainRequest): Promise<QueryChainResponse> {
    const data = QueryChainRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChain", data);
    return promise.then((data) => QueryChainResponse.decode(new BinaryReader(data)));
  }

  GetAssets(request: QueryAssetsRequest): Promise<QueryAssetsResponse> {
    const data = QueryAssetsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAssets", data);
    return promise.then((data) => QueryAssetsResponse.decode(new BinaryReader(data)));
  }

  GetAsset(request: QueryAssetRequest): Promise<QueryAssetResponse> {
    const data = QueryAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAsset", data);
    return promise.then((data) => QueryAssetResponse.decode(new BinaryReader(data)));
  }

  LastTransferHeight(request: LastTransferHeightRequest): Promise<LastTransferHeightResponse> {
    const data = LastTransferHeightRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LastTransferHeight", data);
    return promise.then((data) => LastTransferHeightResponse.decode(new BinaryReader(data)));
  }

  LastTssKeyGen(request: LastTssKeyGenRequest): Promise<LastTssKeyGenResponse> {
    const data = LastTssKeyGenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LastTssKeyGen", data);
    return promise.then((data) => LastTssKeyGenResponse.decode(new BinaryReader(data)));
  }

  TssKeyGen(request: QueryTssKeyGenRequest): Promise<QueryTssKeyGenResponse> {
    const data = QueryTssKeyGenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TssKeyGen", data);
    return promise.then((data) => QueryTssKeyGenResponse.decode(new BinaryReader(data)));
  }

  TssKeyGens(request: QueryTssKeyGensRequest): Promise<QueryTssKeyGensResponse> {
    const data = QueryTssKeyGensRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TssKeyGens", data);
    return promise.then((data) => QueryTssKeyGensResponse.decode(new BinaryReader(data)));
  }

  ChainBalances(request: ChainBalancesRequest): Promise<ChainBalancesResponse> {
    const data = ChainBalancesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChainBalances", data);
    return promise.then((data) => ChainBalancesResponse.decode(new BinaryReader(data)));
  }

  InboundTransfer(request: QueryInboundTransferRequest): Promise<QueryInboundTransferResponse> {
    const data = QueryInboundTransferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InboundTransfer", data);
    return promise.then((data) => QueryInboundTransferResponse.decode(new BinaryReader(data)));
  }

  InboundTransfers(request: QueryInboundTransfersRequest): Promise<QueryInboundTransfersResponse> {
    const data = QueryInboundTransfersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InboundTransfers", data);
    return promise.then((data) => QueryInboundTransfersResponse.decode(new BinaryReader(data)));
  }

  OutboundTransfer(request: QueryOutboundTransferRequest): Promise<QueryOutboundTransferResponse> {
    const data = QueryOutboundTransferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OutboundTransfer", data);
    return promise.then((data) => QueryOutboundTransferResponse.decode(new BinaryReader(data)));
  }

  OutboundTransfers(request: QueryOutboundTransfersRequest): Promise<QueryOutboundTransfersResponse> {
    const data = QueryOutboundTransfersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OutboundTransfers", data);
    return promise.then((data) => QueryOutboundTransfersResponse.decode(new BinaryReader(data)));
  }

  CanTransfer(request: CanTransferRequest): Promise<CanTransferResponse> {
    const data = CanTransferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CanTransfer", data);
    return promise.then((data) => CanTransferResponse.decode(new BinaryReader(data)));
  }

  Proposal(request: QueryProposalRequest): Promise<QueryProposalResponse> {
    const data = QueryProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Proposal", data);
    return promise.then((data) => QueryProposalResponse.decode(new BinaryReader(data)));
  }

  Proposals(request: QueryProposalsRequest): Promise<QueryProposalsResponse> {
    const data = QueryProposalsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Proposals", data);
    return promise.then((data) => QueryProposalsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
