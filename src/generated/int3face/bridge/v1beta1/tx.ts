// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: int3face/bridge/v1beta1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  AssetID,
  AssetStatus,
  assetStatusFromJSON,
  assetStatusToJSON,
  ContractAssetId,
  ContractAssetParams,
  ContractFee,
  ContractSigners,
  ContractStatus,
  contractStatusFromJSON,
  contractStatusToJSON,
  ContractUpgradeData,
  IbcForwardingParams,
} from "./bridge";
import {
  MsgAddChain,
  MsgAddChainAsset,
  MsgAddChainAssetResponse,
  MsgAddChainResponse,
  MsgBurnAsset,
  MsgBurnAssetResponse,
  MsgCreateAsset,
  MsgCreateAssetResponse,
  MsgMintAsset,
  MsgMintAssetResponse,
  MsgPruneSmartContractChainContract,
  MsgPruneSmartContractChainContractResponse,
  MsgRemoveAsset,
  MsgRemoveAssetResponse,
  MsgRemoveChain,
  MsgRemoveChainAsset,
  MsgRemoveChainAssetResponse,
  MsgRemoveChainResponse,
  MsgResolveQuarantinedTransfers,
  MsgResolveQuarantinedTransfersResponse,
  MsgSetChainConfirmationsRequired,
  MsgSetChainConfirmationsRequiredResponse,
  MsgSetChainGasParams,
  MsgSetChainGasParamsResponse,
  MsgSetChainParams,
  MsgSetChainParamsResponse,
  MsgSetChainSigners,
  MsgSetChainSignersResponse,
  MsgSetSmartContractChainAssetsDestChainIds,
  MsgSetSmartContractChainAssetsDestChainIdsResponse,
  MsgSetUtxoChainRelayerParams,
  MsgSetUtxoChainRelayerParamsResponse,
  MsgSubmitProposalResult,
  MsgSubmitProposalResultResponse,
  MsgTssKeyGen,
  MsgTssKeyGenResponse,
  MsgTssKeyGenResult,
  MsgTssKeyGenResultResponse,
  MsgTssVaultMigration,
  MsgTssVaultMigrationResponse,
  MsgTssVaultUpdate,
  MsgTssVaultUpdateResponse,
  MsgUpdateAssetMinTransferAmount,
  MsgUpdateAssetMinTransferAmountResponse,
  MsgUpdateAssetStatus,
  MsgUpdateAssetStatusResponse,
  MsgUpdateBridgeStatus,
  MsgUpdateBridgeStatusResponse,
  MsgUpdateChainAssetStatus,
  MsgUpdateChainAssetStatusResponse,
  MsgUpdateChainRetryParams,
  MsgUpdateChainRetryParamsResponse,
  MsgUpdateChainStatus,
  MsgUpdateChainStatusResponse,
  MsgUpdateIbcChainAssetParams,
  MsgUpdateIbcChainAssetParamsResponse,
  MsgUpdateIbcChainParams,
  MsgUpdateIbcChainParamsResponse,
  MsgUpdateNttChainAssetAddresses,
  MsgUpdateNttChainAssetAddressesResponse,
  MsgUpdateNttChainParams,
  MsgUpdateNttChainParamsResponse,
  MsgUpgradeSmartContractChainContract,
  MsgUpgradeSmartContractChainContractResponse,
} from "./proposals";

export const protobufPackage = "int3face.bridge.v1beta1";

/**
 * MsgInboundTransfer defines the message structure for the InboundTransfer gRPC
 * service method. It allows a sender to perform an inbound cross-chain
 * transfer, i.e., to transfer their tokens from the source chain to Int3face
 * and get the equivalent amount of the corresponding token (specified in
 * subdenom) on Int3face in return. The tokens are minted through the
 * x/tokenfactory module to the destination address.
 */
export interface MsgInboundTransfer {
  /**
   * ExternalId is a unique ID of the transfer coming from outside.
   * Serves the purpose of uniquely identifying the transfer in another chain
   * (e.g., this might be the BTC tx hash)
   */
  externalId: string;
  /**
   * ExternalHeight is the height at which the transfer occurred in the external
   * chain
   */
  externalHeight: Long;
  /** Sender is a sender's address */
  sender: string;
  /** DestAddr is a destination Int3face address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  /**
   * DestChainId is a destination chain of the transfer. If this id is not
   * Int3face chain, we need to perform forwarding of the tokens to the
   * destination chain.
   */
  destChainId: string;
  /** SrcChainId is a source chain of the transfer. */
  srcChainId: string;
}

export interface MsgInboundTransferResponse {
}

export interface MsgInboundTransferRetry {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** SrcChainId is a source chain of the transfer */
  srcChainId: string;
  /**
   * ExternalId is a unique ID of the transfer coming from outside.
   * Serves the purpose of uniquely identifying the transfer in another chain
   * (e.g., this might be the BTC tx hash)
   */
  externalId: string;
  /**
   * ExternalHeight is the height at which the transfer occurred in the external
   * chain
   */
  externalHeight: Long;
}

export interface MsgInboundTransferRetryResponse {
}

export interface MsgIbcInboundTransfer {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** DestAddr is a destination address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  /** DestChainId is a destination chain of the transfer. */
  destChainId: string;
  /** SrcChainId is a source chain of the transfer. */
  srcChainId: string;
  /** SourceChannel is a source channel from which the transfer is coming */
  sourceChannel: string;
  /** DestChannel is a destination channel to which the transfer is going */
  destChannel: string;
  /** Sequence is a sequence number of the transfer */
  sequence: Long;
}

export interface MsgIbcInboundTransferResponse {
}

/**
 * MsgForceInboundTransfer defines the message structure for the
 * ForceInboundTransfer gRPC service method. It allows an inbound cross-chain
 * transfer, i.e., to transfer their tokens from the source chain to Int3face
 * and get the equivalent amount of the corresponding token (specified in
 * subdenom) on Int3face in return authorized by the gov module. The tokens are
 * minted through the x/tokenfactory module to the destination address.
 */
export interface MsgForceInboundTransfer {
  /**
   * ExternalId is a unique ID of the transfer coming from outside.
   * Serves the purpose of uniquely identifying the transfer in another chain
   * (e.g., this might be the BTC tx hash)
   */
  externalId: string;
  /**
   * ExternalHeight is the height at which the transfer occurred in the external
   * chain
   */
  externalHeight: Long;
  /** Sender is a sender's address */
  sender: string;
  /** DestAddr is a destination Int3face address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  /**
   * DestChainId is a destination chain of the transfer. If this id is not
   * Int3face chain, we need to perform forwarding of the tokens to the
   * destination chain.
   */
  destChainId: string;
  /** SrcChainId is a source chain of the transfer. */
  srcChainId: string;
}

export interface MsgForceInboundTransferResponse {
}

/**
 * MsgOutboundTransfer defines the message structure for the OutboundTransfer
 * gRPC service method. It allows a sender to perform an outbound cross-chain
 * transfer, i.e., to transfer their tokens from Int3face to the destination
 * chain. The tokens are burned through the x/tokenfactory module from the
 * sender's address.
 */
export interface MsgOutboundTransfer {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** DestAddr is a destination address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  /** DestChainId is a destination chain of the transfer. */
  destChainId: string;
}

export interface MsgOutboundTransferResponse {
}

/**
 * MsgOutboundTransferRetry defines the message structure for the
 * OutboundTransferRetry gRPC service method. It allows a sender to perform a
 * retry for the outbound cross-chain transfer.
 */
export interface MsgOutboundTransferRetry {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** TransferHash of the transfer to retry */
  transferHash: string;
}

export interface MsgOutboundTransferRetryResponse {
}

export interface MsgOutboundTransferResult {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** TxHash of the outbound transaction hash on Int3face chain */
  txHash: string;
  /**
   * Result is oneof structure that contains the result of the outbound transfer
   * handling
   */
  result: OutboundTransferResult | undefined;
}

export interface OutboundTransferResult {
  /** Success is the new encoded contract data. */
  success?:
    | OutboundTransferResultSuccess
    | undefined;
  /** Failure is the new encoded contract data. */
  failure?: OutboundTransferResultFailure | undefined;
}

export interface OutboundTransferResultSuccess {
  /**
   * BroadcastedTx is the transaction hash of the broadcasted tx to external
   * chain
   */
  broadcastedTx: string;
}

export interface OutboundTransferResultFailure {
}

export interface MsgOutboundTransferResultResponse {
}

export interface MsgUpdateParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /**
   * VotesNeeded marks how many signers out of the list of signers need
   * to sign until a tx can be considered finalized
   */
  votesNeeded: Long;
  /**
   * Fee defines a param for fee that go towards the validator set
   * signing the incoming/outgoing txs. The fee is measured as a ratio,
   * so its value lies between 0 and 1.
   */
  fee: string;
}

export interface MsgUpdateParamsResponse {
}

/**
 * MsgUpdateSigners defines the message structure for the UpdateSigners gRPC
 * method. It allows to update signers in the signers pool
 */
export interface MsgUpdateSigners {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** NewSigners is a list of signers to set in the module */
  newSigners: string[];
}

export interface MsgUpdateSignersResponse {
}

export interface MsgUpdateIbcForwardingParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** Params is the new IBC forwarding params */
  params: IbcForwardingParams[];
}

export interface MsgUpdateIbcForwardingParamsResponse {
}

/** MsgChangeAssetStatus changes the status of the provided asset. */
export interface MsgChangeAssetStatus {
  /** Sender is a sender's address */
  sender: string;
  /**
   * AssetID is the ID of the asset to update.
   * The asset should be known; otherwise, the method will failed.
   */
  assetId:
    | AssetID
    | undefined;
  /** NewStatus is a new asset's status. */
  newStatus: AssetStatus;
}

export interface MsgChangeAssetStatusResponse {
}

/** MsgKeyGen triggers the key generation for the TSS committee. */
export interface MsgKeyGen {
  /** Sender is a sender's Int3face address */
  sender: string;
  /**
   * ParticipantsAddrs is a list of observers' addresses that we expect
   * to include in the next committee.
   */
  participantsAddrs: string[];
  /**
   * Randomness is used in the leader election during the key generation
   * process and can be considered a deterministic source of entropy for all
   * peers. Essentially, just a random number.
   */
  randomness: Long;
}

export interface MsgKeyGenResponse {
}

export interface MsgSubmitKeyGenResult {
  /**
   * Sender is a sender's address. Must be part of the original ParticipantsPKs
   * list.
   */
  sender: string;
  /**
   * KeygenID is a unique identifier for the original keygen. May be either
   * proposal ID or keygen tx hash.
   */
  keygenId: string;
  /**
   * ParticipantsAddrs is a list of observers' addresses participating
   * in the newly generated committee.
   */
  participantsAddrs: string[];
  /** PoolPK is a newly generated pool public key of the committee. */
  poolPk: string;
}

export interface MsgSubmitKeyGenResultResponse {
}

export interface MsgUpdateContractSigners {
  /** Sender is a sender's Int3face address. */
  sender: string;
  /** Signers is a list of observer's addresses for each chain to update. */
  signers: ContractSigners[];
}

export interface MsgUpdateContractSignersResponse {
}

export interface MsgSubmitUpdateContractSignersResult {
  /** Sender is a sender's address. */
  sender: string;
  /** UpdateId is a unique identifier for the update reqeust. */
  updateId: string;
  /** Signers is a list of observer's addresses for each chain updated. */
  signers: ContractSigners[];
}

export interface MsgSubmitUpdateContractSignersResultResponse {
}

export interface MsgUpdateContractParams {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** ContractAddress is an address of the bridge contract. */
  contractAddress: string;
  /**
   * Deprecated: use params instead. MinTransferAmount is minimal transfer
   * amount for the bridge contract.
   */
  minTransferAmount: string;
  /** Fees is new fees amounts for the bridge contract operations. */
  fees: ContractFee[];
  /** Params is the list of new parameters for the chain assets. */
  assetParams: ContractAssetParams[];
}

export interface MsgUpdateContractParamsResponse {
}

export interface MsgSubmitUpdateContractParamsResult {
  /** Sender is a sender's address. */
  sender: string;
  /** UpdateId is a unique identifier for the update request. */
  updateId: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** ContractAddress is an address of the bridge contract. */
  contractAddress: string;
  /**
   * Deprecated: use params instead. MinTransferAmount is minimal transfer
   * amount for the bridge contract.
   */
  minTransferAmount: string;
  /** Fees is new fees amounts for the bridge contract operations. */
  fees: ContractFee[];
  /** Params is the list of new parameters for the chain assets. */
  assetParams: ContractAssetParams[];
}

export interface MsgSubmitUpdateContractParamsResultResponse {
}

export interface MsgUpdateContractStatus {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** Status is a new status of the bridge contract. */
  status: ContractStatus;
}

export interface MsgUpdateContractStatusResponse {
}

export interface MsgSubmitUpdateContractStatusResult {
  /** Sender is a sender's address. */
  sender: string;
  /** UpdateId is a unique identifier of the update. */
  updateId: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** Status is a new status of the bridge contract. */
  status: ContractStatus;
}

export interface MsgSubmitUpdateContractStatusResultResponse {
}

export interface MsgPruneContract {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to prune. */
  chainId: string;
  /** PruneBefore is a timestamp before which the data should be pruned. */
  pruneBefore: Long;
}

export interface MsgPruneContractResponse {
}

export interface MsgSubmitPruneContractResult {
  /** Sender is a sender's address. */
  sender: string;
  /** PruneId is a unique identifier for the prune request. */
  pruneId: string;
  /** ChainId is a id of the chain to prune. */
  chainId: string;
  /** PruneBefore is a timestamp before which the data should be pruned. */
  pruneBefore: Long;
}

export interface MsgSubmitPruneContractResultResponse {
}

export interface MsgUpgradeContract {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to upgrade. */
  chainId: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractData: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractCode: string;
  /**
   * ContractUpgradeData is the encoded contract data related to the concrete
   * chain.
   */
  upgradeData: ContractUpgradeData | undefined;
}

export interface MsgUpgradeContractResponse {
}

export interface MsgSubmitUpgradeContractResult {
  /** Sender is a sender's address. */
  sender: string;
  /** UpgradeId is a unique identifier for the prune request. */
  upgradeId: string;
  /** ChainId is a id of the chain to upgrade. */
  chainId: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractData: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractCode: string;
  /**
   * ContractUpgradeData is the encoded contract data related to the concrete
   * chain.
   */
  upgradeData: ContractUpgradeData | undefined;
}

export interface MsgSubmitUpgradeContractResultResponse {
}

export interface MsgAddContractAssets {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /**
   * NewAssets is the list of new assets parameters to add to the bridge
   * contract.
   */
  newAssets: ContractAssetParams[];
}

export interface MsgAddContractAssetsResponse {
}

export interface MsgSubmitAddContractAssetsResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /**
   * NewAssets is the list of new assets parameters to add to the bridge
   * contract.
   */
  newAssets: ContractAssetParams[];
}

export interface MsgSubmitAddContractAssetsResultResponse {
}

export interface MsgDeleteContractAsset {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** AssetAddress is the address of the asset to delete. */
  assetAddress: string;
}

export interface MsgDeleteContractAssetResponse {
}

export interface MsgSubmitDeleteContractAssetResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** AssetAddress is the address of the asset to delete. */
  assetAddress: string;
}

export interface MsgSubmitDeleteContractAssetResultResponse {
}

export interface MsgWhitelistContractAsset {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to whitelist asset. */
  chainId: string;
  /** Asset is the asset to whitelist. */
  asset: ContractAssetId | undefined;
}

export interface MsgWhitelistContractAssetResponse {
}

export interface MsgSubmitWhitelistContractAssetResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is a id of the chain to whitelist asset. */
  chainId: string;
  /** Asset is the asset to whitelist. */
  asset: ContractAssetId | undefined;
}

export interface MsgSubmitWhitelistContractAssetResultResponse {
}

export interface MsgUnwhitelistContractAsset {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to unwhitelist asset. */
  chainId: string;
  /** Asset is the asset to unwhitelist. */
  asset: ContractAssetId | undefined;
}

export interface MsgUnwhitelistContractAssetResponse {
}

export interface MsgSubmitUnwhitelistContractAssetResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is a id of the chain to unwhitelist asset. */
  chainId: string;
  /** Asset is the asset to unwhitelist. */
  asset: ContractAssetId | undefined;
}

export interface MsgSubmitUnwhitelistContractAssetResultResponse {
}

function createBaseMsgInboundTransfer(): MsgInboundTransfer {
  return {
    externalId: "",
    externalHeight: Long.UZERO,
    sender: "",
    destAddr: "",
    assetId: undefined,
    amount: "",
    destChainId: "",
    srcChainId: "",
  };
}

export const MsgInboundTransfer: MessageFns<MsgInboundTransfer> = {
  encode(message: MsgInboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalId !== "") {
      writer.uint32(10).string(message.externalId);
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.externalHeight.toString());
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(34).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(42).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(50).string(message.amount);
    }
    if (message.destChainId !== "") {
      writer.uint32(58).string(message.destChainId);
    }
    if (message.srcChainId !== "") {
      writer.uint32(66).string(message.srcChainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.externalHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInboundTransfer {
    return {
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      externalHeight: isSet(object.externalHeight) ? Long.fromValue(object.externalHeight) : Long.UZERO,
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
    };
  },

  toJSON(message: MsgInboundTransfer): unknown {
    const obj: any = {};
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      obj.externalHeight = (message.externalHeight || Long.UZERO).toString();
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgInboundTransfer>): MsgInboundTransfer {
    return MsgInboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgInboundTransfer>): MsgInboundTransfer {
    const message = createBaseMsgInboundTransfer();
    message.externalId = object.externalId ?? "";
    message.externalHeight = (object.externalHeight !== undefined && object.externalHeight !== null)
      ? Long.fromValue(object.externalHeight)
      : Long.UZERO;
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.destChainId = object.destChainId ?? "";
    message.srcChainId = object.srcChainId ?? "";
    return message;
  },
};

function createBaseMsgInboundTransferResponse(): MsgInboundTransferResponse {
  return {};
}

export const MsgInboundTransferResponse: MessageFns<MsgInboundTransferResponse> = {
  encode(_: MsgInboundTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInboundTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInboundTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgInboundTransferResponse {
    return {};
  },

  toJSON(_: MsgInboundTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInboundTransferResponse>): MsgInboundTransferResponse {
    return MsgInboundTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgInboundTransferResponse>): MsgInboundTransferResponse {
    const message = createBaseMsgInboundTransferResponse();
    return message;
  },
};

function createBaseMsgInboundTransferRetry(): MsgInboundTransferRetry {
  return { sender: "", srcChainId: "", externalId: "", externalHeight: Long.UZERO };
}

export const MsgInboundTransferRetry: MessageFns<MsgInboundTransferRetry> = {
  encode(message: MsgInboundTransferRetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.srcChainId !== "") {
      writer.uint32(18).string(message.srcChainId);
    }
    if (message.externalId !== "") {
      writer.uint32(26).string(message.externalId);
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.externalHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInboundTransferRetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInboundTransferRetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.externalHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInboundTransferRetry {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      externalHeight: isSet(object.externalHeight) ? Long.fromValue(object.externalHeight) : Long.UZERO,
    };
  },

  toJSON(message: MsgInboundTransferRetry): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      obj.externalHeight = (message.externalHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgInboundTransferRetry>): MsgInboundTransferRetry {
    return MsgInboundTransferRetry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgInboundTransferRetry>): MsgInboundTransferRetry {
    const message = createBaseMsgInboundTransferRetry();
    message.sender = object.sender ?? "";
    message.srcChainId = object.srcChainId ?? "";
    message.externalId = object.externalId ?? "";
    message.externalHeight = (object.externalHeight !== undefined && object.externalHeight !== null)
      ? Long.fromValue(object.externalHeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgInboundTransferRetryResponse(): MsgInboundTransferRetryResponse {
  return {};
}

export const MsgInboundTransferRetryResponse: MessageFns<MsgInboundTransferRetryResponse> = {
  encode(_: MsgInboundTransferRetryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInboundTransferRetryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInboundTransferRetryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgInboundTransferRetryResponse {
    return {};
  },

  toJSON(_: MsgInboundTransferRetryResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInboundTransferRetryResponse>): MsgInboundTransferRetryResponse {
    return MsgInboundTransferRetryResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgInboundTransferRetryResponse>): MsgInboundTransferRetryResponse {
    const message = createBaseMsgInboundTransferRetryResponse();
    return message;
  },
};

function createBaseMsgIbcInboundTransfer(): MsgIbcInboundTransfer {
  return {
    sender: "",
    destAddr: "",
    assetId: undefined,
    amount: "",
    destChainId: "",
    srcChainId: "",
    sourceChannel: "",
    destChannel: "",
    sequence: Long.UZERO,
  };
}

export const MsgIbcInboundTransfer: MessageFns<MsgIbcInboundTransfer> = {
  encode(message: MsgIbcInboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(18).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.destChainId !== "") {
      writer.uint32(42).string(message.destChainId);
    }
    if (message.srcChainId !== "") {
      writer.uint32(50).string(message.srcChainId);
    }
    if (message.sourceChannel !== "") {
      writer.uint32(58).string(message.sourceChannel);
    }
    if (message.destChannel !== "") {
      writer.uint32(66).string(message.destChannel);
    }
    if (!message.sequence.equals(Long.UZERO)) {
      writer.uint32(72).uint64(message.sequence.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIbcInboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIbcInboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sourceChannel = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.destChannel = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sequence = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgIbcInboundTransfer {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      sourceChannel: isSet(object.sourceChannel) ? globalThis.String(object.sourceChannel) : "",
      destChannel: isSet(object.destChannel) ? globalThis.String(object.destChannel) : "",
      sequence: isSet(object.sequence) ? Long.fromValue(object.sequence) : Long.UZERO,
    };
  },

  toJSON(message: MsgIbcInboundTransfer): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.sourceChannel !== "") {
      obj.sourceChannel = message.sourceChannel;
    }
    if (message.destChannel !== "") {
      obj.destChannel = message.destChannel;
    }
    if (!message.sequence.equals(Long.UZERO)) {
      obj.sequence = (message.sequence || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgIbcInboundTransfer>): MsgIbcInboundTransfer {
    return MsgIbcInboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgIbcInboundTransfer>): MsgIbcInboundTransfer {
    const message = createBaseMsgIbcInboundTransfer();
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.destChainId = object.destChainId ?? "";
    message.srcChainId = object.srcChainId ?? "";
    message.sourceChannel = object.sourceChannel ?? "";
    message.destChannel = object.destChannel ?? "";
    message.sequence = (object.sequence !== undefined && object.sequence !== null)
      ? Long.fromValue(object.sequence)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgIbcInboundTransferResponse(): MsgIbcInboundTransferResponse {
  return {};
}

export const MsgIbcInboundTransferResponse: MessageFns<MsgIbcInboundTransferResponse> = {
  encode(_: MsgIbcInboundTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIbcInboundTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIbcInboundTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgIbcInboundTransferResponse {
    return {};
  },

  toJSON(_: MsgIbcInboundTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgIbcInboundTransferResponse>): MsgIbcInboundTransferResponse {
    return MsgIbcInboundTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgIbcInboundTransferResponse>): MsgIbcInboundTransferResponse {
    const message = createBaseMsgIbcInboundTransferResponse();
    return message;
  },
};

function createBaseMsgForceInboundTransfer(): MsgForceInboundTransfer {
  return {
    externalId: "",
    externalHeight: Long.UZERO,
    sender: "",
    destAddr: "",
    assetId: undefined,
    amount: "",
    destChainId: "",
    srcChainId: "",
  };
}

export const MsgForceInboundTransfer: MessageFns<MsgForceInboundTransfer> = {
  encode(message: MsgForceInboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalId !== "") {
      writer.uint32(10).string(message.externalId);
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.externalHeight.toString());
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(34).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(42).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(50).string(message.amount);
    }
    if (message.destChainId !== "") {
      writer.uint32(58).string(message.destChainId);
    }
    if (message.srcChainId !== "") {
      writer.uint32(66).string(message.srcChainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgForceInboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgForceInboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.externalHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgForceInboundTransfer {
    return {
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      externalHeight: isSet(object.externalHeight) ? Long.fromValue(object.externalHeight) : Long.UZERO,
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
    };
  },

  toJSON(message: MsgForceInboundTransfer): unknown {
    const obj: any = {};
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      obj.externalHeight = (message.externalHeight || Long.UZERO).toString();
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgForceInboundTransfer>): MsgForceInboundTransfer {
    return MsgForceInboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgForceInboundTransfer>): MsgForceInboundTransfer {
    const message = createBaseMsgForceInboundTransfer();
    message.externalId = object.externalId ?? "";
    message.externalHeight = (object.externalHeight !== undefined && object.externalHeight !== null)
      ? Long.fromValue(object.externalHeight)
      : Long.UZERO;
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.destChainId = object.destChainId ?? "";
    message.srcChainId = object.srcChainId ?? "";
    return message;
  },
};

function createBaseMsgForceInboundTransferResponse(): MsgForceInboundTransferResponse {
  return {};
}

export const MsgForceInboundTransferResponse: MessageFns<MsgForceInboundTransferResponse> = {
  encode(_: MsgForceInboundTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgForceInboundTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgForceInboundTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgForceInboundTransferResponse {
    return {};
  },

  toJSON(_: MsgForceInboundTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgForceInboundTransferResponse>): MsgForceInboundTransferResponse {
    return MsgForceInboundTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgForceInboundTransferResponse>): MsgForceInboundTransferResponse {
    const message = createBaseMsgForceInboundTransferResponse();
    return message;
  },
};

function createBaseMsgOutboundTransfer(): MsgOutboundTransfer {
  return { sender: "", destAddr: "", assetId: undefined, amount: "", destChainId: "" };
}

export const MsgOutboundTransfer: MessageFns<MsgOutboundTransfer> = {
  encode(message: MsgOutboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(18).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.destChainId !== "") {
      writer.uint32(42).string(message.destChainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOutboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOutboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgOutboundTransfer {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
    };
  },

  toJSON(message: MsgOutboundTransfer): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgOutboundTransfer>): MsgOutboundTransfer {
    return MsgOutboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgOutboundTransfer>): MsgOutboundTransfer {
    const message = createBaseMsgOutboundTransfer();
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.destChainId = object.destChainId ?? "";
    return message;
  },
};

function createBaseMsgOutboundTransferResponse(): MsgOutboundTransferResponse {
  return {};
}

export const MsgOutboundTransferResponse: MessageFns<MsgOutboundTransferResponse> = {
  encode(_: MsgOutboundTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOutboundTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOutboundTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgOutboundTransferResponse {
    return {};
  },

  toJSON(_: MsgOutboundTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgOutboundTransferResponse>): MsgOutboundTransferResponse {
    return MsgOutboundTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgOutboundTransferResponse>): MsgOutboundTransferResponse {
    const message = createBaseMsgOutboundTransferResponse();
    return message;
  },
};

function createBaseMsgOutboundTransferRetry(): MsgOutboundTransferRetry {
  return { sender: "", transferHash: "" };
}

export const MsgOutboundTransferRetry: MessageFns<MsgOutboundTransferRetry> = {
  encode(message: MsgOutboundTransferRetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.transferHash !== "") {
      writer.uint32(18).string(message.transferHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOutboundTransferRetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOutboundTransferRetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transferHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgOutboundTransferRetry {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      transferHash: isSet(object.transferHash) ? globalThis.String(object.transferHash) : "",
    };
  },

  toJSON(message: MsgOutboundTransferRetry): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.transferHash !== "") {
      obj.transferHash = message.transferHash;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgOutboundTransferRetry>): MsgOutboundTransferRetry {
    return MsgOutboundTransferRetry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgOutboundTransferRetry>): MsgOutboundTransferRetry {
    const message = createBaseMsgOutboundTransferRetry();
    message.sender = object.sender ?? "";
    message.transferHash = object.transferHash ?? "";
    return message;
  },
};

function createBaseMsgOutboundTransferRetryResponse(): MsgOutboundTransferRetryResponse {
  return {};
}

export const MsgOutboundTransferRetryResponse: MessageFns<MsgOutboundTransferRetryResponse> = {
  encode(_: MsgOutboundTransferRetryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOutboundTransferRetryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOutboundTransferRetryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgOutboundTransferRetryResponse {
    return {};
  },

  toJSON(_: MsgOutboundTransferRetryResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgOutboundTransferRetryResponse>): MsgOutboundTransferRetryResponse {
    return MsgOutboundTransferRetryResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgOutboundTransferRetryResponse>): MsgOutboundTransferRetryResponse {
    const message = createBaseMsgOutboundTransferRetryResponse();
    return message;
  },
};

function createBaseMsgOutboundTransferResult(): MsgOutboundTransferResult {
  return { sender: "", txHash: "", result: undefined };
}

export const MsgOutboundTransferResult: MessageFns<MsgOutboundTransferResult> = {
  encode(message: MsgOutboundTransferResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.txHash !== "") {
      writer.uint32(18).string(message.txHash);
    }
    if (message.result !== undefined) {
      OutboundTransferResult.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOutboundTransferResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOutboundTransferResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = OutboundTransferResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgOutboundTransferResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      result: isSet(object.result) ? OutboundTransferResult.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: MsgOutboundTransferResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.result !== undefined) {
      obj.result = OutboundTransferResult.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgOutboundTransferResult>): MsgOutboundTransferResult {
    return MsgOutboundTransferResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgOutboundTransferResult>): MsgOutboundTransferResult {
    const message = createBaseMsgOutboundTransferResult();
    message.sender = object.sender ?? "";
    message.txHash = object.txHash ?? "";
    message.result = (object.result !== undefined && object.result !== null)
      ? OutboundTransferResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseOutboundTransferResult(): OutboundTransferResult {
  return { success: undefined, failure: undefined };
}

export const OutboundTransferResult: MessageFns<OutboundTransferResult> = {
  encode(message: OutboundTransferResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      OutboundTransferResultSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.failure !== undefined) {
      OutboundTransferResultFailure.encode(message.failure, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundTransferResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundTransferResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = OutboundTransferResultSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failure = OutboundTransferResultFailure.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundTransferResult {
    return {
      success: isSet(object.success) ? OutboundTransferResultSuccess.fromJSON(object.success) : undefined,
      failure: isSet(object.failure) ? OutboundTransferResultFailure.fromJSON(object.failure) : undefined,
    };
  },

  toJSON(message: OutboundTransferResult): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = OutboundTransferResultSuccess.toJSON(message.success);
    }
    if (message.failure !== undefined) {
      obj.failure = OutboundTransferResultFailure.toJSON(message.failure);
    }
    return obj;
  },

  create(base?: DeepPartial<OutboundTransferResult>): OutboundTransferResult {
    return OutboundTransferResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutboundTransferResult>): OutboundTransferResult {
    const message = createBaseOutboundTransferResult();
    message.success = (object.success !== undefined && object.success !== null)
      ? OutboundTransferResultSuccess.fromPartial(object.success)
      : undefined;
    message.failure = (object.failure !== undefined && object.failure !== null)
      ? OutboundTransferResultFailure.fromPartial(object.failure)
      : undefined;
    return message;
  },
};

function createBaseOutboundTransferResultSuccess(): OutboundTransferResultSuccess {
  return { broadcastedTx: "" };
}

export const OutboundTransferResultSuccess: MessageFns<OutboundTransferResultSuccess> = {
  encode(message: OutboundTransferResultSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.broadcastedTx !== "") {
      writer.uint32(10).string(message.broadcastedTx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundTransferResultSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundTransferResultSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.broadcastedTx = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundTransferResultSuccess {
    return { broadcastedTx: isSet(object.broadcastedTx) ? globalThis.String(object.broadcastedTx) : "" };
  },

  toJSON(message: OutboundTransferResultSuccess): unknown {
    const obj: any = {};
    if (message.broadcastedTx !== "") {
      obj.broadcastedTx = message.broadcastedTx;
    }
    return obj;
  },

  create(base?: DeepPartial<OutboundTransferResultSuccess>): OutboundTransferResultSuccess {
    return OutboundTransferResultSuccess.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutboundTransferResultSuccess>): OutboundTransferResultSuccess {
    const message = createBaseOutboundTransferResultSuccess();
    message.broadcastedTx = object.broadcastedTx ?? "";
    return message;
  },
};

function createBaseOutboundTransferResultFailure(): OutboundTransferResultFailure {
  return {};
}

export const OutboundTransferResultFailure: MessageFns<OutboundTransferResultFailure> = {
  encode(_: OutboundTransferResultFailure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundTransferResultFailure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundTransferResultFailure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OutboundTransferResultFailure {
    return {};
  },

  toJSON(_: OutboundTransferResultFailure): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<OutboundTransferResultFailure>): OutboundTransferResultFailure {
    return OutboundTransferResultFailure.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<OutboundTransferResultFailure>): OutboundTransferResultFailure {
    const message = createBaseOutboundTransferResultFailure();
    return message;
  },
};

function createBaseMsgOutboundTransferResultResponse(): MsgOutboundTransferResultResponse {
  return {};
}

export const MsgOutboundTransferResultResponse: MessageFns<MsgOutboundTransferResultResponse> = {
  encode(_: MsgOutboundTransferResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgOutboundTransferResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgOutboundTransferResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgOutboundTransferResultResponse {
    return {};
  },

  toJSON(_: MsgOutboundTransferResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgOutboundTransferResultResponse>): MsgOutboundTransferResultResponse {
    return MsgOutboundTransferResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgOutboundTransferResultResponse>): MsgOutboundTransferResultResponse {
    const message = createBaseMsgOutboundTransferResultResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { sender: "", votesNeeded: Long.UZERO, fee: "" };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.votesNeeded.toString());
    }
    if (message.fee !== "") {
      writer.uint32(26).string(message.fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.votesNeeded = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      votesNeeded: isSet(object.votesNeeded) ? Long.fromValue(object.votesNeeded) : Long.UZERO,
      fee: isSet(object.fee) ? globalThis.String(object.fee) : "",
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      obj.votesNeeded = (message.votesNeeded || Long.UZERO).toString();
    }
    if (message.fee !== "") {
      obj.fee = message.fee;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.sender = object.sender ?? "";
    message.votesNeeded = (object.votesNeeded !== undefined && object.votesNeeded !== null)
      ? Long.fromValue(object.votesNeeded)
      : Long.UZERO;
    message.fee = object.fee ?? "";
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateSigners(): MsgUpdateSigners {
  return { sender: "", newSigners: [] };
}

export const MsgUpdateSigners: MessageFns<MsgUpdateSigners> = {
  encode(message: MsgUpdateSigners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.newSigners) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateSigners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSigners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newSigners.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateSigners {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      newSigners: globalThis.Array.isArray(object?.newSigners)
        ? object.newSigners.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateSigners): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.newSigners?.length) {
      obj.newSigners = message.newSigners;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateSigners>): MsgUpdateSigners {
    return MsgUpdateSigners.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateSigners>): MsgUpdateSigners {
    const message = createBaseMsgUpdateSigners();
    message.sender = object.sender ?? "";
    message.newSigners = object.newSigners?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateSignersResponse(): MsgUpdateSignersResponse {
  return {};
}

export const MsgUpdateSignersResponse: MessageFns<MsgUpdateSignersResponse> = {
  encode(_: MsgUpdateSignersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateSignersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSignersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateSignersResponse {
    return {};
  },

  toJSON(_: MsgUpdateSignersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateSignersResponse>): MsgUpdateSignersResponse {
    return MsgUpdateSignersResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateSignersResponse>): MsgUpdateSignersResponse {
    const message = createBaseMsgUpdateSignersResponse();
    return message;
  },
};

function createBaseMsgUpdateIbcForwardingParams(): MsgUpdateIbcForwardingParams {
  return { sender: "", params: [] };
}

export const MsgUpdateIbcForwardingParams: MessageFns<MsgUpdateIbcForwardingParams> = {
  encode(message: MsgUpdateIbcForwardingParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.params) {
      IbcForwardingParams.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIbcForwardingParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIbcForwardingParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params.push(IbcForwardingParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateIbcForwardingParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => IbcForwardingParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateIbcForwardingParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => IbcForwardingParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateIbcForwardingParams>): MsgUpdateIbcForwardingParams {
    return MsgUpdateIbcForwardingParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateIbcForwardingParams>): MsgUpdateIbcForwardingParams {
    const message = createBaseMsgUpdateIbcForwardingParams();
    message.sender = object.sender ?? "";
    message.params = object.params?.map((e) => IbcForwardingParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateIbcForwardingParamsResponse(): MsgUpdateIbcForwardingParamsResponse {
  return {};
}

export const MsgUpdateIbcForwardingParamsResponse: MessageFns<MsgUpdateIbcForwardingParamsResponse> = {
  encode(_: MsgUpdateIbcForwardingParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIbcForwardingParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIbcForwardingParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateIbcForwardingParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateIbcForwardingParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateIbcForwardingParamsResponse>): MsgUpdateIbcForwardingParamsResponse {
    return MsgUpdateIbcForwardingParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateIbcForwardingParamsResponse>): MsgUpdateIbcForwardingParamsResponse {
    const message = createBaseMsgUpdateIbcForwardingParamsResponse();
    return message;
  },
};

function createBaseMsgChangeAssetStatus(): MsgChangeAssetStatus {
  return { sender: "", assetId: undefined, newStatus: 0 };
}

export const MsgChangeAssetStatus: MessageFns<MsgChangeAssetStatus> = {
  encode(message: MsgChangeAssetStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.newStatus !== 0) {
      writer.uint32(24).int32(message.newStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeAssetStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeAssetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangeAssetStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      newStatus: isSet(object.newStatus) ? assetStatusFromJSON(object.newStatus) : 0,
    };
  },

  toJSON(message: MsgChangeAssetStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.newStatus !== 0) {
      obj.newStatus = assetStatusToJSON(message.newStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgChangeAssetStatus>): MsgChangeAssetStatus {
    return MsgChangeAssetStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgChangeAssetStatus>): MsgChangeAssetStatus {
    const message = createBaseMsgChangeAssetStatus();
    message.sender = object.sender ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.newStatus = object.newStatus ?? 0;
    return message;
  },
};

function createBaseMsgChangeAssetStatusResponse(): MsgChangeAssetStatusResponse {
  return {};
}

export const MsgChangeAssetStatusResponse: MessageFns<MsgChangeAssetStatusResponse> = {
  encode(_: MsgChangeAssetStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeAssetStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeAssetStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgChangeAssetStatusResponse {
    return {};
  },

  toJSON(_: MsgChangeAssetStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgChangeAssetStatusResponse>): MsgChangeAssetStatusResponse {
    return MsgChangeAssetStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgChangeAssetStatusResponse>): MsgChangeAssetStatusResponse {
    const message = createBaseMsgChangeAssetStatusResponse();
    return message;
  },
};

function createBaseMsgKeyGen(): MsgKeyGen {
  return { sender: "", participantsAddrs: [], randomness: Long.UZERO };
}

export const MsgKeyGen: MessageFns<MsgKeyGen> = {
  encode(message: MsgKeyGen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.participantsAddrs) {
      writer.uint32(18).string(v!);
    }
    if (!message.randomness.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.randomness.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgKeyGen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgKeyGen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participantsAddrs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.randomness = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgKeyGen {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      participantsAddrs: globalThis.Array.isArray(object?.participantsAddrs)
        ? object.participantsAddrs.map((e: any) => globalThis.String(e))
        : [],
      randomness: isSet(object.randomness) ? Long.fromValue(object.randomness) : Long.UZERO,
    };
  },

  toJSON(message: MsgKeyGen): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.participantsAddrs?.length) {
      obj.participantsAddrs = message.participantsAddrs;
    }
    if (!message.randomness.equals(Long.UZERO)) {
      obj.randomness = (message.randomness || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgKeyGen>): MsgKeyGen {
    return MsgKeyGen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgKeyGen>): MsgKeyGen {
    const message = createBaseMsgKeyGen();
    message.sender = object.sender ?? "";
    message.participantsAddrs = object.participantsAddrs?.map((e) => e) || [];
    message.randomness = (object.randomness !== undefined && object.randomness !== null)
      ? Long.fromValue(object.randomness)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgKeyGenResponse(): MsgKeyGenResponse {
  return {};
}

export const MsgKeyGenResponse: MessageFns<MsgKeyGenResponse> = {
  encode(_: MsgKeyGenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgKeyGenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgKeyGenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgKeyGenResponse {
    return {};
  },

  toJSON(_: MsgKeyGenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgKeyGenResponse>): MsgKeyGenResponse {
    return MsgKeyGenResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgKeyGenResponse>): MsgKeyGenResponse {
    const message = createBaseMsgKeyGenResponse();
    return message;
  },
};

function createBaseMsgSubmitKeyGenResult(): MsgSubmitKeyGenResult {
  return { sender: "", keygenId: "", participantsAddrs: [], poolPk: "" };
}

export const MsgSubmitKeyGenResult: MessageFns<MsgSubmitKeyGenResult> = {
  encode(message: MsgSubmitKeyGenResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.keygenId !== "") {
      writer.uint32(18).string(message.keygenId);
    }
    for (const v of message.participantsAddrs) {
      writer.uint32(26).string(v!);
    }
    if (message.poolPk !== "") {
      writer.uint32(34).string(message.poolPk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitKeyGenResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitKeyGenResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participantsAddrs.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.poolPk = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitKeyGenResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
      participantsAddrs: globalThis.Array.isArray(object?.participantsAddrs)
        ? object.participantsAddrs.map((e: any) => globalThis.String(e))
        : [],
      poolPk: isSet(object.poolPk) ? globalThis.String(object.poolPk) : "",
    };
  },

  toJSON(message: MsgSubmitKeyGenResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    if (message.participantsAddrs?.length) {
      obj.participantsAddrs = message.participantsAddrs;
    }
    if (message.poolPk !== "") {
      obj.poolPk = message.poolPk;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitKeyGenResult>): MsgSubmitKeyGenResult {
    return MsgSubmitKeyGenResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitKeyGenResult>): MsgSubmitKeyGenResult {
    const message = createBaseMsgSubmitKeyGenResult();
    message.sender = object.sender ?? "";
    message.keygenId = object.keygenId ?? "";
    message.participantsAddrs = object.participantsAddrs?.map((e) => e) || [];
    message.poolPk = object.poolPk ?? "";
    return message;
  },
};

function createBaseMsgSubmitKeyGenResultResponse(): MsgSubmitKeyGenResultResponse {
  return {};
}

export const MsgSubmitKeyGenResultResponse: MessageFns<MsgSubmitKeyGenResultResponse> = {
  encode(_: MsgSubmitKeyGenResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitKeyGenResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitKeyGenResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitKeyGenResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitKeyGenResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitKeyGenResultResponse>): MsgSubmitKeyGenResultResponse {
    return MsgSubmitKeyGenResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSubmitKeyGenResultResponse>): MsgSubmitKeyGenResultResponse {
    const message = createBaseMsgSubmitKeyGenResultResponse();
    return message;
  },
};

function createBaseMsgUpdateContractSigners(): MsgUpdateContractSigners {
  return { sender: "", signers: [] };
}

export const MsgUpdateContractSigners: MessageFns<MsgUpdateContractSigners> = {
  encode(message: MsgUpdateContractSigners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.signers) {
      ContractSigners.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateContractSigners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateContractSigners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signers.push(ContractSigners.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateContractSigners {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => ContractSigners.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateContractSigners): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => ContractSigners.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateContractSigners>): MsgUpdateContractSigners {
    return MsgUpdateContractSigners.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateContractSigners>): MsgUpdateContractSigners {
    const message = createBaseMsgUpdateContractSigners();
    message.sender = object.sender ?? "";
    message.signers = object.signers?.map((e) => ContractSigners.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateContractSignersResponse(): MsgUpdateContractSignersResponse {
  return {};
}

export const MsgUpdateContractSignersResponse: MessageFns<MsgUpdateContractSignersResponse> = {
  encode(_: MsgUpdateContractSignersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateContractSignersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateContractSignersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateContractSignersResponse {
    return {};
  },

  toJSON(_: MsgUpdateContractSignersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateContractSignersResponse>): MsgUpdateContractSignersResponse {
    return MsgUpdateContractSignersResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateContractSignersResponse>): MsgUpdateContractSignersResponse {
    const message = createBaseMsgUpdateContractSignersResponse();
    return message;
  },
};

function createBaseMsgSubmitUpdateContractSignersResult(): MsgSubmitUpdateContractSignersResult {
  return { sender: "", updateId: "", signers: [] };
}

export const MsgSubmitUpdateContractSignersResult: MessageFns<MsgSubmitUpdateContractSignersResult> = {
  encode(message: MsgSubmitUpdateContractSignersResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.updateId !== "") {
      writer.uint32(18).string(message.updateId);
    }
    for (const v of message.signers) {
      ContractSigners.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpdateContractSignersResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpdateContractSignersResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signers.push(ContractSigners.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitUpdateContractSignersResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => ContractSigners.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgSubmitUpdateContractSignersResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => ContractSigners.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUpdateContractSignersResult>): MsgSubmitUpdateContractSignersResult {
    return MsgSubmitUpdateContractSignersResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitUpdateContractSignersResult>): MsgSubmitUpdateContractSignersResult {
    const message = createBaseMsgSubmitUpdateContractSignersResult();
    message.sender = object.sender ?? "";
    message.updateId = object.updateId ?? "";
    message.signers = object.signers?.map((e) => ContractSigners.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgSubmitUpdateContractSignersResultResponse(): MsgSubmitUpdateContractSignersResultResponse {
  return {};
}

export const MsgSubmitUpdateContractSignersResultResponse: MessageFns<MsgSubmitUpdateContractSignersResultResponse> = {
  encode(_: MsgSubmitUpdateContractSignersResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpdateContractSignersResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpdateContractSignersResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitUpdateContractSignersResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitUpdateContractSignersResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<MsgSubmitUpdateContractSignersResultResponse>,
  ): MsgSubmitUpdateContractSignersResultResponse {
    return MsgSubmitUpdateContractSignersResultResponse.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<MsgSubmitUpdateContractSignersResultResponse>,
  ): MsgSubmitUpdateContractSignersResultResponse {
    const message = createBaseMsgSubmitUpdateContractSignersResultResponse();
    return message;
  },
};

function createBaseMsgUpdateContractParams(): MsgUpdateContractParams {
  return { sender: "", chainId: "", contractAddress: "", minTransferAmount: "", fees: [], assetParams: [] };
}

export const MsgUpdateContractParams: MessageFns<MsgUpdateContractParams> = {
  encode(message: MsgUpdateContractParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(34).string(message.minTransferAmount);
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateContractParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateContractParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateContractParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateContractParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateContractParams>): MsgUpdateContractParams {
    return MsgUpdateContractParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateContractParams>): MsgUpdateContractParams {
    const message = createBaseMsgUpdateContractParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.minTransferAmount = object.minTransferAmount ?? "";
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateContractParamsResponse(): MsgUpdateContractParamsResponse {
  return {};
}

export const MsgUpdateContractParamsResponse: MessageFns<MsgUpdateContractParamsResponse> = {
  encode(_: MsgUpdateContractParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateContractParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateContractParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateContractParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateContractParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateContractParamsResponse>): MsgUpdateContractParamsResponse {
    return MsgUpdateContractParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateContractParamsResponse>): MsgUpdateContractParamsResponse {
    const message = createBaseMsgUpdateContractParamsResponse();
    return message;
  },
};

function createBaseMsgSubmitUpdateContractParamsResult(): MsgSubmitUpdateContractParamsResult {
  return {
    sender: "",
    updateId: "",
    chainId: "",
    contractAddress: "",
    minTransferAmount: "",
    fees: [],
    assetParams: [],
  };
}

export const MsgSubmitUpdateContractParamsResult: MessageFns<MsgSubmitUpdateContractParamsResult> = {
  encode(message: MsgSubmitUpdateContractParamsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.updateId !== "") {
      writer.uint32(18).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.contractAddress !== "") {
      writer.uint32(34).string(message.contractAddress);
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(42).string(message.minTransferAmount);
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpdateContractParamsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpdateContractParamsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitUpdateContractParamsResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgSubmitUpdateContractParamsResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUpdateContractParamsResult>): MsgSubmitUpdateContractParamsResult {
    return MsgSubmitUpdateContractParamsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitUpdateContractParamsResult>): MsgSubmitUpdateContractParamsResult {
    const message = createBaseMsgSubmitUpdateContractParamsResult();
    message.sender = object.sender ?? "";
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.minTransferAmount = object.minTransferAmount ?? "";
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgSubmitUpdateContractParamsResultResponse(): MsgSubmitUpdateContractParamsResultResponse {
  return {};
}

export const MsgSubmitUpdateContractParamsResultResponse: MessageFns<MsgSubmitUpdateContractParamsResultResponse> = {
  encode(_: MsgSubmitUpdateContractParamsResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpdateContractParamsResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpdateContractParamsResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitUpdateContractParamsResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitUpdateContractParamsResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUpdateContractParamsResultResponse>): MsgSubmitUpdateContractParamsResultResponse {
    return MsgSubmitUpdateContractParamsResultResponse.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<MsgSubmitUpdateContractParamsResultResponse>,
  ): MsgSubmitUpdateContractParamsResultResponse {
    const message = createBaseMsgSubmitUpdateContractParamsResultResponse();
    return message;
  },
};

function createBaseMsgUpdateContractStatus(): MsgUpdateContractStatus {
  return { sender: "", chainId: "", status: 0 };
}

export const MsgUpdateContractStatus: MessageFns<MsgUpdateContractStatus> = {
  encode(message: MsgUpdateContractStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateContractStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateContractStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateContractStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? contractStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MsgUpdateContractStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = contractStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateContractStatus>): MsgUpdateContractStatus {
    return MsgUpdateContractStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateContractStatus>): MsgUpdateContractStatus {
    const message = createBaseMsgUpdateContractStatus();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseMsgUpdateContractStatusResponse(): MsgUpdateContractStatusResponse {
  return {};
}

export const MsgUpdateContractStatusResponse: MessageFns<MsgUpdateContractStatusResponse> = {
  encode(_: MsgUpdateContractStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateContractStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateContractStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateContractStatusResponse {
    return {};
  },

  toJSON(_: MsgUpdateContractStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateContractStatusResponse>): MsgUpdateContractStatusResponse {
    return MsgUpdateContractStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateContractStatusResponse>): MsgUpdateContractStatusResponse {
    const message = createBaseMsgUpdateContractStatusResponse();
    return message;
  },
};

function createBaseMsgSubmitUpdateContractStatusResult(): MsgSubmitUpdateContractStatusResult {
  return { sender: "", updateId: "", chainId: "", status: 0 };
}

export const MsgSubmitUpdateContractStatusResult: MessageFns<MsgSubmitUpdateContractStatusResult> = {
  encode(message: MsgSubmitUpdateContractStatusResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.updateId !== "") {
      writer.uint32(18).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpdateContractStatusResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpdateContractStatusResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitUpdateContractStatusResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? contractStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MsgSubmitUpdateContractStatusResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = contractStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUpdateContractStatusResult>): MsgSubmitUpdateContractStatusResult {
    return MsgSubmitUpdateContractStatusResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitUpdateContractStatusResult>): MsgSubmitUpdateContractStatusResult {
    const message = createBaseMsgSubmitUpdateContractStatusResult();
    message.sender = object.sender ?? "";
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseMsgSubmitUpdateContractStatusResultResponse(): MsgSubmitUpdateContractStatusResultResponse {
  return {};
}

export const MsgSubmitUpdateContractStatusResultResponse: MessageFns<MsgSubmitUpdateContractStatusResultResponse> = {
  encode(_: MsgSubmitUpdateContractStatusResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpdateContractStatusResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpdateContractStatusResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitUpdateContractStatusResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitUpdateContractStatusResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUpdateContractStatusResultResponse>): MsgSubmitUpdateContractStatusResultResponse {
    return MsgSubmitUpdateContractStatusResultResponse.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<MsgSubmitUpdateContractStatusResultResponse>,
  ): MsgSubmitUpdateContractStatusResultResponse {
    const message = createBaseMsgSubmitUpdateContractStatusResultResponse();
    return message;
  },
};

function createBaseMsgPruneContract(): MsgPruneContract {
  return { sender: "", chainId: "", pruneBefore: Long.UZERO };
}

export const MsgPruneContract: MessageFns<MsgPruneContract> = {
  encode(message: MsgPruneContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pruneBefore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPruneContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPruneContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPruneContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
    };
  },

  toJSON(message: MsgPruneContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgPruneContract>): MsgPruneContract {
    return MsgPruneContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgPruneContract>): MsgPruneContract {
    const message = createBaseMsgPruneContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgPruneContractResponse(): MsgPruneContractResponse {
  return {};
}

export const MsgPruneContractResponse: MessageFns<MsgPruneContractResponse> = {
  encode(_: MsgPruneContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPruneContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPruneContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgPruneContractResponse {
    return {};
  },

  toJSON(_: MsgPruneContractResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgPruneContractResponse>): MsgPruneContractResponse {
    return MsgPruneContractResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgPruneContractResponse>): MsgPruneContractResponse {
    const message = createBaseMsgPruneContractResponse();
    return message;
  },
};

function createBaseMsgSubmitPruneContractResult(): MsgSubmitPruneContractResult {
  return { sender: "", pruneId: "", chainId: "", pruneBefore: Long.UZERO };
}

export const MsgSubmitPruneContractResult: MessageFns<MsgSubmitPruneContractResult> = {
  encode(message: MsgSubmitPruneContractResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.pruneId !== "") {
      writer.uint32(18).string(message.pruneId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.pruneBefore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitPruneContractResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitPruneContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pruneId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitPruneContractResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      pruneId: isSet(object.pruneId) ? globalThis.String(object.pruneId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
    };
  },

  toJSON(message: MsgSubmitPruneContractResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.pruneId !== "") {
      obj.pruneId = message.pruneId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitPruneContractResult>): MsgSubmitPruneContractResult {
    return MsgSubmitPruneContractResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitPruneContractResult>): MsgSubmitPruneContractResult {
    const message = createBaseMsgSubmitPruneContractResult();
    message.sender = object.sender ?? "";
    message.pruneId = object.pruneId ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgSubmitPruneContractResultResponse(): MsgSubmitPruneContractResultResponse {
  return {};
}

export const MsgSubmitPruneContractResultResponse: MessageFns<MsgSubmitPruneContractResultResponse> = {
  encode(_: MsgSubmitPruneContractResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitPruneContractResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitPruneContractResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitPruneContractResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitPruneContractResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitPruneContractResultResponse>): MsgSubmitPruneContractResultResponse {
    return MsgSubmitPruneContractResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSubmitPruneContractResultResponse>): MsgSubmitPruneContractResultResponse {
    const message = createBaseMsgSubmitPruneContractResultResponse();
    return message;
  },
};

function createBaseMsgUpgradeContract(): MsgUpgradeContract {
  return { sender: "", chainId: "", contractData: "", contractCode: "", upgradeData: undefined };
}

export const MsgUpgradeContract: MessageFns<MsgUpgradeContract> = {
  encode(message: MsgUpgradeContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.contractData !== "") {
      writer.uint32(26).string(message.contractData);
    }
    if (message.contractCode !== "") {
      writer.uint32(34).string(message.contractCode);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpgradeContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpgradeContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractData = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpgradeContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractData: isSet(object.contractData) ? globalThis.String(object.contractData) : "",
      contractCode: isSet(object.contractCode) ? globalThis.String(object.contractCode) : "",
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
    };
  },

  toJSON(message: MsgUpgradeContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractData !== "") {
      obj.contractData = message.contractData;
    }
    if (message.contractCode !== "") {
      obj.contractCode = message.contractCode;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpgradeContract>): MsgUpgradeContract {
    return MsgUpgradeContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpgradeContract>): MsgUpgradeContract {
    const message = createBaseMsgUpgradeContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.contractData = object.contractData ?? "";
    message.contractCode = object.contractCode ?? "";
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    return message;
  },
};

function createBaseMsgUpgradeContractResponse(): MsgUpgradeContractResponse {
  return {};
}

export const MsgUpgradeContractResponse: MessageFns<MsgUpgradeContractResponse> = {
  encode(_: MsgUpgradeContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpgradeContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpgradeContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpgradeContractResponse {
    return {};
  },

  toJSON(_: MsgUpgradeContractResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpgradeContractResponse>): MsgUpgradeContractResponse {
    return MsgUpgradeContractResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpgradeContractResponse>): MsgUpgradeContractResponse {
    const message = createBaseMsgUpgradeContractResponse();
    return message;
  },
};

function createBaseMsgSubmitUpgradeContractResult(): MsgSubmitUpgradeContractResult {
  return { sender: "", upgradeId: "", chainId: "", contractData: "", contractCode: "", upgradeData: undefined };
}

export const MsgSubmitUpgradeContractResult: MessageFns<MsgSubmitUpgradeContractResult> = {
  encode(message: MsgSubmitUpgradeContractResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.upgradeId !== "") {
      writer.uint32(18).string(message.upgradeId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.contractData !== "") {
      writer.uint32(34).string(message.contractData);
    }
    if (message.contractCode !== "") {
      writer.uint32(42).string(message.contractCode);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpgradeContractResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpgradeContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.upgradeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractData = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitUpgradeContractResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      upgradeId: isSet(object.upgradeId) ? globalThis.String(object.upgradeId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractData: isSet(object.contractData) ? globalThis.String(object.contractData) : "",
      contractCode: isSet(object.contractCode) ? globalThis.String(object.contractCode) : "",
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
    };
  },

  toJSON(message: MsgSubmitUpgradeContractResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.upgradeId !== "") {
      obj.upgradeId = message.upgradeId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractData !== "") {
      obj.contractData = message.contractData;
    }
    if (message.contractCode !== "") {
      obj.contractCode = message.contractCode;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUpgradeContractResult>): MsgSubmitUpgradeContractResult {
    return MsgSubmitUpgradeContractResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitUpgradeContractResult>): MsgSubmitUpgradeContractResult {
    const message = createBaseMsgSubmitUpgradeContractResult();
    message.sender = object.sender ?? "";
    message.upgradeId = object.upgradeId ?? "";
    message.chainId = object.chainId ?? "";
    message.contractData = object.contractData ?? "";
    message.contractCode = object.contractCode ?? "";
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    return message;
  },
};

function createBaseMsgSubmitUpgradeContractResultResponse(): MsgSubmitUpgradeContractResultResponse {
  return {};
}

export const MsgSubmitUpgradeContractResultResponse: MessageFns<MsgSubmitUpgradeContractResultResponse> = {
  encode(_: MsgSubmitUpgradeContractResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUpgradeContractResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUpgradeContractResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitUpgradeContractResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitUpgradeContractResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUpgradeContractResultResponse>): MsgSubmitUpgradeContractResultResponse {
    return MsgSubmitUpgradeContractResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSubmitUpgradeContractResultResponse>): MsgSubmitUpgradeContractResultResponse {
    const message = createBaseMsgSubmitUpgradeContractResultResponse();
    return message;
  },
};

function createBaseMsgAddContractAssets(): MsgAddContractAssets {
  return { sender: "", chainId: "", newAssets: [] };
}

export const MsgAddContractAssets: MessageFns<MsgAddContractAssets> = {
  encode(message: MsgAddContractAssets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.newAssets) {
      ContractAssetParams.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddContractAssets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddContractAssets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAssets.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddContractAssets {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      newAssets: globalThis.Array.isArray(object?.newAssets)
        ? object.newAssets.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgAddContractAssets): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.newAssets?.length) {
      obj.newAssets = message.newAssets.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAddContractAssets>): MsgAddContractAssets {
    return MsgAddContractAssets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAddContractAssets>): MsgAddContractAssets {
    const message = createBaseMsgAddContractAssets();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.newAssets = object.newAssets?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgAddContractAssetsResponse(): MsgAddContractAssetsResponse {
  return {};
}

export const MsgAddContractAssetsResponse: MessageFns<MsgAddContractAssetsResponse> = {
  encode(_: MsgAddContractAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddContractAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddContractAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddContractAssetsResponse {
    return {};
  },

  toJSON(_: MsgAddContractAssetsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAddContractAssetsResponse>): MsgAddContractAssetsResponse {
    return MsgAddContractAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAddContractAssetsResponse>): MsgAddContractAssetsResponse {
    const message = createBaseMsgAddContractAssetsResponse();
    return message;
  },
};

function createBaseMsgSubmitAddContractAssetsResult(): MsgSubmitAddContractAssetsResult {
  return { sender: "", id: "", chainId: "", newAssets: [] };
}

export const MsgSubmitAddContractAssetsResult: MessageFns<MsgSubmitAddContractAssetsResult> = {
  encode(message: MsgSubmitAddContractAssetsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    for (const v of message.newAssets) {
      ContractAssetParams.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitAddContractAssetsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitAddContractAssetsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newAssets.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitAddContractAssetsResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      newAssets: globalThis.Array.isArray(object?.newAssets)
        ? object.newAssets.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgSubmitAddContractAssetsResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.newAssets?.length) {
      obj.newAssets = message.newAssets.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitAddContractAssetsResult>): MsgSubmitAddContractAssetsResult {
    return MsgSubmitAddContractAssetsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitAddContractAssetsResult>): MsgSubmitAddContractAssetsResult {
    const message = createBaseMsgSubmitAddContractAssetsResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.newAssets = object.newAssets?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgSubmitAddContractAssetsResultResponse(): MsgSubmitAddContractAssetsResultResponse {
  return {};
}

export const MsgSubmitAddContractAssetsResultResponse: MessageFns<MsgSubmitAddContractAssetsResultResponse> = {
  encode(_: MsgSubmitAddContractAssetsResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitAddContractAssetsResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitAddContractAssetsResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitAddContractAssetsResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitAddContractAssetsResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitAddContractAssetsResultResponse>): MsgSubmitAddContractAssetsResultResponse {
    return MsgSubmitAddContractAssetsResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSubmitAddContractAssetsResultResponse>): MsgSubmitAddContractAssetsResultResponse {
    const message = createBaseMsgSubmitAddContractAssetsResultResponse();
    return message;
  },
};

function createBaseMsgDeleteContractAsset(): MsgDeleteContractAsset {
  return { sender: "", chainId: "", assetAddress: "" };
}

export const MsgDeleteContractAsset: MessageFns<MsgDeleteContractAsset> = {
  encode(message: MsgDeleteContractAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetAddress !== "") {
      writer.uint32(26).string(message.assetAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteContractAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteContractAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteContractAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetAddress: isSet(object.assetAddress) ? globalThis.String(object.assetAddress) : "",
    };
  },

  toJSON(message: MsgDeleteContractAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetAddress !== "") {
      obj.assetAddress = message.assetAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgDeleteContractAsset>): MsgDeleteContractAsset {
    return MsgDeleteContractAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgDeleteContractAsset>): MsgDeleteContractAsset {
    const message = createBaseMsgDeleteContractAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetAddress = object.assetAddress ?? "";
    return message;
  },
};

function createBaseMsgDeleteContractAssetResponse(): MsgDeleteContractAssetResponse {
  return {};
}

export const MsgDeleteContractAssetResponse: MessageFns<MsgDeleteContractAssetResponse> = {
  encode(_: MsgDeleteContractAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteContractAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteContractAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteContractAssetResponse {
    return {};
  },

  toJSON(_: MsgDeleteContractAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgDeleteContractAssetResponse>): MsgDeleteContractAssetResponse {
    return MsgDeleteContractAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgDeleteContractAssetResponse>): MsgDeleteContractAssetResponse {
    const message = createBaseMsgDeleteContractAssetResponse();
    return message;
  },
};

function createBaseMsgSubmitDeleteContractAssetResult(): MsgSubmitDeleteContractAssetResult {
  return { sender: "", id: "", chainId: "", assetAddress: "" };
}

export const MsgSubmitDeleteContractAssetResult: MessageFns<MsgSubmitDeleteContractAssetResult> = {
  encode(message: MsgSubmitDeleteContractAssetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.assetAddress !== "") {
      writer.uint32(34).string(message.assetAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitDeleteContractAssetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitDeleteContractAssetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assetAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitDeleteContractAssetResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetAddress: isSet(object.assetAddress) ? globalThis.String(object.assetAddress) : "",
    };
  },

  toJSON(message: MsgSubmitDeleteContractAssetResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetAddress !== "") {
      obj.assetAddress = message.assetAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitDeleteContractAssetResult>): MsgSubmitDeleteContractAssetResult {
    return MsgSubmitDeleteContractAssetResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitDeleteContractAssetResult>): MsgSubmitDeleteContractAssetResult {
    const message = createBaseMsgSubmitDeleteContractAssetResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.assetAddress = object.assetAddress ?? "";
    return message;
  },
};

function createBaseMsgSubmitDeleteContractAssetResultResponse(): MsgSubmitDeleteContractAssetResultResponse {
  return {};
}

export const MsgSubmitDeleteContractAssetResultResponse: MessageFns<MsgSubmitDeleteContractAssetResultResponse> = {
  encode(_: MsgSubmitDeleteContractAssetResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitDeleteContractAssetResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitDeleteContractAssetResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitDeleteContractAssetResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitDeleteContractAssetResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitDeleteContractAssetResultResponse>): MsgSubmitDeleteContractAssetResultResponse {
    return MsgSubmitDeleteContractAssetResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSubmitDeleteContractAssetResultResponse>): MsgSubmitDeleteContractAssetResultResponse {
    const message = createBaseMsgSubmitDeleteContractAssetResultResponse();
    return message;
  },
};

function createBaseMsgWhitelistContractAsset(): MsgWhitelistContractAsset {
  return { sender: "", chainId: "", asset: undefined };
}

export const MsgWhitelistContractAsset: MessageFns<MsgWhitelistContractAsset> = {
  encode(message: MsgWhitelistContractAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWhitelistContractAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWhitelistContractAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWhitelistContractAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: MsgWhitelistContractAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgWhitelistContractAsset>): MsgWhitelistContractAsset {
    return MsgWhitelistContractAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgWhitelistContractAsset>): MsgWhitelistContractAsset {
    const message = createBaseMsgWhitelistContractAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseMsgWhitelistContractAssetResponse(): MsgWhitelistContractAssetResponse {
  return {};
}

export const MsgWhitelistContractAssetResponse: MessageFns<MsgWhitelistContractAssetResponse> = {
  encode(_: MsgWhitelistContractAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWhitelistContractAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWhitelistContractAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgWhitelistContractAssetResponse {
    return {};
  },

  toJSON(_: MsgWhitelistContractAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgWhitelistContractAssetResponse>): MsgWhitelistContractAssetResponse {
    return MsgWhitelistContractAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgWhitelistContractAssetResponse>): MsgWhitelistContractAssetResponse {
    const message = createBaseMsgWhitelistContractAssetResponse();
    return message;
  },
};

function createBaseMsgSubmitWhitelistContractAssetResult(): MsgSubmitWhitelistContractAssetResult {
  return { sender: "", id: "", chainId: "", asset: undefined };
}

export const MsgSubmitWhitelistContractAssetResult: MessageFns<MsgSubmitWhitelistContractAssetResult> = {
  encode(message: MsgSubmitWhitelistContractAssetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitWhitelistContractAssetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitWhitelistContractAssetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitWhitelistContractAssetResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: MsgSubmitWhitelistContractAssetResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitWhitelistContractAssetResult>): MsgSubmitWhitelistContractAssetResult {
    return MsgSubmitWhitelistContractAssetResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitWhitelistContractAssetResult>): MsgSubmitWhitelistContractAssetResult {
    const message = createBaseMsgSubmitWhitelistContractAssetResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseMsgSubmitWhitelistContractAssetResultResponse(): MsgSubmitWhitelistContractAssetResultResponse {
  return {};
}

export const MsgSubmitWhitelistContractAssetResultResponse: MessageFns<MsgSubmitWhitelistContractAssetResultResponse> =
  {
    encode(_: MsgSubmitWhitelistContractAssetResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitWhitelistContractAssetResultResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgSubmitWhitelistContractAssetResultResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgSubmitWhitelistContractAssetResultResponse {
      return {};
    },

    toJSON(_: MsgSubmitWhitelistContractAssetResultResponse): unknown {
      const obj: any = {};
      return obj;
    },

    create(
      base?: DeepPartial<MsgSubmitWhitelistContractAssetResultResponse>,
    ): MsgSubmitWhitelistContractAssetResultResponse {
      return MsgSubmitWhitelistContractAssetResultResponse.fromPartial(base ?? {});
    },
    fromPartial(
      _: DeepPartial<MsgSubmitWhitelistContractAssetResultResponse>,
    ): MsgSubmitWhitelistContractAssetResultResponse {
      const message = createBaseMsgSubmitWhitelistContractAssetResultResponse();
      return message;
    },
  };

function createBaseMsgUnwhitelistContractAsset(): MsgUnwhitelistContractAsset {
  return { sender: "", chainId: "", asset: undefined };
}

export const MsgUnwhitelistContractAsset: MessageFns<MsgUnwhitelistContractAsset> = {
  encode(message: MsgUnwhitelistContractAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnwhitelistContractAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnwhitelistContractAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUnwhitelistContractAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: MsgUnwhitelistContractAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUnwhitelistContractAsset>): MsgUnwhitelistContractAsset {
    return MsgUnwhitelistContractAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUnwhitelistContractAsset>): MsgUnwhitelistContractAsset {
    const message = createBaseMsgUnwhitelistContractAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseMsgUnwhitelistContractAssetResponse(): MsgUnwhitelistContractAssetResponse {
  return {};
}

export const MsgUnwhitelistContractAssetResponse: MessageFns<MsgUnwhitelistContractAssetResponse> = {
  encode(_: MsgUnwhitelistContractAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnwhitelistContractAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnwhitelistContractAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUnwhitelistContractAssetResponse {
    return {};
  },

  toJSON(_: MsgUnwhitelistContractAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUnwhitelistContractAssetResponse>): MsgUnwhitelistContractAssetResponse {
    return MsgUnwhitelistContractAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUnwhitelistContractAssetResponse>): MsgUnwhitelistContractAssetResponse {
    const message = createBaseMsgUnwhitelistContractAssetResponse();
    return message;
  },
};

function createBaseMsgSubmitUnwhitelistContractAssetResult(): MsgSubmitUnwhitelistContractAssetResult {
  return { sender: "", id: "", chainId: "", asset: undefined };
}

export const MsgSubmitUnwhitelistContractAssetResult: MessageFns<MsgSubmitUnwhitelistContractAssetResult> = {
  encode(message: MsgSubmitUnwhitelistContractAssetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUnwhitelistContractAssetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUnwhitelistContractAssetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitUnwhitelistContractAssetResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: MsgSubmitUnwhitelistContractAssetResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitUnwhitelistContractAssetResult>): MsgSubmitUnwhitelistContractAssetResult {
    return MsgSubmitUnwhitelistContractAssetResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitUnwhitelistContractAssetResult>): MsgSubmitUnwhitelistContractAssetResult {
    const message = createBaseMsgSubmitUnwhitelistContractAssetResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseMsgSubmitUnwhitelistContractAssetResultResponse(): MsgSubmitUnwhitelistContractAssetResultResponse {
  return {};
}

export const MsgSubmitUnwhitelistContractAssetResultResponse: MessageFns<
  MsgSubmitUnwhitelistContractAssetResultResponse
> = {
  encode(_: MsgSubmitUnwhitelistContractAssetResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitUnwhitelistContractAssetResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitUnwhitelistContractAssetResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitUnwhitelistContractAssetResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitUnwhitelistContractAssetResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<MsgSubmitUnwhitelistContractAssetResultResponse>,
  ): MsgSubmitUnwhitelistContractAssetResultResponse {
    return MsgSubmitUnwhitelistContractAssetResultResponse.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<MsgSubmitUnwhitelistContractAssetResultResponse>,
  ): MsgSubmitUnwhitelistContractAssetResultResponse {
    const message = createBaseMsgSubmitUnwhitelistContractAssetResultResponse();
    return message;
  },
};

/** Msg defines the bridge module's gRPC message service. */
export interface Msg {
  /** InboundTransfer is used to process Bitfrost inbound transfers. */
  InboundTransfer(request: MsgInboundTransfer): Promise<MsgInboundTransferResponse>;
  /** InboundTransferRetry is used for retrying inbound transfers. */
  InboundTransferRetry(request: MsgInboundTransferRetry): Promise<MsgInboundTransferRetryResponse>;
  /** IbcInboundTransfer is used to process IBC inbound transfers */
  IbcInboundTransfer(request: MsgIbcInboundTransfer): Promise<MsgIbcInboundTransferResponse>;
  /** OutboundTransfer is used for outbound transfers (INT3 -> <other_chain>). */
  OutboundTransfer(request: MsgOutboundTransfer): Promise<MsgOutboundTransferResponse>;
  /** OutboundTransferRetry is used for retrying outbound transfers. */
  OutboundTransferRetry(request: MsgOutboundTransferRetry): Promise<MsgOutboundTransferRetryResponse>;
  /** OutboundTransferResult is used for submitting outbound transfer results */
  OutboundTransferResult(request: MsgOutboundTransferResult): Promise<MsgOutboundTransferResultResponse>;
  /**
   * ForceInboundTransfer is used to recover failed inbound transfers
   * (<other_chain> -> INT3). Only accessible by the gov module.
   */
  ForceInboundTransfer(request: MsgForceInboundTransfer): Promise<MsgForceInboundTransferResponse>;
  UpdateBridgeStatus(request: MsgUpdateBridgeStatus): Promise<MsgUpdateBridgeStatusResponse>;
  /** CreateAsset is used for declaring new assets. */
  CreateAsset(request: MsgCreateAsset): Promise<MsgCreateAssetResponse>;
  /** MintAsset is used for minting an asset. */
  MintAsset(request: MsgMintAsset): Promise<MsgMintAssetResponse>;
  /** BurnAsset is used for burning an asset. */
  BurnAsset(request: MsgBurnAsset): Promise<MsgBurnAssetResponse>;
  /** RemoveAsset is used to remove existing asset. */
  RemoveAsset(request: MsgRemoveAsset): Promise<MsgRemoveAssetResponse>;
  /** UpdateAssetStatus is used to update asset status. */
  UpdateAssetStatus(request: MsgUpdateAssetStatus): Promise<MsgUpdateAssetStatusResponse>;
  /**
   * UpdateAssetMinTransferAmount is used to update minimal transfer amount for
   * an asset. Should be observed by observers.
   */
  UpdateAssetMinTransferAmount(
    request: MsgUpdateAssetMinTransferAmount,
  ): Promise<MsgUpdateAssetMinTransferAmountResponse>;
  /** TssKeyGen triggers the key generation for the TSS committee. */
  TssKeyGen(request: MsgTssKeyGen): Promise<MsgTssKeyGenResponse>;
  /** SubmitTssKeyGenResult is used for submitting keygen results from observers */
  SubmitTssKeyGenResult(request: MsgTssKeyGenResult): Promise<MsgTssKeyGenResultResponse>;
  /**
   * TssVaultMigration triggers the vault migration for the specific chains.
   * Should be observed by observers.
   */
  TssVaultMigration(request: MsgTssVaultMigration): Promise<MsgTssVaultMigrationResponse>;
  /**
   * TssVaultUpdate triggers the vault address update for specific chains.
   * Should be observed by observers.
   */
  TssVaultUpdate(request: MsgTssVaultUpdate): Promise<MsgTssVaultUpdateResponse>;
  /**
   * SetChainParams is used to update all chain parameters. Should only be used
   * in correctional purposes.
   */
  SetChainParams(request: MsgSetChainParams): Promise<MsgSetChainParamsResponse>;
  /** AddChain is used to add new chain into the bridge. */
  AddChain(request: MsgAddChain): Promise<MsgAddChainResponse>;
  /**
   * RemoveChain is used to remove chain from the bridge. Removal should be only
   * allowed only if all assets originated from this chain has no liquidity and
   * are removed from the x/bridge.
   */
  RemoveChain(request: MsgRemoveChain): Promise<MsgRemoveChainResponse>;
  /**
   * UpdateChainStatus is used to update status of a chain. Should be observed
   * by observers.
   */
  UpdateChainStatus(request: MsgUpdateChainStatus): Promise<MsgUpdateChainStatusResponse>;
  /** UpdateChainRetryParams is used to update retry parameters of a chain. */
  UpdateChainRetryParams(request: MsgUpdateChainRetryParams): Promise<MsgUpdateChainRetryParamsResponse>;
  /**
   * UpdateChainAssetStatus is used to update asset status of a chain. Should be
   * observed by observers.
   */
  UpdateChainAssetStatus(request: MsgUpdateChainAssetStatus): Promise<MsgUpdateChainAssetStatusResponse>;
  /**
   * AddChainAsset is used to add new assets to a chain. Should be observed by
   * observers.
   */
  AddChainAsset(request: MsgAddChainAsset): Promise<MsgAddChainAssetResponse>;
  /**
   * RemoveChainAsset is used to remove an asset from a chain. Should be
   * observed by observers.
   */
  RemoveChainAsset(request: MsgRemoveChainAsset): Promise<MsgRemoveChainAssetResponse>;
  /**
   * SetChainSigners is used to update signers of the chain. Should be observed
   * by observers.
   */
  SetChainSigners(request: MsgSetChainSigners): Promise<MsgSetChainSignersResponse>;
  /**
   * SetChainGasParams is used to update gas parameters for a chain. Should be
   * observed by observers.
   */
  SetChainGasParams(request: MsgSetChainGasParams): Promise<MsgSetChainGasParamsResponse>;
  /**
   * SetChainConfirmationsRequired is used to update the number of confirmations
   * required for a chain.
   */
  SetChainConfirmationsRequired(
    request: MsgSetChainConfirmationsRequired,
  ): Promise<MsgSetChainConfirmationsRequiredResponse>;
  /**
   * SubmitProposalResult is used to submit the result of observer processing by
   * observers.
   */
  SubmitProposalResult(request: MsgSubmitProposalResult): Promise<MsgSubmitProposalResultResponse>;
  /**
   * SetUtxoChainRelayerParams is used to update relayer parameters for a UTXO
   * chain.
   */
  SetUtxoChainRelayerParams(request: MsgSetUtxoChainRelayerParams): Promise<MsgSetUtxoChainRelayerParamsResponse>;
  /**
   * PruneSmartContractChainContract is used to initiate contract prune for a
   * smart contract chain. Should be observed by observers.
   */
  PruneSmartContractChainContract(
    request: MsgPruneSmartContractChainContract,
  ): Promise<MsgPruneSmartContractChainContractResponse>;
  /**
   * UpgradeSmartContractChainContract is used to initiate contract upgrade for
   * a smart contract chain. Should be observed by observers.
   */
  UpgradeSmartContractChainContract(
    request: MsgUpgradeSmartContractChainContract,
  ): Promise<MsgUpgradeSmartContractChainContractResponse>;
  /**
   * SetSmartContractChainAssetsDestChainIds is used to update destination chain
   * ids for an asset of smart contract chain. Should be observed by observers.
   */
  SetSmartContractChainAssetsDestChainIds(
    request: MsgSetSmartContractChainAssetsDestChainIds,
  ): Promise<MsgSetSmartContractChainAssetsDestChainIdsResponse>;
  /** UpdateIbcChainParams is used to update IBC chain parameters. */
  UpdateIbcChainParams(request: MsgUpdateIbcChainParams): Promise<MsgUpdateIbcChainParamsResponse>;
  /** UpdateIbcChainAssetParams is used to update IBC chain asset parameters. */
  UpdateIbcChainAssetParams(request: MsgUpdateIbcChainAssetParams): Promise<MsgUpdateIbcChainAssetParamsResponse>;
  /** UpdateNttChainWormholeProgram is used to update Wormhole program id */
  UpdateNttChainParams(request: MsgUpdateNttChainParams): Promise<MsgUpdateNttChainParamsResponse>;
  /** UpdateNttChainAssetAddresses is used to update NTT asset addresses */
  UpdateNttChainAssetAddresses(
    request: MsgUpdateNttChainAssetAddresses,
  ): Promise<MsgUpdateNttChainAssetAddressesResponse>;
  /**
   * UpdateIbcForwardingParams is used for updating parameters of the IBC
   * forwarding.
   *
   * @deprecated
   */
  UpdateIbcForwardingParams(request: MsgUpdateIbcForwardingParams): Promise<MsgUpdateIbcForwardingParamsResponse>;
  /**
   * ChangeAssetStatus will change the provided asset's status.
   *
   * @deprecated
   */
  ChangeAssetStatus(request: MsgChangeAssetStatus): Promise<MsgChangeAssetStatusResponse>;
  /**
   * UpdateContractSigners triggers contract signers update
   *
   * @deprecated
   */
  UpdateContractSigners(request: MsgUpdateContractSigners): Promise<MsgUpdateContractSignersResponse>;
  /**
   * SubmitUpdateContractSignersResult is used for submitting contract signers
   * update results from observer
   *
   * @deprecated
   */
  SubmitUpdateContractSignersResult(
    request: MsgSubmitUpdateContractSignersResult,
  ): Promise<MsgSubmitUpdateContractSignersResultResponse>;
  /**
   * UpdateContractParams triggers contract params update
   *
   * @deprecated
   */
  UpdateContractParams(request: MsgUpdateContractParams): Promise<MsgUpdateContractParamsResponse>;
  /**
   * SubmitUpdateContractParamsResult is used for submitting contract params
   * update result from observer
   *
   * @deprecated
   */
  SubmitUpdateContractParamsResult(
    request: MsgSubmitUpdateContractParamsResult,
  ): Promise<MsgSubmitUpdateContractParamsResultResponse>;
  /**
   * UpdateContractStatus triggers contract status update
   *
   * @deprecated
   */
  UpdateContractStatus(request: MsgUpdateContractStatus): Promise<MsgUpdateContractStatusResponse>;
  /**
   * SubmitUpdateContractStatusResult is used for submitting contract status
   * update result from observer
   *
   * @deprecated
   */
  SubmitUpdateContractStatusResult(
    request: MsgSubmitUpdateContractStatusResult,
  ): Promise<MsgSubmitUpdateContractStatusResultResponse>;
  /**
   * PruneContract triggers contract pruning
   *
   * @deprecated
   */
  PruneContract(request: MsgPruneContract): Promise<MsgPruneContractResponse>;
  /**
   * SubmitPruneContractResult is used for submitting contract pruning result
   * from observer
   *
   * @deprecated
   */
  SubmitPruneContractResult(request: MsgSubmitPruneContractResult): Promise<MsgSubmitPruneContractResultResponse>;
  /**
   * UpgradeContract triggers contract upgrade
   *
   * @deprecated
   */
  UpgradeContract(request: MsgUpgradeContract): Promise<MsgUpgradeContractResponse>;
  /**
   * SubmitUpgradeContractResult is used for submitting contract upgrade result
   * from observer
   *
   * @deprecated
   */
  SubmitUpgradeContractResult(request: MsgSubmitUpgradeContractResult): Promise<MsgSubmitUpgradeContractResultResponse>;
  /**
   * AddContractAssets triggers adding new assets to a bridge contract
   *
   * @deprecated
   */
  AddContractAssets(request: MsgAddContractAssets): Promise<MsgAddContractAssetsResponse>;
  /**
   * SubmitAddContractAssetsResult is used for submitting add contract asset
   * result from observer
   *
   * @deprecated
   */
  SubmitAddContractAssetsResult(
    request: MsgSubmitAddContractAssetsResult,
  ): Promise<MsgSubmitAddContractAssetsResultResponse>;
  /**
   * DeleteContractAsset triggers deleting an asset from a bridge contract
   *
   * @deprecated
   */
  DeleteContractAsset(request: MsgDeleteContractAsset): Promise<MsgDeleteContractAssetResponse>;
  /**
   * SubmitDeleteContractAssetResult is used for submitting delete contract
   * asset result from observer
   *
   * @deprecated
   */
  SubmitDeleteContractAssetResult(
    request: MsgSubmitDeleteContractAssetResult,
  ): Promise<MsgSubmitDeleteContractAssetResultResponse>;
  /**
   * WhitelistContractAsset triggers whitelisting assets in a bridge contract
   *
   * @deprecated
   */
  WhitelistContractAsset(request: MsgWhitelistContractAsset): Promise<MsgWhitelistContractAssetResponse>;
  /**
   * SubmitWhitelistContractAssetResult is used for submitting whitelist result
   * from observer
   *
   * @deprecated
   */
  SubmitWhitelistContractAssetResult(
    request: MsgSubmitWhitelistContractAssetResult,
  ): Promise<MsgSubmitWhitelistContractAssetResultResponse>;
  /**
   * UnwhitelistContractAssets triggers unwhitelisting assets in a bridge
   * contract
   *
   * @deprecated
   */
  UnwhitelistContractAsset(request: MsgUnwhitelistContractAsset): Promise<MsgUnwhitelistContractAssetResponse>;
  /**
   * SubmitUnwhitelistContractAssetsResult is used for submitting unwhitelist
   * result from observer
   *
   * @deprecated
   */
  SubmitUnwhitelistContractAssetResult(
    request: MsgSubmitUnwhitelistContractAssetResult,
  ): Promise<MsgSubmitUnwhitelistContractAssetResultResponse>;
  /**
   * ResolveQuarantinedTransfers is used to initiate voting on a quarantined
   * entity to either process or reject it.
   */
  ResolveQuarantinedTransfers(request: MsgResolveQuarantinedTransfers): Promise<MsgResolveQuarantinedTransfersResponse>;
}

export const MsgServiceName = "int3face.bridge.v1beta1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.InboundTransfer = this.InboundTransfer.bind(this);
    this.InboundTransferRetry = this.InboundTransferRetry.bind(this);
    this.IbcInboundTransfer = this.IbcInboundTransfer.bind(this);
    this.OutboundTransfer = this.OutboundTransfer.bind(this);
    this.OutboundTransferRetry = this.OutboundTransferRetry.bind(this);
    this.OutboundTransferResult = this.OutboundTransferResult.bind(this);
    this.ForceInboundTransfer = this.ForceInboundTransfer.bind(this);
    this.UpdateBridgeStatus = this.UpdateBridgeStatus.bind(this);
    this.CreateAsset = this.CreateAsset.bind(this);
    this.MintAsset = this.MintAsset.bind(this);
    this.BurnAsset = this.BurnAsset.bind(this);
    this.RemoveAsset = this.RemoveAsset.bind(this);
    this.UpdateAssetStatus = this.UpdateAssetStatus.bind(this);
    this.UpdateAssetMinTransferAmount = this.UpdateAssetMinTransferAmount.bind(this);
    this.TssKeyGen = this.TssKeyGen.bind(this);
    this.SubmitTssKeyGenResult = this.SubmitTssKeyGenResult.bind(this);
    this.TssVaultMigration = this.TssVaultMigration.bind(this);
    this.TssVaultUpdate = this.TssVaultUpdate.bind(this);
    this.SetChainParams = this.SetChainParams.bind(this);
    this.AddChain = this.AddChain.bind(this);
    this.RemoveChain = this.RemoveChain.bind(this);
    this.UpdateChainStatus = this.UpdateChainStatus.bind(this);
    this.UpdateChainRetryParams = this.UpdateChainRetryParams.bind(this);
    this.UpdateChainAssetStatus = this.UpdateChainAssetStatus.bind(this);
    this.AddChainAsset = this.AddChainAsset.bind(this);
    this.RemoveChainAsset = this.RemoveChainAsset.bind(this);
    this.SetChainSigners = this.SetChainSigners.bind(this);
    this.SetChainGasParams = this.SetChainGasParams.bind(this);
    this.SetChainConfirmationsRequired = this.SetChainConfirmationsRequired.bind(this);
    this.SubmitProposalResult = this.SubmitProposalResult.bind(this);
    this.SetUtxoChainRelayerParams = this.SetUtxoChainRelayerParams.bind(this);
    this.PruneSmartContractChainContract = this.PruneSmartContractChainContract.bind(this);
    this.UpgradeSmartContractChainContract = this.UpgradeSmartContractChainContract.bind(this);
    this.SetSmartContractChainAssetsDestChainIds = this.SetSmartContractChainAssetsDestChainIds.bind(this);
    this.UpdateIbcChainParams = this.UpdateIbcChainParams.bind(this);
    this.UpdateIbcChainAssetParams = this.UpdateIbcChainAssetParams.bind(this);
    this.UpdateNttChainParams = this.UpdateNttChainParams.bind(this);
    this.UpdateNttChainAssetAddresses = this.UpdateNttChainAssetAddresses.bind(this);
    this.UpdateIbcForwardingParams = this.UpdateIbcForwardingParams.bind(this);
    this.ChangeAssetStatus = this.ChangeAssetStatus.bind(this);
    this.UpdateContractSigners = this.UpdateContractSigners.bind(this);
    this.SubmitUpdateContractSignersResult = this.SubmitUpdateContractSignersResult.bind(this);
    this.UpdateContractParams = this.UpdateContractParams.bind(this);
    this.SubmitUpdateContractParamsResult = this.SubmitUpdateContractParamsResult.bind(this);
    this.UpdateContractStatus = this.UpdateContractStatus.bind(this);
    this.SubmitUpdateContractStatusResult = this.SubmitUpdateContractStatusResult.bind(this);
    this.PruneContract = this.PruneContract.bind(this);
    this.SubmitPruneContractResult = this.SubmitPruneContractResult.bind(this);
    this.UpgradeContract = this.UpgradeContract.bind(this);
    this.SubmitUpgradeContractResult = this.SubmitUpgradeContractResult.bind(this);
    this.AddContractAssets = this.AddContractAssets.bind(this);
    this.SubmitAddContractAssetsResult = this.SubmitAddContractAssetsResult.bind(this);
    this.DeleteContractAsset = this.DeleteContractAsset.bind(this);
    this.SubmitDeleteContractAssetResult = this.SubmitDeleteContractAssetResult.bind(this);
    this.WhitelistContractAsset = this.WhitelistContractAsset.bind(this);
    this.SubmitWhitelistContractAssetResult = this.SubmitWhitelistContractAssetResult.bind(this);
    this.UnwhitelistContractAsset = this.UnwhitelistContractAsset.bind(this);
    this.SubmitUnwhitelistContractAssetResult = this.SubmitUnwhitelistContractAssetResult.bind(this);
    this.ResolveQuarantinedTransfers = this.ResolveQuarantinedTransfers.bind(this);
  }
  InboundTransfer(request: MsgInboundTransfer): Promise<MsgInboundTransferResponse> {
    const data = MsgInboundTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "InboundTransfer", data);
    return promise.then((data) => MsgInboundTransferResponse.decode(new BinaryReader(data)));
  }

  InboundTransferRetry(request: MsgInboundTransferRetry): Promise<MsgInboundTransferRetryResponse> {
    const data = MsgInboundTransferRetry.encode(request).finish();
    const promise = this.rpc.request(this.service, "InboundTransferRetry", data);
    return promise.then((data) => MsgInboundTransferRetryResponse.decode(new BinaryReader(data)));
  }

  IbcInboundTransfer(request: MsgIbcInboundTransfer): Promise<MsgIbcInboundTransferResponse> {
    const data = MsgIbcInboundTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "IbcInboundTransfer", data);
    return promise.then((data) => MsgIbcInboundTransferResponse.decode(new BinaryReader(data)));
  }

  OutboundTransfer(request: MsgOutboundTransfer): Promise<MsgOutboundTransferResponse> {
    const data = MsgOutboundTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "OutboundTransfer", data);
    return promise.then((data) => MsgOutboundTransferResponse.decode(new BinaryReader(data)));
  }

  OutboundTransferRetry(request: MsgOutboundTransferRetry): Promise<MsgOutboundTransferRetryResponse> {
    const data = MsgOutboundTransferRetry.encode(request).finish();
    const promise = this.rpc.request(this.service, "OutboundTransferRetry", data);
    return promise.then((data) => MsgOutboundTransferRetryResponse.decode(new BinaryReader(data)));
  }

  OutboundTransferResult(request: MsgOutboundTransferResult): Promise<MsgOutboundTransferResultResponse> {
    const data = MsgOutboundTransferResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "OutboundTransferResult", data);
    return promise.then((data) => MsgOutboundTransferResultResponse.decode(new BinaryReader(data)));
  }

  ForceInboundTransfer(request: MsgForceInboundTransfer): Promise<MsgForceInboundTransferResponse> {
    const data = MsgForceInboundTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "ForceInboundTransfer", data);
    return promise.then((data) => MsgForceInboundTransferResponse.decode(new BinaryReader(data)));
  }

  UpdateBridgeStatus(request: MsgUpdateBridgeStatus): Promise<MsgUpdateBridgeStatusResponse> {
    const data = MsgUpdateBridgeStatus.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateBridgeStatus", data);
    return promise.then((data) => MsgUpdateBridgeStatusResponse.decode(new BinaryReader(data)));
  }

  CreateAsset(request: MsgCreateAsset): Promise<MsgCreateAssetResponse> {
    const data = MsgCreateAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAsset", data);
    return promise.then((data) => MsgCreateAssetResponse.decode(new BinaryReader(data)));
  }

  MintAsset(request: MsgMintAsset): Promise<MsgMintAssetResponse> {
    const data = MsgMintAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "MintAsset", data);
    return promise.then((data) => MsgMintAssetResponse.decode(new BinaryReader(data)));
  }

  BurnAsset(request: MsgBurnAsset): Promise<MsgBurnAssetResponse> {
    const data = MsgBurnAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "BurnAsset", data);
    return promise.then((data) => MsgBurnAssetResponse.decode(new BinaryReader(data)));
  }

  RemoveAsset(request: MsgRemoveAsset): Promise<MsgRemoveAssetResponse> {
    const data = MsgRemoveAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveAsset", data);
    return promise.then((data) => MsgRemoveAssetResponse.decode(new BinaryReader(data)));
  }

  UpdateAssetStatus(request: MsgUpdateAssetStatus): Promise<MsgUpdateAssetStatusResponse> {
    const data = MsgUpdateAssetStatus.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateAssetStatus", data);
    return promise.then((data) => MsgUpdateAssetStatusResponse.decode(new BinaryReader(data)));
  }

  UpdateAssetMinTransferAmount(
    request: MsgUpdateAssetMinTransferAmount,
  ): Promise<MsgUpdateAssetMinTransferAmountResponse> {
    const data = MsgUpdateAssetMinTransferAmount.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateAssetMinTransferAmount", data);
    return promise.then((data) => MsgUpdateAssetMinTransferAmountResponse.decode(new BinaryReader(data)));
  }

  TssKeyGen(request: MsgTssKeyGen): Promise<MsgTssKeyGenResponse> {
    const data = MsgTssKeyGen.encode(request).finish();
    const promise = this.rpc.request(this.service, "TssKeyGen", data);
    return promise.then((data) => MsgTssKeyGenResponse.decode(new BinaryReader(data)));
  }

  SubmitTssKeyGenResult(request: MsgTssKeyGenResult): Promise<MsgTssKeyGenResultResponse> {
    const data = MsgTssKeyGenResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitTssKeyGenResult", data);
    return promise.then((data) => MsgTssKeyGenResultResponse.decode(new BinaryReader(data)));
  }

  TssVaultMigration(request: MsgTssVaultMigration): Promise<MsgTssVaultMigrationResponse> {
    const data = MsgTssVaultMigration.encode(request).finish();
    const promise = this.rpc.request(this.service, "TssVaultMigration", data);
    return promise.then((data) => MsgTssVaultMigrationResponse.decode(new BinaryReader(data)));
  }

  TssVaultUpdate(request: MsgTssVaultUpdate): Promise<MsgTssVaultUpdateResponse> {
    const data = MsgTssVaultUpdate.encode(request).finish();
    const promise = this.rpc.request(this.service, "TssVaultUpdate", data);
    return promise.then((data) => MsgTssVaultUpdateResponse.decode(new BinaryReader(data)));
  }

  SetChainParams(request: MsgSetChainParams): Promise<MsgSetChainParamsResponse> {
    const data = MsgSetChainParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetChainParams", data);
    return promise.then((data) => MsgSetChainParamsResponse.decode(new BinaryReader(data)));
  }

  AddChain(request: MsgAddChain): Promise<MsgAddChainResponse> {
    const data = MsgAddChain.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddChain", data);
    return promise.then((data) => MsgAddChainResponse.decode(new BinaryReader(data)));
  }

  RemoveChain(request: MsgRemoveChain): Promise<MsgRemoveChainResponse> {
    const data = MsgRemoveChain.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveChain", data);
    return promise.then((data) => MsgRemoveChainResponse.decode(new BinaryReader(data)));
  }

  UpdateChainStatus(request: MsgUpdateChainStatus): Promise<MsgUpdateChainStatusResponse> {
    const data = MsgUpdateChainStatus.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateChainStatus", data);
    return promise.then((data) => MsgUpdateChainStatusResponse.decode(new BinaryReader(data)));
  }

  UpdateChainRetryParams(request: MsgUpdateChainRetryParams): Promise<MsgUpdateChainRetryParamsResponse> {
    const data = MsgUpdateChainRetryParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateChainRetryParams", data);
    return promise.then((data) => MsgUpdateChainRetryParamsResponse.decode(new BinaryReader(data)));
  }

  UpdateChainAssetStatus(request: MsgUpdateChainAssetStatus): Promise<MsgUpdateChainAssetStatusResponse> {
    const data = MsgUpdateChainAssetStatus.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateChainAssetStatus", data);
    return promise.then((data) => MsgUpdateChainAssetStatusResponse.decode(new BinaryReader(data)));
  }

  AddChainAsset(request: MsgAddChainAsset): Promise<MsgAddChainAssetResponse> {
    const data = MsgAddChainAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddChainAsset", data);
    return promise.then((data) => MsgAddChainAssetResponse.decode(new BinaryReader(data)));
  }

  RemoveChainAsset(request: MsgRemoveChainAsset): Promise<MsgRemoveChainAssetResponse> {
    const data = MsgRemoveChainAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveChainAsset", data);
    return promise.then((data) => MsgRemoveChainAssetResponse.decode(new BinaryReader(data)));
  }

  SetChainSigners(request: MsgSetChainSigners): Promise<MsgSetChainSignersResponse> {
    const data = MsgSetChainSigners.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetChainSigners", data);
    return promise.then((data) => MsgSetChainSignersResponse.decode(new BinaryReader(data)));
  }

  SetChainGasParams(request: MsgSetChainGasParams): Promise<MsgSetChainGasParamsResponse> {
    const data = MsgSetChainGasParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetChainGasParams", data);
    return promise.then((data) => MsgSetChainGasParamsResponse.decode(new BinaryReader(data)));
  }

  SetChainConfirmationsRequired(
    request: MsgSetChainConfirmationsRequired,
  ): Promise<MsgSetChainConfirmationsRequiredResponse> {
    const data = MsgSetChainConfirmationsRequired.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetChainConfirmationsRequired", data);
    return promise.then((data) => MsgSetChainConfirmationsRequiredResponse.decode(new BinaryReader(data)));
  }

  SubmitProposalResult(request: MsgSubmitProposalResult): Promise<MsgSubmitProposalResultResponse> {
    const data = MsgSubmitProposalResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitProposalResult", data);
    return promise.then((data) => MsgSubmitProposalResultResponse.decode(new BinaryReader(data)));
  }

  SetUtxoChainRelayerParams(request: MsgSetUtxoChainRelayerParams): Promise<MsgSetUtxoChainRelayerParamsResponse> {
    const data = MsgSetUtxoChainRelayerParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetUtxoChainRelayerParams", data);
    return promise.then((data) => MsgSetUtxoChainRelayerParamsResponse.decode(new BinaryReader(data)));
  }

  PruneSmartContractChainContract(
    request: MsgPruneSmartContractChainContract,
  ): Promise<MsgPruneSmartContractChainContractResponse> {
    const data = MsgPruneSmartContractChainContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "PruneSmartContractChainContract", data);
    return promise.then((data) => MsgPruneSmartContractChainContractResponse.decode(new BinaryReader(data)));
  }

  UpgradeSmartContractChainContract(
    request: MsgUpgradeSmartContractChainContract,
  ): Promise<MsgUpgradeSmartContractChainContractResponse> {
    const data = MsgUpgradeSmartContractChainContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpgradeSmartContractChainContract", data);
    return promise.then((data) => MsgUpgradeSmartContractChainContractResponse.decode(new BinaryReader(data)));
  }

  SetSmartContractChainAssetsDestChainIds(
    request: MsgSetSmartContractChainAssetsDestChainIds,
  ): Promise<MsgSetSmartContractChainAssetsDestChainIdsResponse> {
    const data = MsgSetSmartContractChainAssetsDestChainIds.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetSmartContractChainAssetsDestChainIds", data);
    return promise.then((data) => MsgSetSmartContractChainAssetsDestChainIdsResponse.decode(new BinaryReader(data)));
  }

  UpdateIbcChainParams(request: MsgUpdateIbcChainParams): Promise<MsgUpdateIbcChainParamsResponse> {
    const data = MsgUpdateIbcChainParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateIbcChainParams", data);
    return promise.then((data) => MsgUpdateIbcChainParamsResponse.decode(new BinaryReader(data)));
  }

  UpdateIbcChainAssetParams(request: MsgUpdateIbcChainAssetParams): Promise<MsgUpdateIbcChainAssetParamsResponse> {
    const data = MsgUpdateIbcChainAssetParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateIbcChainAssetParams", data);
    return promise.then((data) => MsgUpdateIbcChainAssetParamsResponse.decode(new BinaryReader(data)));
  }

  UpdateNttChainParams(request: MsgUpdateNttChainParams): Promise<MsgUpdateNttChainParamsResponse> {
    const data = MsgUpdateNttChainParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateNttChainParams", data);
    return promise.then((data) => MsgUpdateNttChainParamsResponse.decode(new BinaryReader(data)));
  }

  UpdateNttChainAssetAddresses(
    request: MsgUpdateNttChainAssetAddresses,
  ): Promise<MsgUpdateNttChainAssetAddressesResponse> {
    const data = MsgUpdateNttChainAssetAddresses.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateNttChainAssetAddresses", data);
    return promise.then((data) => MsgUpdateNttChainAssetAddressesResponse.decode(new BinaryReader(data)));
  }

  UpdateIbcForwardingParams(request: MsgUpdateIbcForwardingParams): Promise<MsgUpdateIbcForwardingParamsResponse> {
    const data = MsgUpdateIbcForwardingParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateIbcForwardingParams", data);
    return promise.then((data) => MsgUpdateIbcForwardingParamsResponse.decode(new BinaryReader(data)));
  }

  ChangeAssetStatus(request: MsgChangeAssetStatus): Promise<MsgChangeAssetStatusResponse> {
    const data = MsgChangeAssetStatus.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeAssetStatus", data);
    return promise.then((data) => MsgChangeAssetStatusResponse.decode(new BinaryReader(data)));
  }

  UpdateContractSigners(request: MsgUpdateContractSigners): Promise<MsgUpdateContractSignersResponse> {
    const data = MsgUpdateContractSigners.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateContractSigners", data);
    return promise.then((data) => MsgUpdateContractSignersResponse.decode(new BinaryReader(data)));
  }

  SubmitUpdateContractSignersResult(
    request: MsgSubmitUpdateContractSignersResult,
  ): Promise<MsgSubmitUpdateContractSignersResultResponse> {
    const data = MsgSubmitUpdateContractSignersResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitUpdateContractSignersResult", data);
    return promise.then((data) => MsgSubmitUpdateContractSignersResultResponse.decode(new BinaryReader(data)));
  }

  UpdateContractParams(request: MsgUpdateContractParams): Promise<MsgUpdateContractParamsResponse> {
    const data = MsgUpdateContractParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateContractParams", data);
    return promise.then((data) => MsgUpdateContractParamsResponse.decode(new BinaryReader(data)));
  }

  SubmitUpdateContractParamsResult(
    request: MsgSubmitUpdateContractParamsResult,
  ): Promise<MsgSubmitUpdateContractParamsResultResponse> {
    const data = MsgSubmitUpdateContractParamsResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitUpdateContractParamsResult", data);
    return promise.then((data) => MsgSubmitUpdateContractParamsResultResponse.decode(new BinaryReader(data)));
  }

  UpdateContractStatus(request: MsgUpdateContractStatus): Promise<MsgUpdateContractStatusResponse> {
    const data = MsgUpdateContractStatus.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateContractStatus", data);
    return promise.then((data) => MsgUpdateContractStatusResponse.decode(new BinaryReader(data)));
  }

  SubmitUpdateContractStatusResult(
    request: MsgSubmitUpdateContractStatusResult,
  ): Promise<MsgSubmitUpdateContractStatusResultResponse> {
    const data = MsgSubmitUpdateContractStatusResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitUpdateContractStatusResult", data);
    return promise.then((data) => MsgSubmitUpdateContractStatusResultResponse.decode(new BinaryReader(data)));
  }

  PruneContract(request: MsgPruneContract): Promise<MsgPruneContractResponse> {
    const data = MsgPruneContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "PruneContract", data);
    return promise.then((data) => MsgPruneContractResponse.decode(new BinaryReader(data)));
  }

  SubmitPruneContractResult(request: MsgSubmitPruneContractResult): Promise<MsgSubmitPruneContractResultResponse> {
    const data = MsgSubmitPruneContractResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitPruneContractResult", data);
    return promise.then((data) => MsgSubmitPruneContractResultResponse.decode(new BinaryReader(data)));
  }

  UpgradeContract(request: MsgUpgradeContract): Promise<MsgUpgradeContractResponse> {
    const data = MsgUpgradeContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpgradeContract", data);
    return promise.then((data) => MsgUpgradeContractResponse.decode(new BinaryReader(data)));
  }

  SubmitUpgradeContractResult(
    request: MsgSubmitUpgradeContractResult,
  ): Promise<MsgSubmitUpgradeContractResultResponse> {
    const data = MsgSubmitUpgradeContractResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitUpgradeContractResult", data);
    return promise.then((data) => MsgSubmitUpgradeContractResultResponse.decode(new BinaryReader(data)));
  }

  AddContractAssets(request: MsgAddContractAssets): Promise<MsgAddContractAssetsResponse> {
    const data = MsgAddContractAssets.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddContractAssets", data);
    return promise.then((data) => MsgAddContractAssetsResponse.decode(new BinaryReader(data)));
  }

  SubmitAddContractAssetsResult(
    request: MsgSubmitAddContractAssetsResult,
  ): Promise<MsgSubmitAddContractAssetsResultResponse> {
    const data = MsgSubmitAddContractAssetsResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitAddContractAssetsResult", data);
    return promise.then((data) => MsgSubmitAddContractAssetsResultResponse.decode(new BinaryReader(data)));
  }

  DeleteContractAsset(request: MsgDeleteContractAsset): Promise<MsgDeleteContractAssetResponse> {
    const data = MsgDeleteContractAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteContractAsset", data);
    return promise.then((data) => MsgDeleteContractAssetResponse.decode(new BinaryReader(data)));
  }

  SubmitDeleteContractAssetResult(
    request: MsgSubmitDeleteContractAssetResult,
  ): Promise<MsgSubmitDeleteContractAssetResultResponse> {
    const data = MsgSubmitDeleteContractAssetResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitDeleteContractAssetResult", data);
    return promise.then((data) => MsgSubmitDeleteContractAssetResultResponse.decode(new BinaryReader(data)));
  }

  WhitelistContractAsset(request: MsgWhitelistContractAsset): Promise<MsgWhitelistContractAssetResponse> {
    const data = MsgWhitelistContractAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "WhitelistContractAsset", data);
    return promise.then((data) => MsgWhitelistContractAssetResponse.decode(new BinaryReader(data)));
  }

  SubmitWhitelistContractAssetResult(
    request: MsgSubmitWhitelistContractAssetResult,
  ): Promise<MsgSubmitWhitelistContractAssetResultResponse> {
    const data = MsgSubmitWhitelistContractAssetResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitWhitelistContractAssetResult", data);
    return promise.then((data) => MsgSubmitWhitelistContractAssetResultResponse.decode(new BinaryReader(data)));
  }

  UnwhitelistContractAsset(request: MsgUnwhitelistContractAsset): Promise<MsgUnwhitelistContractAssetResponse> {
    const data = MsgUnwhitelistContractAsset.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnwhitelistContractAsset", data);
    return promise.then((data) => MsgUnwhitelistContractAssetResponse.decode(new BinaryReader(data)));
  }

  SubmitUnwhitelistContractAssetResult(
    request: MsgSubmitUnwhitelistContractAssetResult,
  ): Promise<MsgSubmitUnwhitelistContractAssetResultResponse> {
    const data = MsgSubmitUnwhitelistContractAssetResult.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitUnwhitelistContractAssetResult", data);
    return promise.then((data) => MsgSubmitUnwhitelistContractAssetResultResponse.decode(new BinaryReader(data)));
  }

  ResolveQuarantinedTransfers(
    request: MsgResolveQuarantinedTransfers,
  ): Promise<MsgResolveQuarantinedTransfersResponse> {
    const data = MsgResolveQuarantinedTransfers.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResolveQuarantinedTransfers", data);
    return promise.then((data) => MsgResolveQuarantinedTransfersResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
