// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: int3face/bridge/v1beta1/proposals.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../../google/protobuf/any";
import {
  AssetID,
  AssetStatus,
  assetStatusFromJSON,
  assetStatusToJSON,
  BridgeStatus,
  bridgeStatusFromJSON,
  bridgeStatusToJSON,
  Chain,
  ChainAssetStatus,
  chainAssetStatusFromJSON,
  chainAssetStatusToJSON,
  ChainRetryParams,
  ChainStatus,
  chainStatusFromJSON,
  chainStatusToJSON,
  ContractUpgradeData,
  GasParams,
  IbcAssetSwap,
  ProposalResult,
  proposalResultFromJSON,
  proposalResultToJSON,
  QuarantineResolves,
  Signer,
  UtxoRelayerParams,
} from "./bridge";

export const protobufPackage = "int3face.bridge.v1beta1";

export enum ProposalFinalizationType {
  PROPOSAL_FINALIZATION_TYPE_UNSPECIFIED = 0,
  PROPOSAL_FINALIZATION_TYPE_INSTANT = 1,
  PROPOSAL_FINALIZATION_TYPE_VOTING = 2,
  UNRECOGNIZED = -1,
}

export function proposalFinalizationTypeFromJSON(object: any): ProposalFinalizationType {
  switch (object) {
    case 0:
    case "PROPOSAL_FINALIZATION_TYPE_UNSPECIFIED":
      return ProposalFinalizationType.PROPOSAL_FINALIZATION_TYPE_UNSPECIFIED;
    case 1:
    case "PROPOSAL_FINALIZATION_TYPE_INSTANT":
      return ProposalFinalizationType.PROPOSAL_FINALIZATION_TYPE_INSTANT;
    case 2:
    case "PROPOSAL_FINALIZATION_TYPE_VOTING":
      return ProposalFinalizationType.PROPOSAL_FINALIZATION_TYPE_VOTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProposalFinalizationType.UNRECOGNIZED;
  }
}

export function proposalFinalizationTypeToJSON(object: ProposalFinalizationType): string {
  switch (object) {
    case ProposalFinalizationType.PROPOSAL_FINALIZATION_TYPE_UNSPECIFIED:
      return "PROPOSAL_FINALIZATION_TYPE_UNSPECIFIED";
    case ProposalFinalizationType.PROPOSAL_FINALIZATION_TYPE_INSTANT:
      return "PROPOSAL_FINALIZATION_TYPE_INSTANT";
    case ProposalFinalizationType.PROPOSAL_FINALIZATION_TYPE_VOTING:
      return "PROPOSAL_FINALIZATION_TYPE_VOTING";
    case ProposalFinalizationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * MsgUpdateBridgeStatus defines the message structure for the
 * UpdateBridgeStatus gRPC method. It allows to update bridge status.
 */
export interface MsgUpdateBridgeStatus {
  sender: string;
  status: BridgeStatus;
}

export interface MsgUpdateBridgeStatusResponse {
}

/**
 * MsgTssKeyGen defines the message structure for the TssKeyGen gRPC method.
 * It allows to generate the TSS key for the bridge module.
 */
export interface MsgTssKeyGen {
  /** Sender is a sender's Int3face address */
  sender: string;
  /**
   * TssSigners is the new TSS signers of the bridge for UTXO chains
   * This is a list of Int3face addresses of the signers.
   */
  tssSigners: string[];
  /**
   * Randomness is used in the leader election during the key generation
   * process and can be considered a deterministic source of entropy for all
   * peers. Essentially, just a random number.
   */
  randomness: Long;
}

export interface MsgTssKeyGenResponse {
}

/**
 * MsgTssKeyGenResult defines the message structure for the TssKeyGenResult gRPC
 * method. It allows to get the result of the TSS key generation for the bridge
 * module. Note: This method is used for Observers voting on the the TSS keygen
 * result.
 */
export interface MsgTssKeyGenResult {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** KeygenId is the keygen id */
  keygenId: string;
  /**
   * TssSigners is the new signers of the bridge for UTXO chains
   * This is a list of Int3face addresses of the signers.
   */
  tssSigners: string[];
  /** TssPookPK is the TSS public key */
  tssPoolPk: string;
}

export interface MsgTssKeyGenResultResponse {
}

/**
 * MsgTssVaultMigration defines the message structure for the
 * TssVaultMigration gRPC method. It allows to migrate some amount of tokens
 * from the current vault used by the chains to the new vault from the passed
 * TSS keygen ID. As an option, the vault address could be switched to the new
 * one once the migration is finalized -> Set the vault address from the TSS
 * keygen ID in the chains params.
 */
export interface MsgTssVaultMigration {
  sender: string;
  /**
   * Chains are the chain's unique names (identifiers)
   * with the amounts to be migrated.
   */
  chains: TssChainToMigrate[];
  /**
   * KeygenId is the TSS Keygen ID to migrate to.
   * MUST be already performed and finalized in the x/bridge state.
   */
  keygenId: string;
  /**
   * SkipVaultUpdate is a flag to disable the vault address updating once the
   * migration is finalized. Could be used for more granular control over the
   * vault address updating.
   */
  skipVaultUpdate: boolean;
}

export interface TssChainToMigrate {
  /** ChainID is the chain's unique name (identifier). */
  chainId: string;
  /**
   * Amount is the amount of tokens to be transferred from the current vault to
   * the new vault.
   */
  amount: string;
  migrateAllFunds: boolean;
}

export interface MsgTssVaultMigrationResponse {
}

/**
 * MsgTssVaultUpdate defines the message structure for the
 * TssVaultUpdate gRPC method. It allows to update the vault address
 * currently used by the chains to the new vault from the passed TSS keygen ID.
 */
export interface MsgTssVaultUpdate {
  sender: string;
  /**
   * ChainIDs is the chain's unique names (identifiers)
   * These are the chains that will be updated to the new vault.
   */
  chainIds: string[];
  /**
   * KeygenId is the TSS Keygen ID to update to.
   * MUST be already performed and finalized in the x/bridge state.
   */
  keygenId: string;
}

export interface MsgTssVaultUpdateResponse {
}

/**
 * MsgCreateAsset defines the message structure for the CreateAsset gRPC
 * method. It allows to add new Asset to the bridge module.
 */
export interface MsgCreateAsset {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ID is the asset's primary key */
  id:
    | AssetID
    | undefined;
  /** Exponent represents the power of 10 used for coin representation */
  exponent: Long;
  /** Minimal amount of tokens for transfer */
  minTransferAmount: string;
}

export interface MsgCreateAssetResponse {
}

/**
 * MsgMintAsset defines the message structure for the MintAsset gRPC method.
 * It allows to mint an Asset to the passed address.
 */
export interface MsgMintAsset {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ID is the asset's key */
  id:
    | AssetID
    | undefined;
  /** Amount of coins to mint */
  amount: string;
  /** DestAddr is a destination address to mint to */
  destAddr: string;
}

export interface MsgMintAssetResponse {
}

/**
 * MsgBurnAsset defines the message structure for the BurnAsset gRPC method.
 * It allows to burn an Asset from the passed address.
 */
export interface MsgBurnAsset {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ID is the asset's key */
  id:
    | AssetID
    | undefined;
  /** Amount of coins to burn */
  amount: string;
  /** DestAddr is an address to burn from */
  destAddr: string;
}

export interface MsgBurnAssetResponse {
}

/**
 * MsgUpdateAssetStatus defines the message structure for the UpdateAssetStatus
 * gRPC method. It allows to update the status of the Asset in the bridge
 * module.
 */
export interface MsgUpdateAssetStatus {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ID is the asset's primary key */
  id:
    | AssetID
    | undefined;
  /** Status is the new status of the asset */
  status: AssetStatus;
}

export interface MsgUpdateAssetStatusResponse {
}

/**
 * MsgRemoveAsset defines the message structure for the RemoveAsset gRPC method.
 * It allows to remove the Asset from the bridge module.
 * Deletion could be allowed only if the asset has no liquidity and removed from
 * all the chains.
 */
export interface MsgRemoveAsset {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ID is the asset's primary key */
  id: AssetID | undefined;
}

export interface MsgRemoveAssetResponse {
}

/**
 * MsgUpdateAssetMinTransferAmount defines the message structure for the
 * UpdateAssetMinTransferAmount gRPC method. It allows to update the minimal
 * transfer amount of the Asset in the bridge module.
 */
export interface MsgUpdateAssetMinTransferAmount {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ID is the asset's primary key */
  id:
    | AssetID
    | undefined;
  /** MinTransferAmount is the new minimal transfer amount of the asset */
  minTransferAmount: string;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgUpdateAssetMinTransferAmountResponse {
}

/**
 * MsgUpdateAssetMinTransferAmountResult defines the message structure for the
 * UpdateAssetMinTransferAmountResult gRPC method. It allows to update the
 * minimal transfer amount of the Asset in the bridge module.
 */
export interface MsgUpdateAssetMinTransferAmountResult {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ID is the asset's primary key */
  id:
    | AssetID
    | undefined;
  /** MintTransferAmount is the new minimal transfer amount of the asset */
  minTransferAmount: string;
}

/**
 * MsgSetChainParams defines the message structure for the SetChainParams gRPC
 * method. It allows to set the all the chain parameters in the bridge module.
 * Should not be observed by observers and could be used only in correctional
 * purposes.
 */
export interface MsgSetChainParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** Params is the new chain parameters */
  chainParams: Chain | undefined;
}

export interface MsgSetChainParamsResponse {
}

/**
 * MsgAddChain defines the message structure for the AddChain gRPC
 * method. It allows to add new chain into the bridge module.
 */
export interface MsgAddChain {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** Chain is a new chain's parameters */
  chain: Chain | undefined;
}

export interface MsgAddChainResponse {
}

/**
 * MsgRemoveChain defines the message structure for the RemoveChain gRPC
 * method. It allows to remove a chain from the bridge module.
 */
export interface MsgRemoveChain {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
}

export interface MsgRemoveChainResponse {
}

/**
 * MsgUpdateChainStatus defines the message structure for the UpdateChainStatus
 * gRPC method. It allows to update the status of the Chain in the bridge
 * module.
 */
export interface MsgUpdateChainStatus {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** Status is the new status of the chain */
  status: ChainStatus;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgUpdateChainStatusResponse {
}

/**
 * MsgUpdateChainRetryParams defines the message structure for the
 * UpdateChainRetryParams gRPC method. It allows to update the retry parameters
 * of the Chain in the bridge module.
 */
export interface MsgUpdateChainRetryParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** RetryParams is the new retry parameters of the chain */
  retryParams: ChainRetryParams | undefined;
}

export interface MsgUpdateChainRetryParamsResponse {
}

/**
 * MsgUpdateChainAssetStatus defines the message structure for the
 * UpdateChainAssetStatus gRPC method. It allows to update the status of the
 * Asset in the chain in the bridge module.
 */
export interface MsgUpdateChainAssetStatus {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** AssetID is the asset's primary key */
  assetId:
    | AssetID
    | undefined;
  /** Status is the new status of the asset in the chain */
  status: ChainAssetStatus;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgUpdateChainAssetStatusResponse {
}

/**
 * MsgAddChainAsset defines the message structure for the AddAsset gRPC method.
 * It allows to add new Asset to a specified chain.
 */
export interface MsgAddChainAsset {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** Asset is the new asset to be added */
  asset:
    | Any
    | undefined;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgAddChainAssetResponse {
}

/**
 * MsgRemoveChainAsset defines the message structure for the RemoveChainAsset
 * gRPC method. It allows to remove the Asset from the chain in the bridge
 * module. Deletion could be allowed only if the asset has no liquidity and
 * removed from all the chains.
 */
export interface MsgRemoveChainAsset {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** AssetID is the asset's primary key */
  assetId:
    | AssetID
    | undefined;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgRemoveChainAssetResponse {
}

/**
 * MsgSetChainSigners defines the message structure for the SetChainSigners
 * gRPC method. It allows to set new signers list of the Chain in the bridge
 * module.
 */
export interface MsgSetChainSigners {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** Signers is the new signers of the chain */
  signers: Signer[];
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgSetChainSignersResponse {
}

/**
 * MsgSetChainGasParams defines the message structure for the
 * UpdateChainGasParams gRPC method. It allows to update the gas parameters
 * of the Chain in the bridge module.
 */
export interface MsgSetChainGasParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** GasParams is the new gas parameters of the chain */
  gasParams:
    | GasParams
    | undefined;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgSetChainGasParamsResponse {
}

/**
 * MsgSetChainConfirmationsRequired defines the message structure for the
 * UpdateChainConfirmationsRequired gRPC method. It allows to update the
 * confirmations of the Chain in the bridge module.
 */
export interface MsgSetChainConfirmationsRequired {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** Confirmations is the new confirmations of the chain */
  confirmations: Long;
}

export interface MsgSetChainConfirmationsRequiredResponse {
}

/**
 * MsgSetUtxoChainRelayerParams defines the message structure for the
 * SetUtxoChainRelayerParams gRPC method. It allows to update the relayer
 * parameters of the UTXO Chain in the bridge module.
 */
export interface MsgSetUtxoChainRelayerParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** RelayerParams is the new relayer parameters of the chain */
  relayerParams: UtxoRelayerParams | undefined;
}

export interface MsgSetUtxoChainRelayerParamsResponse {
}

/**
 * MsgPruneSmartContractChainContract defines the message structure for the
 * PruneSmartContractChainContract gRPC method. It allows to prune the contract
 * from the Smart Contract chain.
 */
export interface MsgPruneSmartContractChainContract {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** PruneBefore is a timestamp before which the data should be pruned. */
  pruneBefore: Long;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgPruneSmartContractChainContractResponse {
}

/**
 * MsgUpgradeSmartContractChainContract defines the message structure for the
 * UpgradeSmartContractChainContract gRPC method. It allows to upgrade the
 * contract on the Smart Contract chain.
 */
export interface MsgUpgradeSmartContractChainContract {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /**
   * ContractUpgradeData is the encoded contract data related to the concrete
   * chain.
   */
  upgradeData:
    | ContractUpgradeData
    | undefined;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgUpgradeSmartContractChainContractResponse {
}

/**
 * MsgSetSmartContractChainAssetsDestChainIds defines the message structure for
 * the SetSmartContractChainAssetsDestChainIds gRPC method. It allows to set the
 * destination chain IDs for the assets on the Smart Contract chain.
 */
export interface MsgSetSmartContractChainAssetsDestChainIds {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** AssetDestChainIds is the destination chain IDs for the assets */
  assets: AssetDestChainIds[];
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface AssetDestChainIds {
  /** AssetID is the asset's primary key */
  assetId:
    | AssetID
    | undefined;
  /** DestChainIDs is the destination chain IDs for the asset */
  destChainIds: string[];
}

export interface MsgSetSmartContractChainAssetsDestChainIdsResponse {
}

/**
 * MsgUpdateIbcChainParams defines the message structure for the
 * UpdateIbcChainParams gRPC method. It allows to update the IBC chain
 * parameters of the IBC Chain in the bridge module.
 */
export interface MsgUpdateIbcChainParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** ChannelId is the channel on the local chain */
  channelId: string;
  /** PortId is the port on the local chain */
  portId: string;
  /** Timeout is the timeout height of the IBC chain */
  timeout: Long;
}

export interface MsgUpdateIbcChainParamsResponse {
}

export interface MsgUpdateIbcChainAssetParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** AssetID is the asset's primary key */
  assetId:
    | AssetID
    | undefined;
  /** LocalIbcDenom is the denom's representation on the Int3face chain */
  localIbcDenom: string;
  /** ExternalIbcDenom is the denom's representation on the external chain */
  externalIbcDenom: string;
  /** Swap is the asset swap parameters */
  swap: IbcAssetSwap | undefined;
}

export interface MsgUpdateIbcChainAssetParamsResponse {
}

export interface MsgUpdateNttChainParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** WormholeProgramId is the id of the new Wormhole program */
  wormholeProgram: string;
  /** NttChainId is the id of the chain in the NTT protocol */
  nttChainId: Long;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
}

export interface MsgUpdateNttChainParamsResponse {
}

export interface MsgUpdateNttChainAssetAddresses {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** AssetID is the asset's primary key */
  assetId: AssetID | undefined;
  nttManagerAddress: string;
  externalNttManagerAddress: string;
  externalTokenAddress: string;
  /** FinalizationType is the proposal finalization type */
  finalizationType: ProposalFinalizationType;
  /** EvfcIds is the list of chain ids expected to confirm the proposal */
  evfcIds: string[];
  nttTransceivers: string[];
  externalNttTransceivers: string[];
}

export interface MsgUpdateNttChainAssetAddressesResponse {
}

export interface MsgSubmitProposalResult {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ProposalId is an ID of the precessed proposal */
  proposalId: Long;
  /** ChainId is an ID of the reporting chain */
  chainId: string;
  /** Result is a result of the proposal */
  result: ProposalResult;
  /** BroadcastedTxHash is the hash of the transaction on the external chain */
  broadcastedTxHash: string;
}

export interface MsgSubmitProposalResultResponse {
}

export interface MsgResolveQuarantinedTransfers {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** Array of quarantined transfers to resolve */
  resolves: QuarantineResolves[];
}

export interface MsgResolveQuarantinedTransfersResponse {
}

function createBaseMsgUpdateBridgeStatus(): MsgUpdateBridgeStatus {
  return { sender: "", status: 0 };
}

export const MsgUpdateBridgeStatus: MessageFns<MsgUpdateBridgeStatus> = {
  encode(message: MsgUpdateBridgeStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateBridgeStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateBridgeStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateBridgeStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      status: isSet(object.status) ? bridgeStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MsgUpdateBridgeStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.status !== 0) {
      obj.status = bridgeStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateBridgeStatus>): MsgUpdateBridgeStatus {
    return MsgUpdateBridgeStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateBridgeStatus>): MsgUpdateBridgeStatus {
    const message = createBaseMsgUpdateBridgeStatus();
    message.sender = object.sender ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseMsgUpdateBridgeStatusResponse(): MsgUpdateBridgeStatusResponse {
  return {};
}

export const MsgUpdateBridgeStatusResponse: MessageFns<MsgUpdateBridgeStatusResponse> = {
  encode(_: MsgUpdateBridgeStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateBridgeStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateBridgeStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateBridgeStatusResponse {
    return {};
  },

  toJSON(_: MsgUpdateBridgeStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateBridgeStatusResponse>): MsgUpdateBridgeStatusResponse {
    return MsgUpdateBridgeStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateBridgeStatusResponse>): MsgUpdateBridgeStatusResponse {
    const message = createBaseMsgUpdateBridgeStatusResponse();
    return message;
  },
};

function createBaseMsgTssKeyGen(): MsgTssKeyGen {
  return { sender: "", tssSigners: [], randomness: Long.UZERO };
}

export const MsgTssKeyGen: MessageFns<MsgTssKeyGen> = {
  encode(message: MsgTssKeyGen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.tssSigners) {
      writer.uint32(18).string(v!);
    }
    if (!message.randomness.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.randomness.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssKeyGen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssKeyGen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tssSigners.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.randomness = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTssKeyGen {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      tssSigners: globalThis.Array.isArray(object?.tssSigners)
        ? object.tssSigners.map((e: any) => globalThis.String(e))
        : [],
      randomness: isSet(object.randomness) ? Long.fromValue(object.randomness) : Long.UZERO,
    };
  },

  toJSON(message: MsgTssKeyGen): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.tssSigners?.length) {
      obj.tssSigners = message.tssSigners;
    }
    if (!message.randomness.equals(Long.UZERO)) {
      obj.randomness = (message.randomness || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTssKeyGen>): MsgTssKeyGen {
    return MsgTssKeyGen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTssKeyGen>): MsgTssKeyGen {
    const message = createBaseMsgTssKeyGen();
    message.sender = object.sender ?? "";
    message.tssSigners = object.tssSigners?.map((e) => e) || [];
    message.randomness = (object.randomness !== undefined && object.randomness !== null)
      ? Long.fromValue(object.randomness)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgTssKeyGenResponse(): MsgTssKeyGenResponse {
  return {};
}

export const MsgTssKeyGenResponse: MessageFns<MsgTssKeyGenResponse> = {
  encode(_: MsgTssKeyGenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssKeyGenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssKeyGenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTssKeyGenResponse {
    return {};
  },

  toJSON(_: MsgTssKeyGenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTssKeyGenResponse>): MsgTssKeyGenResponse {
    return MsgTssKeyGenResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTssKeyGenResponse>): MsgTssKeyGenResponse {
    const message = createBaseMsgTssKeyGenResponse();
    return message;
  },
};

function createBaseMsgTssKeyGenResult(): MsgTssKeyGenResult {
  return { sender: "", keygenId: "", tssSigners: [], tssPoolPk: "" };
}

export const MsgTssKeyGenResult: MessageFns<MsgTssKeyGenResult> = {
  encode(message: MsgTssKeyGenResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.keygenId !== "") {
      writer.uint32(18).string(message.keygenId);
    }
    for (const v of message.tssSigners) {
      writer.uint32(26).string(v!);
    }
    if (message.tssPoolPk !== "") {
      writer.uint32(34).string(message.tssPoolPk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssKeyGenResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssKeyGenResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tssSigners.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tssPoolPk = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTssKeyGenResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
      tssSigners: globalThis.Array.isArray(object?.tssSigners)
        ? object.tssSigners.map((e: any) => globalThis.String(e))
        : [],
      tssPoolPk: isSet(object.tssPoolPk) ? globalThis.String(object.tssPoolPk) : "",
    };
  },

  toJSON(message: MsgTssKeyGenResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    if (message.tssSigners?.length) {
      obj.tssSigners = message.tssSigners;
    }
    if (message.tssPoolPk !== "") {
      obj.tssPoolPk = message.tssPoolPk;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTssKeyGenResult>): MsgTssKeyGenResult {
    return MsgTssKeyGenResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTssKeyGenResult>): MsgTssKeyGenResult {
    const message = createBaseMsgTssKeyGenResult();
    message.sender = object.sender ?? "";
    message.keygenId = object.keygenId ?? "";
    message.tssSigners = object.tssSigners?.map((e) => e) || [];
    message.tssPoolPk = object.tssPoolPk ?? "";
    return message;
  },
};

function createBaseMsgTssKeyGenResultResponse(): MsgTssKeyGenResultResponse {
  return {};
}

export const MsgTssKeyGenResultResponse: MessageFns<MsgTssKeyGenResultResponse> = {
  encode(_: MsgTssKeyGenResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssKeyGenResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssKeyGenResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTssKeyGenResultResponse {
    return {};
  },

  toJSON(_: MsgTssKeyGenResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTssKeyGenResultResponse>): MsgTssKeyGenResultResponse {
    return MsgTssKeyGenResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTssKeyGenResultResponse>): MsgTssKeyGenResultResponse {
    const message = createBaseMsgTssKeyGenResultResponse();
    return message;
  },
};

function createBaseMsgTssVaultMigration(): MsgTssVaultMigration {
  return { sender: "", chains: [], keygenId: "", skipVaultUpdate: false };
}

export const MsgTssVaultMigration: MessageFns<MsgTssVaultMigration> = {
  encode(message: MsgTssVaultMigration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.chains) {
      TssChainToMigrate.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.keygenId !== "") {
      writer.uint32(26).string(message.keygenId);
    }
    if (message.skipVaultUpdate !== false) {
      writer.uint32(32).bool(message.skipVaultUpdate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssVaultMigration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssVaultMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chains.push(TssChainToMigrate.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skipVaultUpdate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTssVaultMigration {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chains: globalThis.Array.isArray(object?.chains)
        ? object.chains.map((e: any) => TssChainToMigrate.fromJSON(e))
        : [],
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
      skipVaultUpdate: isSet(object.skipVaultUpdate) ? globalThis.Boolean(object.skipVaultUpdate) : false,
    };
  },

  toJSON(message: MsgTssVaultMigration): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => TssChainToMigrate.toJSON(e));
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    if (message.skipVaultUpdate !== false) {
      obj.skipVaultUpdate = message.skipVaultUpdate;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTssVaultMigration>): MsgTssVaultMigration {
    return MsgTssVaultMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTssVaultMigration>): MsgTssVaultMigration {
    const message = createBaseMsgTssVaultMigration();
    message.sender = object.sender ?? "";
    message.chains = object.chains?.map((e) => TssChainToMigrate.fromPartial(e)) || [];
    message.keygenId = object.keygenId ?? "";
    message.skipVaultUpdate = object.skipVaultUpdate ?? false;
    return message;
  },
};

function createBaseTssChainToMigrate(): TssChainToMigrate {
  return { chainId: "", amount: "", migrateAllFunds: false };
}

export const TssChainToMigrate: MessageFns<TssChainToMigrate> = {
  encode(message: TssChainToMigrate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.migrateAllFunds !== false) {
      writer.uint32(24).bool(message.migrateAllFunds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TssChainToMigrate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTssChainToMigrate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.migrateAllFunds = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TssChainToMigrate {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      migrateAllFunds: isSet(object.migrateAllFunds) ? globalThis.Boolean(object.migrateAllFunds) : false,
    };
  },

  toJSON(message: TssChainToMigrate): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.migrateAllFunds !== false) {
      obj.migrateAllFunds = message.migrateAllFunds;
    }
    return obj;
  },

  create(base?: DeepPartial<TssChainToMigrate>): TssChainToMigrate {
    return TssChainToMigrate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TssChainToMigrate>): TssChainToMigrate {
    const message = createBaseTssChainToMigrate();
    message.chainId = object.chainId ?? "";
    message.amount = object.amount ?? "";
    message.migrateAllFunds = object.migrateAllFunds ?? false;
    return message;
  },
};

function createBaseMsgTssVaultMigrationResponse(): MsgTssVaultMigrationResponse {
  return {};
}

export const MsgTssVaultMigrationResponse: MessageFns<MsgTssVaultMigrationResponse> = {
  encode(_: MsgTssVaultMigrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssVaultMigrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssVaultMigrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTssVaultMigrationResponse {
    return {};
  },

  toJSON(_: MsgTssVaultMigrationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTssVaultMigrationResponse>): MsgTssVaultMigrationResponse {
    return MsgTssVaultMigrationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTssVaultMigrationResponse>): MsgTssVaultMigrationResponse {
    const message = createBaseMsgTssVaultMigrationResponse();
    return message;
  },
};

function createBaseMsgTssVaultUpdate(): MsgTssVaultUpdate {
  return { sender: "", chainIds: [], keygenId: "" };
}

export const MsgTssVaultUpdate: MessageFns<MsgTssVaultUpdate> = {
  encode(message: MsgTssVaultUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.chainIds) {
      writer.uint32(18).string(v!);
    }
    if (message.keygenId !== "") {
      writer.uint32(26).string(message.keygenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssVaultUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssVaultUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTssVaultUpdate {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainIds: globalThis.Array.isArray(object?.chainIds) ? object.chainIds.map((e: any) => globalThis.String(e)) : [],
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
    };
  },

  toJSON(message: MsgTssVaultUpdate): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainIds?.length) {
      obj.chainIds = message.chainIds;
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTssVaultUpdate>): MsgTssVaultUpdate {
    return MsgTssVaultUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTssVaultUpdate>): MsgTssVaultUpdate {
    const message = createBaseMsgTssVaultUpdate();
    message.sender = object.sender ?? "";
    message.chainIds = object.chainIds?.map((e) => e) || [];
    message.keygenId = object.keygenId ?? "";
    return message;
  },
};

function createBaseMsgTssVaultUpdateResponse(): MsgTssVaultUpdateResponse {
  return {};
}

export const MsgTssVaultUpdateResponse: MessageFns<MsgTssVaultUpdateResponse> = {
  encode(_: MsgTssVaultUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTssVaultUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTssVaultUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTssVaultUpdateResponse {
    return {};
  },

  toJSON(_: MsgTssVaultUpdateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTssVaultUpdateResponse>): MsgTssVaultUpdateResponse {
    return MsgTssVaultUpdateResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTssVaultUpdateResponse>): MsgTssVaultUpdateResponse {
    const message = createBaseMsgTssVaultUpdateResponse();
    return message;
  },
};

function createBaseMsgCreateAsset(): MsgCreateAsset {
  return { sender: "", id: undefined, exponent: Long.UZERO, minTransferAmount: "" };
}

export const MsgCreateAsset: MessageFns<MsgCreateAsset> = {
  encode(message: MsgCreateAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (!message.exponent.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.exponent.toString());
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(42).string(message.minTransferAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exponent = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      exponent: isSet(object.exponent) ? Long.fromValue(object.exponent) : Long.UZERO,
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
    };
  },

  toJSON(message: MsgCreateAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (!message.exponent.equals(Long.UZERO)) {
      obj.exponent = (message.exponent || Long.UZERO).toString();
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCreateAsset>): MsgCreateAsset {
    return MsgCreateAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCreateAsset>): MsgCreateAsset {
    const message = createBaseMsgCreateAsset();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.exponent = (object.exponent !== undefined && object.exponent !== null)
      ? Long.fromValue(object.exponent)
      : Long.UZERO;
    message.minTransferAmount = object.minTransferAmount ?? "";
    return message;
  },
};

function createBaseMsgCreateAssetResponse(): MsgCreateAssetResponse {
  return {};
}

export const MsgCreateAssetResponse: MessageFns<MsgCreateAssetResponse> = {
  encode(_: MsgCreateAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateAssetResponse {
    return {};
  },

  toJSON(_: MsgCreateAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCreateAssetResponse>): MsgCreateAssetResponse {
    return MsgCreateAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgCreateAssetResponse>): MsgCreateAssetResponse {
    const message = createBaseMsgCreateAssetResponse();
    return message;
  },
};

function createBaseMsgMintAsset(): MsgMintAsset {
  return { sender: "", id: undefined, amount: "", destAddr: "" };
}

export const MsgMintAsset: MessageFns<MsgMintAsset> = {
  encode(message: MsgMintAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.destAddr !== "") {
      writer.uint32(34).string(message.destAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMintAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMintAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMintAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
    };
  },

  toJSON(message: MsgMintAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgMintAsset>): MsgMintAsset {
    return MsgMintAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgMintAsset>): MsgMintAsset {
    const message = createBaseMsgMintAsset();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.amount = object.amount ?? "";
    message.destAddr = object.destAddr ?? "";
    return message;
  },
};

function createBaseMsgMintAssetResponse(): MsgMintAssetResponse {
  return {};
}

export const MsgMintAssetResponse: MessageFns<MsgMintAssetResponse> = {
  encode(_: MsgMintAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMintAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMintAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMintAssetResponse {
    return {};
  },

  toJSON(_: MsgMintAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgMintAssetResponse>): MsgMintAssetResponse {
    return MsgMintAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgMintAssetResponse>): MsgMintAssetResponse {
    const message = createBaseMsgMintAssetResponse();
    return message;
  },
};

function createBaseMsgBurnAsset(): MsgBurnAsset {
  return { sender: "", id: undefined, amount: "", destAddr: "" };
}

export const MsgBurnAsset: MessageFns<MsgBurnAsset> = {
  encode(message: MsgBurnAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.destAddr !== "") {
      writer.uint32(34).string(message.destAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurnAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurnAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBurnAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
    };
  },

  toJSON(message: MsgBurnAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBurnAsset>): MsgBurnAsset {
    return MsgBurnAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgBurnAsset>): MsgBurnAsset {
    const message = createBaseMsgBurnAsset();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.amount = object.amount ?? "";
    message.destAddr = object.destAddr ?? "";
    return message;
  },
};

function createBaseMsgBurnAssetResponse(): MsgBurnAssetResponse {
  return {};
}

export const MsgBurnAssetResponse: MessageFns<MsgBurnAssetResponse> = {
  encode(_: MsgBurnAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurnAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurnAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBurnAssetResponse {
    return {};
  },

  toJSON(_: MsgBurnAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgBurnAssetResponse>): MsgBurnAssetResponse {
    return MsgBurnAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgBurnAssetResponse>): MsgBurnAssetResponse {
    const message = createBaseMsgBurnAssetResponse();
    return message;
  },
};

function createBaseMsgUpdateAssetStatus(): MsgUpdateAssetStatus {
  return { sender: "", id: undefined, status: 0 };
}

export const MsgUpdateAssetStatus: MessageFns<MsgUpdateAssetStatus> = {
  encode(message: MsgUpdateAssetStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateAssetStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAssetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateAssetStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? assetStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MsgUpdateAssetStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = assetStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateAssetStatus>): MsgUpdateAssetStatus {
    return MsgUpdateAssetStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateAssetStatus>): MsgUpdateAssetStatus {
    const message = createBaseMsgUpdateAssetStatus();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseMsgUpdateAssetStatusResponse(): MsgUpdateAssetStatusResponse {
  return {};
}

export const MsgUpdateAssetStatusResponse: MessageFns<MsgUpdateAssetStatusResponse> = {
  encode(_: MsgUpdateAssetStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateAssetStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAssetStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateAssetStatusResponse {
    return {};
  },

  toJSON(_: MsgUpdateAssetStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateAssetStatusResponse>): MsgUpdateAssetStatusResponse {
    return MsgUpdateAssetStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateAssetStatusResponse>): MsgUpdateAssetStatusResponse {
    const message = createBaseMsgUpdateAssetStatusResponse();
    return message;
  },
};

function createBaseMsgRemoveAsset(): MsgRemoveAsset {
  return { sender: "", id: undefined };
}

export const MsgRemoveAsset: MessageFns<MsgRemoveAsset> = {
  encode(message: MsgRemoveAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: MsgRemoveAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveAsset>): MsgRemoveAsset {
    return MsgRemoveAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveAsset>): MsgRemoveAsset {
    const message = createBaseMsgRemoveAsset();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseMsgRemoveAssetResponse(): MsgRemoveAssetResponse {
  return {};
}

export const MsgRemoveAssetResponse: MessageFns<MsgRemoveAssetResponse> = {
  encode(_: MsgRemoveAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveAssetResponse {
    return {};
  },

  toJSON(_: MsgRemoveAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveAssetResponse>): MsgRemoveAssetResponse {
    return MsgRemoveAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveAssetResponse>): MsgRemoveAssetResponse {
    const message = createBaseMsgRemoveAssetResponse();
    return message;
  },
};

function createBaseMsgUpdateAssetMinTransferAmount(): MsgUpdateAssetMinTransferAmount {
  return { sender: "", id: undefined, minTransferAmount: "", finalizationType: 0, evfcIds: [] };
}

export const MsgUpdateAssetMinTransferAmount: MessageFns<MsgUpdateAssetMinTransferAmount> = {
  encode(message: MsgUpdateAssetMinTransferAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(26).string(message.minTransferAmount);
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateAssetMinTransferAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAssetMinTransferAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateAssetMinTransferAmount {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgUpdateAssetMinTransferAmount): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateAssetMinTransferAmount>): MsgUpdateAssetMinTransferAmount {
    return MsgUpdateAssetMinTransferAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateAssetMinTransferAmount>): MsgUpdateAssetMinTransferAmount {
    const message = createBaseMsgUpdateAssetMinTransferAmount();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.minTransferAmount = object.minTransferAmount ?? "";
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateAssetMinTransferAmountResponse(): MsgUpdateAssetMinTransferAmountResponse {
  return {};
}

export const MsgUpdateAssetMinTransferAmountResponse: MessageFns<MsgUpdateAssetMinTransferAmountResponse> = {
  encode(_: MsgUpdateAssetMinTransferAmountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateAssetMinTransferAmountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAssetMinTransferAmountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateAssetMinTransferAmountResponse {
    return {};
  },

  toJSON(_: MsgUpdateAssetMinTransferAmountResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateAssetMinTransferAmountResponse>): MsgUpdateAssetMinTransferAmountResponse {
    return MsgUpdateAssetMinTransferAmountResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateAssetMinTransferAmountResponse>): MsgUpdateAssetMinTransferAmountResponse {
    const message = createBaseMsgUpdateAssetMinTransferAmountResponse();
    return message;
  },
};

function createBaseMsgUpdateAssetMinTransferAmountResult(): MsgUpdateAssetMinTransferAmountResult {
  return { sender: "", id: undefined, minTransferAmount: "" };
}

export const MsgUpdateAssetMinTransferAmountResult: MessageFns<MsgUpdateAssetMinTransferAmountResult> = {
  encode(message: MsgUpdateAssetMinTransferAmountResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(26).string(message.minTransferAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateAssetMinTransferAmountResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAssetMinTransferAmountResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateAssetMinTransferAmountResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
    };
  },

  toJSON(message: MsgUpdateAssetMinTransferAmountResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateAssetMinTransferAmountResult>): MsgUpdateAssetMinTransferAmountResult {
    return MsgUpdateAssetMinTransferAmountResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateAssetMinTransferAmountResult>): MsgUpdateAssetMinTransferAmountResult {
    const message = createBaseMsgUpdateAssetMinTransferAmountResult();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.minTransferAmount = object.minTransferAmount ?? "";
    return message;
  },
};

function createBaseMsgSetChainParams(): MsgSetChainParams {
  return { sender: "", chainId: "", chainParams: undefined };
}

export const MsgSetChainParams: MessageFns<MsgSetChainParams> = {
  encode(message: MsgSetChainParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.chainParams !== undefined) {
      Chain.encode(message.chainParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainParams = Chain.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetChainParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      chainParams: isSet(object.chainParams) ? Chain.fromJSON(object.chainParams) : undefined,
    };
  },

  toJSON(message: MsgSetChainParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.chainParams !== undefined) {
      obj.chainParams = Chain.toJSON(message.chainParams);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainParams>): MsgSetChainParams {
    return MsgSetChainParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSetChainParams>): MsgSetChainParams {
    const message = createBaseMsgSetChainParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.chainParams = (object.chainParams !== undefined && object.chainParams !== null)
      ? Chain.fromPartial(object.chainParams)
      : undefined;
    return message;
  },
};

function createBaseMsgSetChainParamsResponse(): MsgSetChainParamsResponse {
  return {};
}

export const MsgSetChainParamsResponse: MessageFns<MsgSetChainParamsResponse> = {
  encode(_: MsgSetChainParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetChainParamsResponse {
    return {};
  },

  toJSON(_: MsgSetChainParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainParamsResponse>): MsgSetChainParamsResponse {
    return MsgSetChainParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSetChainParamsResponse>): MsgSetChainParamsResponse {
    const message = createBaseMsgSetChainParamsResponse();
    return message;
  },
};

function createBaseMsgAddChain(): MsgAddChain {
  return { sender: "", chain: undefined };
}

export const MsgAddChain: MessageFns<MsgAddChain> = {
  encode(message: MsgAddChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chain !== undefined) {
      Chain.encode(message.chain, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chain = Chain.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddChain {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chain: isSet(object.chain) ? Chain.fromJSON(object.chain) : undefined,
    };
  },

  toJSON(message: MsgAddChain): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chain !== undefined) {
      obj.chain = Chain.toJSON(message.chain);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAddChain>): MsgAddChain {
    return MsgAddChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAddChain>): MsgAddChain {
    const message = createBaseMsgAddChain();
    message.sender = object.sender ?? "";
    message.chain = (object.chain !== undefined && object.chain !== null) ? Chain.fromPartial(object.chain) : undefined;
    return message;
  },
};

function createBaseMsgAddChainResponse(): MsgAddChainResponse {
  return {};
}

export const MsgAddChainResponse: MessageFns<MsgAddChainResponse> = {
  encode(_: MsgAddChainResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddChainResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddChainResponse {
    return {};
  },

  toJSON(_: MsgAddChainResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAddChainResponse>): MsgAddChainResponse {
    return MsgAddChainResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAddChainResponse>): MsgAddChainResponse {
    const message = createBaseMsgAddChainResponse();
    return message;
  },
};

function createBaseMsgRemoveChain(): MsgRemoveChain {
  return { sender: "", chainId: "" };
}

export const MsgRemoveChain: MessageFns<MsgRemoveChain> = {
  encode(message: MsgRemoveChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveChain {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
    };
  },

  toJSON(message: MsgRemoveChain): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveChain>): MsgRemoveChain {
    return MsgRemoveChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveChain>): MsgRemoveChain {
    const message = createBaseMsgRemoveChain();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseMsgRemoveChainResponse(): MsgRemoveChainResponse {
  return {};
}

export const MsgRemoveChainResponse: MessageFns<MsgRemoveChainResponse> = {
  encode(_: MsgRemoveChainResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveChainResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveChainResponse {
    return {};
  },

  toJSON(_: MsgRemoveChainResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveChainResponse>): MsgRemoveChainResponse {
    return MsgRemoveChainResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveChainResponse>): MsgRemoveChainResponse {
    const message = createBaseMsgRemoveChainResponse();
    return message;
  },
};

function createBaseMsgUpdateChainStatus(): MsgUpdateChainStatus {
  return { sender: "", chainId: "", status: 0, finalizationType: 0, evfcIds: [] };
}

export const MsgUpdateChainStatus: MessageFns<MsgUpdateChainStatus> = {
  encode(message: MsgUpdateChainStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateChainStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateChainStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateChainStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? chainStatusFromJSON(object.status) : 0,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgUpdateChainStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = chainStatusToJSON(message.status);
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateChainStatus>): MsgUpdateChainStatus {
    return MsgUpdateChainStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateChainStatus>): MsgUpdateChainStatus {
    const message = createBaseMsgUpdateChainStatus();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateChainStatusResponse(): MsgUpdateChainStatusResponse {
  return {};
}

export const MsgUpdateChainStatusResponse: MessageFns<MsgUpdateChainStatusResponse> = {
  encode(_: MsgUpdateChainStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateChainStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateChainStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateChainStatusResponse {
    return {};
  },

  toJSON(_: MsgUpdateChainStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateChainStatusResponse>): MsgUpdateChainStatusResponse {
    return MsgUpdateChainStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateChainStatusResponse>): MsgUpdateChainStatusResponse {
    const message = createBaseMsgUpdateChainStatusResponse();
    return message;
  },
};

function createBaseMsgUpdateChainRetryParams(): MsgUpdateChainRetryParams {
  return { sender: "", chainId: "", retryParams: undefined };
}

export const MsgUpdateChainRetryParams: MessageFns<MsgUpdateChainRetryParams> = {
  encode(message: MsgUpdateChainRetryParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.retryParams !== undefined) {
      ChainRetryParams.encode(message.retryParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateChainRetryParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateChainRetryParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryParams = ChainRetryParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateChainRetryParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      retryParams: isSet(object.retryParams) ? ChainRetryParams.fromJSON(object.retryParams) : undefined,
    };
  },

  toJSON(message: MsgUpdateChainRetryParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.retryParams !== undefined) {
      obj.retryParams = ChainRetryParams.toJSON(message.retryParams);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateChainRetryParams>): MsgUpdateChainRetryParams {
    return MsgUpdateChainRetryParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateChainRetryParams>): MsgUpdateChainRetryParams {
    const message = createBaseMsgUpdateChainRetryParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.retryParams = (object.retryParams !== undefined && object.retryParams !== null)
      ? ChainRetryParams.fromPartial(object.retryParams)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateChainRetryParamsResponse(): MsgUpdateChainRetryParamsResponse {
  return {};
}

export const MsgUpdateChainRetryParamsResponse: MessageFns<MsgUpdateChainRetryParamsResponse> = {
  encode(_: MsgUpdateChainRetryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateChainRetryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateChainRetryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateChainRetryParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateChainRetryParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateChainRetryParamsResponse>): MsgUpdateChainRetryParamsResponse {
    return MsgUpdateChainRetryParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateChainRetryParamsResponse>): MsgUpdateChainRetryParamsResponse {
    const message = createBaseMsgUpdateChainRetryParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateChainAssetStatus(): MsgUpdateChainAssetStatus {
  return { sender: "", chainId: "", assetId: undefined, status: 0, finalizationType: 0, evfcIds: [] };
}

export const MsgUpdateChainAssetStatus: MessageFns<MsgUpdateChainAssetStatus> = {
  encode(message: MsgUpdateChainAssetStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.finalizationType !== 0) {
      writer.uint32(40).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateChainAssetStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateChainAssetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateChainAssetStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgUpdateChainAssetStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateChainAssetStatus>): MsgUpdateChainAssetStatus {
    return MsgUpdateChainAssetStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateChainAssetStatus>): MsgUpdateChainAssetStatus {
    const message = createBaseMsgUpdateChainAssetStatus();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.status = object.status ?? 0;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateChainAssetStatusResponse(): MsgUpdateChainAssetStatusResponse {
  return {};
}

export const MsgUpdateChainAssetStatusResponse: MessageFns<MsgUpdateChainAssetStatusResponse> = {
  encode(_: MsgUpdateChainAssetStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateChainAssetStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateChainAssetStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateChainAssetStatusResponse {
    return {};
  },

  toJSON(_: MsgUpdateChainAssetStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateChainAssetStatusResponse>): MsgUpdateChainAssetStatusResponse {
    return MsgUpdateChainAssetStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateChainAssetStatusResponse>): MsgUpdateChainAssetStatusResponse {
    const message = createBaseMsgUpdateChainAssetStatusResponse();
    return message;
  },
};

function createBaseMsgAddChainAsset(): MsgAddChainAsset {
  return { sender: "", chainId: "", asset: undefined, finalizationType: 0, evfcIds: [] };
}

export const MsgAddChainAsset: MessageFns<MsgAddChainAsset> = {
  encode(message: MsgAddChainAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      Any.encode(message.asset, writer.uint32(26).fork()).join();
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddChainAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddChainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = Any.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddChainAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? Any.fromJSON(object.asset) : undefined,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgAddChainAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = Any.toJSON(message.asset);
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAddChainAsset>): MsgAddChainAsset {
    return MsgAddChainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAddChainAsset>): MsgAddChainAsset {
    const message = createBaseMsgAddChainAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Any.fromPartial(object.asset) : undefined;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgAddChainAssetResponse(): MsgAddChainAssetResponse {
  return {};
}

export const MsgAddChainAssetResponse: MessageFns<MsgAddChainAssetResponse> = {
  encode(_: MsgAddChainAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddChainAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddChainAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddChainAssetResponse {
    return {};
  },

  toJSON(_: MsgAddChainAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAddChainAssetResponse>): MsgAddChainAssetResponse {
    return MsgAddChainAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAddChainAssetResponse>): MsgAddChainAssetResponse {
    const message = createBaseMsgAddChainAssetResponse();
    return message;
  },
};

function createBaseMsgRemoveChainAsset(): MsgRemoveChainAsset {
  return { sender: "", chainId: "", assetId: undefined, finalizationType: 0, evfcIds: [] };
}

export const MsgRemoveChainAsset: MessageFns<MsgRemoveChainAsset> = {
  encode(message: MsgRemoveChainAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveChainAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveChainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveChainAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgRemoveChainAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveChainAsset>): MsgRemoveChainAsset {
    return MsgRemoveChainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveChainAsset>): MsgRemoveChainAsset {
    const message = createBaseMsgRemoveChainAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgRemoveChainAssetResponse(): MsgRemoveChainAssetResponse {
  return {};
}

export const MsgRemoveChainAssetResponse: MessageFns<MsgRemoveChainAssetResponse> = {
  encode(_: MsgRemoveChainAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveChainAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveChainAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveChainAssetResponse {
    return {};
  },

  toJSON(_: MsgRemoveChainAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveChainAssetResponse>): MsgRemoveChainAssetResponse {
    return MsgRemoveChainAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveChainAssetResponse>): MsgRemoveChainAssetResponse {
    const message = createBaseMsgRemoveChainAssetResponse();
    return message;
  },
};

function createBaseMsgSetChainSigners(): MsgSetChainSigners {
  return { sender: "", chainId: "", signers: [], finalizationType: 0, evfcIds: [] };
}

export const MsgSetChainSigners: MessageFns<MsgSetChainSigners> = {
  encode(message: MsgSetChainSigners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.signers) {
      Signer.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainSigners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainSigners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signers.push(Signer.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetChainSigners {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => Signer.fromJSON(e)) : [],
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgSetChainSigners): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainSigners>): MsgSetChainSigners {
    return MsgSetChainSigners.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSetChainSigners>): MsgSetChainSigners {
    const message = createBaseMsgSetChainSigners();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetChainSignersResponse(): MsgSetChainSignersResponse {
  return {};
}

export const MsgSetChainSignersResponse: MessageFns<MsgSetChainSignersResponse> = {
  encode(_: MsgSetChainSignersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainSignersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainSignersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetChainSignersResponse {
    return {};
  },

  toJSON(_: MsgSetChainSignersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainSignersResponse>): MsgSetChainSignersResponse {
    return MsgSetChainSignersResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSetChainSignersResponse>): MsgSetChainSignersResponse {
    const message = createBaseMsgSetChainSignersResponse();
    return message;
  },
};

function createBaseMsgSetChainGasParams(): MsgSetChainGasParams {
  return { sender: "", chainId: "", gasParams: undefined, finalizationType: 0, evfcIds: [] };
}

export const MsgSetChainGasParams: MessageFns<MsgSetChainGasParams> = {
  encode(message: MsgSetChainGasParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.gasParams !== undefined) {
      GasParams.encode(message.gasParams, writer.uint32(26).fork()).join();
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainGasParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainGasParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gasParams = GasParams.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetChainGasParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      gasParams: isSet(object.gasParams) ? GasParams.fromJSON(object.gasParams) : undefined,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgSetChainGasParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.gasParams !== undefined) {
      obj.gasParams = GasParams.toJSON(message.gasParams);
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainGasParams>): MsgSetChainGasParams {
    return MsgSetChainGasParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSetChainGasParams>): MsgSetChainGasParams {
    const message = createBaseMsgSetChainGasParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.gasParams = (object.gasParams !== undefined && object.gasParams !== null)
      ? GasParams.fromPartial(object.gasParams)
      : undefined;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetChainGasParamsResponse(): MsgSetChainGasParamsResponse {
  return {};
}

export const MsgSetChainGasParamsResponse: MessageFns<MsgSetChainGasParamsResponse> = {
  encode(_: MsgSetChainGasParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainGasParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainGasParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetChainGasParamsResponse {
    return {};
  },

  toJSON(_: MsgSetChainGasParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainGasParamsResponse>): MsgSetChainGasParamsResponse {
    return MsgSetChainGasParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSetChainGasParamsResponse>): MsgSetChainGasParamsResponse {
    const message = createBaseMsgSetChainGasParamsResponse();
    return message;
  },
};

function createBaseMsgSetChainConfirmationsRequired(): MsgSetChainConfirmationsRequired {
  return { sender: "", chainId: "", confirmations: Long.UZERO };
}

export const MsgSetChainConfirmationsRequired: MessageFns<MsgSetChainConfirmationsRequired> = {
  encode(message: MsgSetChainConfirmationsRequired, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.confirmations.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.confirmations.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainConfirmationsRequired {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainConfirmationsRequired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.confirmations = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetChainConfirmationsRequired {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      confirmations: isSet(object.confirmations) ? Long.fromValue(object.confirmations) : Long.UZERO,
    };
  },

  toJSON(message: MsgSetChainConfirmationsRequired): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.confirmations.equals(Long.UZERO)) {
      obj.confirmations = (message.confirmations || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainConfirmationsRequired>): MsgSetChainConfirmationsRequired {
    return MsgSetChainConfirmationsRequired.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSetChainConfirmationsRequired>): MsgSetChainConfirmationsRequired {
    const message = createBaseMsgSetChainConfirmationsRequired();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.confirmations = (object.confirmations !== undefined && object.confirmations !== null)
      ? Long.fromValue(object.confirmations)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgSetChainConfirmationsRequiredResponse(): MsgSetChainConfirmationsRequiredResponse {
  return {};
}

export const MsgSetChainConfirmationsRequiredResponse: MessageFns<MsgSetChainConfirmationsRequiredResponse> = {
  encode(_: MsgSetChainConfirmationsRequiredResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetChainConfirmationsRequiredResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetChainConfirmationsRequiredResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetChainConfirmationsRequiredResponse {
    return {};
  },

  toJSON(_: MsgSetChainConfirmationsRequiredResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetChainConfirmationsRequiredResponse>): MsgSetChainConfirmationsRequiredResponse {
    return MsgSetChainConfirmationsRequiredResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSetChainConfirmationsRequiredResponse>): MsgSetChainConfirmationsRequiredResponse {
    const message = createBaseMsgSetChainConfirmationsRequiredResponse();
    return message;
  },
};

function createBaseMsgSetUtxoChainRelayerParams(): MsgSetUtxoChainRelayerParams {
  return { sender: "", chainId: "", relayerParams: undefined };
}

export const MsgSetUtxoChainRelayerParams: MessageFns<MsgSetUtxoChainRelayerParams> = {
  encode(message: MsgSetUtxoChainRelayerParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.relayerParams !== undefined) {
      UtxoRelayerParams.encode(message.relayerParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetUtxoChainRelayerParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetUtxoChainRelayerParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relayerParams = UtxoRelayerParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetUtxoChainRelayerParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      relayerParams: isSet(object.relayerParams) ? UtxoRelayerParams.fromJSON(object.relayerParams) : undefined,
    };
  },

  toJSON(message: MsgSetUtxoChainRelayerParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.relayerParams !== undefined) {
      obj.relayerParams = UtxoRelayerParams.toJSON(message.relayerParams);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetUtxoChainRelayerParams>): MsgSetUtxoChainRelayerParams {
    return MsgSetUtxoChainRelayerParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSetUtxoChainRelayerParams>): MsgSetUtxoChainRelayerParams {
    const message = createBaseMsgSetUtxoChainRelayerParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.relayerParams = (object.relayerParams !== undefined && object.relayerParams !== null)
      ? UtxoRelayerParams.fromPartial(object.relayerParams)
      : undefined;
    return message;
  },
};

function createBaseMsgSetUtxoChainRelayerParamsResponse(): MsgSetUtxoChainRelayerParamsResponse {
  return {};
}

export const MsgSetUtxoChainRelayerParamsResponse: MessageFns<MsgSetUtxoChainRelayerParamsResponse> = {
  encode(_: MsgSetUtxoChainRelayerParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetUtxoChainRelayerParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetUtxoChainRelayerParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetUtxoChainRelayerParamsResponse {
    return {};
  },

  toJSON(_: MsgSetUtxoChainRelayerParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetUtxoChainRelayerParamsResponse>): MsgSetUtxoChainRelayerParamsResponse {
    return MsgSetUtxoChainRelayerParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSetUtxoChainRelayerParamsResponse>): MsgSetUtxoChainRelayerParamsResponse {
    const message = createBaseMsgSetUtxoChainRelayerParamsResponse();
    return message;
  },
};

function createBaseMsgPruneSmartContractChainContract(): MsgPruneSmartContractChainContract {
  return { sender: "", chainId: "", pruneBefore: Long.UZERO, finalizationType: 0, evfcIds: [] };
}

export const MsgPruneSmartContractChainContract: MessageFns<MsgPruneSmartContractChainContract> = {
  encode(message: MsgPruneSmartContractChainContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pruneBefore.toString());
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPruneSmartContractChainContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPruneSmartContractChainContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPruneSmartContractChainContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgPruneSmartContractChainContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgPruneSmartContractChainContract>): MsgPruneSmartContractChainContract {
    return MsgPruneSmartContractChainContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgPruneSmartContractChainContract>): MsgPruneSmartContractChainContract {
    const message = createBaseMsgPruneSmartContractChainContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgPruneSmartContractChainContractResponse(): MsgPruneSmartContractChainContractResponse {
  return {};
}

export const MsgPruneSmartContractChainContractResponse: MessageFns<MsgPruneSmartContractChainContractResponse> = {
  encode(_: MsgPruneSmartContractChainContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPruneSmartContractChainContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPruneSmartContractChainContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgPruneSmartContractChainContractResponse {
    return {};
  },

  toJSON(_: MsgPruneSmartContractChainContractResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgPruneSmartContractChainContractResponse>): MsgPruneSmartContractChainContractResponse {
    return MsgPruneSmartContractChainContractResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgPruneSmartContractChainContractResponse>): MsgPruneSmartContractChainContractResponse {
    const message = createBaseMsgPruneSmartContractChainContractResponse();
    return message;
  },
};

function createBaseMsgUpgradeSmartContractChainContract(): MsgUpgradeSmartContractChainContract {
  return { sender: "", chainId: "", upgradeData: undefined, finalizationType: 0, evfcIds: [] };
}

export const MsgUpgradeSmartContractChainContract: MessageFns<MsgUpgradeSmartContractChainContract> = {
  encode(message: MsgUpgradeSmartContractChainContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(26).fork()).join();
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpgradeSmartContractChainContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpgradeSmartContractChainContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpgradeSmartContractChainContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgUpgradeSmartContractChainContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpgradeSmartContractChainContract>): MsgUpgradeSmartContractChainContract {
    return MsgUpgradeSmartContractChainContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpgradeSmartContractChainContract>): MsgUpgradeSmartContractChainContract {
    const message = createBaseMsgUpgradeSmartContractChainContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpgradeSmartContractChainContractResponse(): MsgUpgradeSmartContractChainContractResponse {
  return {};
}

export const MsgUpgradeSmartContractChainContractResponse: MessageFns<MsgUpgradeSmartContractChainContractResponse> = {
  encode(_: MsgUpgradeSmartContractChainContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpgradeSmartContractChainContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpgradeSmartContractChainContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpgradeSmartContractChainContractResponse {
    return {};
  },

  toJSON(_: MsgUpgradeSmartContractChainContractResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<MsgUpgradeSmartContractChainContractResponse>,
  ): MsgUpgradeSmartContractChainContractResponse {
    return MsgUpgradeSmartContractChainContractResponse.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<MsgUpgradeSmartContractChainContractResponse>,
  ): MsgUpgradeSmartContractChainContractResponse {
    const message = createBaseMsgUpgradeSmartContractChainContractResponse();
    return message;
  },
};

function createBaseMsgSetSmartContractChainAssetsDestChainIds(): MsgSetSmartContractChainAssetsDestChainIds {
  return { sender: "", chainId: "", assets: [], finalizationType: 0, evfcIds: [] };
}

export const MsgSetSmartContractChainAssetsDestChainIds: MessageFns<MsgSetSmartContractChainAssetsDestChainIds> = {
  encode(message: MsgSetSmartContractChainAssetsDestChainIds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.assets) {
      AssetDestChainIds.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.finalizationType !== 0) {
      writer.uint32(32).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetSmartContractChainAssetsDestChainIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetSmartContractChainAssetsDestChainIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assets.push(AssetDestChainIds.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetSmartContractChainAssetsDestChainIds {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assets: globalThis.Array.isArray(object?.assets)
        ? object.assets.map((e: any) => AssetDestChainIds.fromJSON(e))
        : [],
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgSetSmartContractChainAssetsDestChainIds): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => AssetDestChainIds.toJSON(e));
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetSmartContractChainAssetsDestChainIds>): MsgSetSmartContractChainAssetsDestChainIds {
    return MsgSetSmartContractChainAssetsDestChainIds.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<MsgSetSmartContractChainAssetsDestChainIds>,
  ): MsgSetSmartContractChainAssetsDestChainIds {
    const message = createBaseMsgSetSmartContractChainAssetsDestChainIds();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assets = object.assets?.map((e) => AssetDestChainIds.fromPartial(e)) || [];
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseAssetDestChainIds(): AssetDestChainIds {
  return { assetId: undefined, destChainIds: [] };
}

export const AssetDestChainIds: MessageFns<AssetDestChainIds> = {
  encode(message: AssetDestChainIds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(10).fork()).join();
    }
    for (const v of message.destChainIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetDestChainIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetDestChainIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destChainIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetDestChainIds {
    return {
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      destChainIds: globalThis.Array.isArray(object?.destChainIds)
        ? object.destChainIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AssetDestChainIds): unknown {
    const obj: any = {};
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.destChainIds?.length) {
      obj.destChainIds = message.destChainIds;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetDestChainIds>): AssetDestChainIds {
    return AssetDestChainIds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetDestChainIds>): AssetDestChainIds {
    const message = createBaseAssetDestChainIds();
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.destChainIds = object.destChainIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetSmartContractChainAssetsDestChainIdsResponse(): MsgSetSmartContractChainAssetsDestChainIdsResponse {
  return {};
}

export const MsgSetSmartContractChainAssetsDestChainIdsResponse: MessageFns<
  MsgSetSmartContractChainAssetsDestChainIdsResponse
> = {
  encode(
    _: MsgSetSmartContractChainAssetsDestChainIdsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetSmartContractChainAssetsDestChainIdsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetSmartContractChainAssetsDestChainIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetSmartContractChainAssetsDestChainIdsResponse {
    return {};
  },

  toJSON(_: MsgSetSmartContractChainAssetsDestChainIdsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<MsgSetSmartContractChainAssetsDestChainIdsResponse>,
  ): MsgSetSmartContractChainAssetsDestChainIdsResponse {
    return MsgSetSmartContractChainAssetsDestChainIdsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<MsgSetSmartContractChainAssetsDestChainIdsResponse>,
  ): MsgSetSmartContractChainAssetsDestChainIdsResponse {
    const message = createBaseMsgSetSmartContractChainAssetsDestChainIdsResponse();
    return message;
  },
};

function createBaseMsgUpdateIbcChainParams(): MsgUpdateIbcChainParams {
  return { sender: "", chainId: "", channelId: "", portId: "", timeout: Long.UZERO };
}

export const MsgUpdateIbcChainParams: MessageFns<MsgUpdateIbcChainParams> = {
  encode(message: MsgUpdateIbcChainParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.channelId !== "") {
      writer.uint32(26).string(message.channelId);
    }
    if (message.portId !== "") {
      writer.uint32(34).string(message.portId);
    }
    if (!message.timeout.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.timeout.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIbcChainParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIbcChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.portId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timeout = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateIbcChainParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      portId: isSet(object.portId) ? globalThis.String(object.portId) : "",
      timeout: isSet(object.timeout) ? Long.fromValue(object.timeout) : Long.UZERO,
    };
  },

  toJSON(message: MsgUpdateIbcChainParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.portId !== "") {
      obj.portId = message.portId;
    }
    if (!message.timeout.equals(Long.UZERO)) {
      obj.timeout = (message.timeout || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateIbcChainParams>): MsgUpdateIbcChainParams {
    return MsgUpdateIbcChainParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateIbcChainParams>): MsgUpdateIbcChainParams {
    const message = createBaseMsgUpdateIbcChainParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.channelId = object.channelId ?? "";
    message.portId = object.portId ?? "";
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Long.fromValue(object.timeout)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgUpdateIbcChainParamsResponse(): MsgUpdateIbcChainParamsResponse {
  return {};
}

export const MsgUpdateIbcChainParamsResponse: MessageFns<MsgUpdateIbcChainParamsResponse> = {
  encode(_: MsgUpdateIbcChainParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIbcChainParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIbcChainParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateIbcChainParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateIbcChainParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateIbcChainParamsResponse>): MsgUpdateIbcChainParamsResponse {
    return MsgUpdateIbcChainParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateIbcChainParamsResponse>): MsgUpdateIbcChainParamsResponse {
    const message = createBaseMsgUpdateIbcChainParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateIbcChainAssetParams(): MsgUpdateIbcChainAssetParams {
  return { sender: "", chainId: "", assetId: undefined, localIbcDenom: "", externalIbcDenom: "", swap: undefined };
}

export const MsgUpdateIbcChainAssetParams: MessageFns<MsgUpdateIbcChainAssetParams> = {
  encode(message: MsgUpdateIbcChainAssetParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.localIbcDenom !== "") {
      writer.uint32(34).string(message.localIbcDenom);
    }
    if (message.externalIbcDenom !== "") {
      writer.uint32(42).string(message.externalIbcDenom);
    }
    if (message.swap !== undefined) {
      IbcAssetSwap.encode(message.swap, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIbcChainAssetParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIbcChainAssetParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.localIbcDenom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalIbcDenom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.swap = IbcAssetSwap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateIbcChainAssetParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      localIbcDenom: isSet(object.localIbcDenom) ? globalThis.String(object.localIbcDenom) : "",
      externalIbcDenom: isSet(object.externalIbcDenom) ? globalThis.String(object.externalIbcDenom) : "",
      swap: isSet(object.swap) ? IbcAssetSwap.fromJSON(object.swap) : undefined,
    };
  },

  toJSON(message: MsgUpdateIbcChainAssetParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.localIbcDenom !== "") {
      obj.localIbcDenom = message.localIbcDenom;
    }
    if (message.externalIbcDenom !== "") {
      obj.externalIbcDenom = message.externalIbcDenom;
    }
    if (message.swap !== undefined) {
      obj.swap = IbcAssetSwap.toJSON(message.swap);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateIbcChainAssetParams>): MsgUpdateIbcChainAssetParams {
    return MsgUpdateIbcChainAssetParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateIbcChainAssetParams>): MsgUpdateIbcChainAssetParams {
    const message = createBaseMsgUpdateIbcChainAssetParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.localIbcDenom = object.localIbcDenom ?? "";
    message.externalIbcDenom = object.externalIbcDenom ?? "";
    message.swap = (object.swap !== undefined && object.swap !== null)
      ? IbcAssetSwap.fromPartial(object.swap)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateIbcChainAssetParamsResponse(): MsgUpdateIbcChainAssetParamsResponse {
  return {};
}

export const MsgUpdateIbcChainAssetParamsResponse: MessageFns<MsgUpdateIbcChainAssetParamsResponse> = {
  encode(_: MsgUpdateIbcChainAssetParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIbcChainAssetParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIbcChainAssetParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateIbcChainAssetParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateIbcChainAssetParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateIbcChainAssetParamsResponse>): MsgUpdateIbcChainAssetParamsResponse {
    return MsgUpdateIbcChainAssetParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateIbcChainAssetParamsResponse>): MsgUpdateIbcChainAssetParamsResponse {
    const message = createBaseMsgUpdateIbcChainAssetParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateNttChainParams(): MsgUpdateNttChainParams {
  return { sender: "", chainId: "", wormholeProgram: "", nttChainId: Long.UZERO, finalizationType: 0, evfcIds: [] };
}

export const MsgUpdateNttChainParams: MessageFns<MsgUpdateNttChainParams> = {
  encode(message: MsgUpdateNttChainParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.wormholeProgram !== "") {
      writer.uint32(26).string(message.wormholeProgram);
    }
    if (!message.nttChainId.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.nttChainId.toString());
    }
    if (message.finalizationType !== 0) {
      writer.uint32(40).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateNttChainParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateNttChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wormholeProgram = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nttChainId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateNttChainParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      wormholeProgram: isSet(object.wormholeProgram) ? globalThis.String(object.wormholeProgram) : "",
      nttChainId: isSet(object.nttChainId) ? Long.fromValue(object.nttChainId) : Long.UZERO,
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgUpdateNttChainParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.wormholeProgram !== "") {
      obj.wormholeProgram = message.wormholeProgram;
    }
    if (!message.nttChainId.equals(Long.UZERO)) {
      obj.nttChainId = (message.nttChainId || Long.UZERO).toString();
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateNttChainParams>): MsgUpdateNttChainParams {
    return MsgUpdateNttChainParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateNttChainParams>): MsgUpdateNttChainParams {
    const message = createBaseMsgUpdateNttChainParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.wormholeProgram = object.wormholeProgram ?? "";
    message.nttChainId = (object.nttChainId !== undefined && object.nttChainId !== null)
      ? Long.fromValue(object.nttChainId)
      : Long.UZERO;
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateNttChainParamsResponse(): MsgUpdateNttChainParamsResponse {
  return {};
}

export const MsgUpdateNttChainParamsResponse: MessageFns<MsgUpdateNttChainParamsResponse> = {
  encode(_: MsgUpdateNttChainParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateNttChainParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateNttChainParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateNttChainParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateNttChainParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateNttChainParamsResponse>): MsgUpdateNttChainParamsResponse {
    return MsgUpdateNttChainParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateNttChainParamsResponse>): MsgUpdateNttChainParamsResponse {
    const message = createBaseMsgUpdateNttChainParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateNttChainAssetAddresses(): MsgUpdateNttChainAssetAddresses {
  return {
    sender: "",
    chainId: "",
    assetId: undefined,
    nttManagerAddress: "",
    externalNttManagerAddress: "",
    externalTokenAddress: "",
    finalizationType: 0,
    evfcIds: [],
    nttTransceivers: [],
    externalNttTransceivers: [],
  };
}

export const MsgUpdateNttChainAssetAddresses: MessageFns<MsgUpdateNttChainAssetAddresses> = {
  encode(message: MsgUpdateNttChainAssetAddresses, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.nttManagerAddress !== "") {
      writer.uint32(34).string(message.nttManagerAddress);
    }
    if (message.externalNttManagerAddress !== "") {
      writer.uint32(42).string(message.externalNttManagerAddress);
    }
    if (message.externalTokenAddress !== "") {
      writer.uint32(50).string(message.externalTokenAddress);
    }
    if (message.finalizationType !== 0) {
      writer.uint32(56).int32(message.finalizationType);
    }
    for (const v of message.evfcIds) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.nttTransceivers) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.externalNttTransceivers) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateNttChainAssetAddresses {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateNttChainAssetAddresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nttManagerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalNttManagerAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalTokenAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.finalizationType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.evfcIds.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.nttTransceivers.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.externalNttTransceivers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateNttChainAssetAddresses {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      nttManagerAddress: isSet(object.nttManagerAddress) ? globalThis.String(object.nttManagerAddress) : "",
      externalNttManagerAddress: isSet(object.externalNttManagerAddress)
        ? globalThis.String(object.externalNttManagerAddress)
        : "",
      externalTokenAddress: isSet(object.externalTokenAddress) ? globalThis.String(object.externalTokenAddress) : "",
      finalizationType: isSet(object.finalizationType) ? proposalFinalizationTypeFromJSON(object.finalizationType) : 0,
      evfcIds: globalThis.Array.isArray(object?.evfcIds) ? object.evfcIds.map((e: any) => globalThis.String(e)) : [],
      nttTransceivers: globalThis.Array.isArray(object?.nttTransceivers)
        ? object.nttTransceivers.map((e: any) => globalThis.String(e))
        : [],
      externalNttTransceivers: globalThis.Array.isArray(object?.externalNttTransceivers)
        ? object.externalNttTransceivers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateNttChainAssetAddresses): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.nttManagerAddress !== "") {
      obj.nttManagerAddress = message.nttManagerAddress;
    }
    if (message.externalNttManagerAddress !== "") {
      obj.externalNttManagerAddress = message.externalNttManagerAddress;
    }
    if (message.externalTokenAddress !== "") {
      obj.externalTokenAddress = message.externalTokenAddress;
    }
    if (message.finalizationType !== 0) {
      obj.finalizationType = proposalFinalizationTypeToJSON(message.finalizationType);
    }
    if (message.evfcIds?.length) {
      obj.evfcIds = message.evfcIds;
    }
    if (message.nttTransceivers?.length) {
      obj.nttTransceivers = message.nttTransceivers;
    }
    if (message.externalNttTransceivers?.length) {
      obj.externalNttTransceivers = message.externalNttTransceivers;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateNttChainAssetAddresses>): MsgUpdateNttChainAssetAddresses {
    return MsgUpdateNttChainAssetAddresses.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateNttChainAssetAddresses>): MsgUpdateNttChainAssetAddresses {
    const message = createBaseMsgUpdateNttChainAssetAddresses();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.nttManagerAddress = object.nttManagerAddress ?? "";
    message.externalNttManagerAddress = object.externalNttManagerAddress ?? "";
    message.externalTokenAddress = object.externalTokenAddress ?? "";
    message.finalizationType = object.finalizationType ?? 0;
    message.evfcIds = object.evfcIds?.map((e) => e) || [];
    message.nttTransceivers = object.nttTransceivers?.map((e) => e) || [];
    message.externalNttTransceivers = object.externalNttTransceivers?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateNttChainAssetAddressesResponse(): MsgUpdateNttChainAssetAddressesResponse {
  return {};
}

export const MsgUpdateNttChainAssetAddressesResponse: MessageFns<MsgUpdateNttChainAssetAddressesResponse> = {
  encode(_: MsgUpdateNttChainAssetAddressesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateNttChainAssetAddressesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateNttChainAssetAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateNttChainAssetAddressesResponse {
    return {};
  },

  toJSON(_: MsgUpdateNttChainAssetAddressesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateNttChainAssetAddressesResponse>): MsgUpdateNttChainAssetAddressesResponse {
    return MsgUpdateNttChainAssetAddressesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateNttChainAssetAddressesResponse>): MsgUpdateNttChainAssetAddressesResponse {
    const message = createBaseMsgUpdateNttChainAssetAddressesResponse();
    return message;
  },
};

function createBaseMsgSubmitProposalResult(): MsgSubmitProposalResult {
  return { sender: "", proposalId: Long.UZERO, chainId: "", result: 0, broadcastedTxHash: "" };
}

export const MsgSubmitProposalResult: MessageFns<MsgSubmitProposalResult> = {
  encode(message: MsgSubmitProposalResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.proposalId.toString());
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.result !== 0) {
      writer.uint32(32).int32(message.result);
    }
    if (message.broadcastedTxHash !== "") {
      writer.uint32(42).string(message.broadcastedTxHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitProposalResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitProposalResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.proposalId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.broadcastedTxHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitProposalResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      proposalId: isSet(object.proposalId) ? Long.fromValue(object.proposalId) : Long.UZERO,
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      result: isSet(object.result) ? proposalResultFromJSON(object.result) : 0,
      broadcastedTxHash: isSet(object.broadcastedTxHash) ? globalThis.String(object.broadcastedTxHash) : "",
    };
  },

  toJSON(message: MsgSubmitProposalResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      obj.proposalId = (message.proposalId || Long.UZERO).toString();
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.result !== 0) {
      obj.result = proposalResultToJSON(message.result);
    }
    if (message.broadcastedTxHash !== "") {
      obj.broadcastedTxHash = message.broadcastedTxHash;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitProposalResult>): MsgSubmitProposalResult {
    return MsgSubmitProposalResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgSubmitProposalResult>): MsgSubmitProposalResult {
    const message = createBaseMsgSubmitProposalResult();
    message.sender = object.sender ?? "";
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.UZERO;
    message.chainId = object.chainId ?? "";
    message.result = object.result ?? 0;
    message.broadcastedTxHash = object.broadcastedTxHash ?? "";
    return message;
  },
};

function createBaseMsgSubmitProposalResultResponse(): MsgSubmitProposalResultResponse {
  return {};
}

export const MsgSubmitProposalResultResponse: MessageFns<MsgSubmitProposalResultResponse> = {
  encode(_: MsgSubmitProposalResultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitProposalResultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitProposalResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitProposalResultResponse {
    return {};
  },

  toJSON(_: MsgSubmitProposalResultResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubmitProposalResultResponse>): MsgSubmitProposalResultResponse {
    return MsgSubmitProposalResultResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgSubmitProposalResultResponse>): MsgSubmitProposalResultResponse {
    const message = createBaseMsgSubmitProposalResultResponse();
    return message;
  },
};

function createBaseMsgResolveQuarantinedTransfers(): MsgResolveQuarantinedTransfers {
  return { sender: "", resolves: [] };
}

export const MsgResolveQuarantinedTransfers: MessageFns<MsgResolveQuarantinedTransfers> = {
  encode(message: MsgResolveQuarantinedTransfers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.resolves) {
      QuarantineResolves.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResolveQuarantinedTransfers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResolveQuarantinedTransfers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resolves.push(QuarantineResolves.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgResolveQuarantinedTransfers {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      resolves: globalThis.Array.isArray(object?.resolves)
        ? object.resolves.map((e: any) => QuarantineResolves.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgResolveQuarantinedTransfers): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.resolves?.length) {
      obj.resolves = message.resolves.map((e) => QuarantineResolves.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgResolveQuarantinedTransfers>): MsgResolveQuarantinedTransfers {
    return MsgResolveQuarantinedTransfers.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgResolveQuarantinedTransfers>): MsgResolveQuarantinedTransfers {
    const message = createBaseMsgResolveQuarantinedTransfers();
    message.sender = object.sender ?? "";
    message.resolves = object.resolves?.map((e) => QuarantineResolves.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgResolveQuarantinedTransfersResponse(): MsgResolveQuarantinedTransfersResponse {
  return {};
}

export const MsgResolveQuarantinedTransfersResponse: MessageFns<MsgResolveQuarantinedTransfersResponse> = {
  encode(_: MsgResolveQuarantinedTransfersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResolveQuarantinedTransfersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResolveQuarantinedTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgResolveQuarantinedTransfersResponse {
    return {};
  },

  toJSON(_: MsgResolveQuarantinedTransfersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgResolveQuarantinedTransfersResponse>): MsgResolveQuarantinedTransfersResponse {
    return MsgResolveQuarantinedTransfersResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgResolveQuarantinedTransfersResponse>): MsgResolveQuarantinedTransfersResponse {
    const message = createBaseMsgResolveQuarantinedTransfersResponse();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
