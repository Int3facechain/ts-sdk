// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: int3face/bridge/v1beta1/bridge.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../../google/protobuf/any";
import {
  QuarantinedEntityType,
  quarantinedEntityTypeFromJSON,
  quarantinedEntityTypeToJSON,
  QuarantineVotingResult,
  quarantineVotingResultFromJSON,
  quarantineVotingResultToJSON,
} from "../../quarantine/quarantine";

export const protobufPackage = "int3face.bridge.v1beta1";

export enum BridgeStatus {
  BRIDGE_STATUS_UNSPECIFIED = 0,
  BRIDGE_STATUS_OK = 1,
  BRIDGE_STATUS_BLOCKED = 2,
  UNRECOGNIZED = -1,
}

export function bridgeStatusFromJSON(object: any): BridgeStatus {
  switch (object) {
    case 0:
    case "BRIDGE_STATUS_UNSPECIFIED":
      return BridgeStatus.BRIDGE_STATUS_UNSPECIFIED;
    case 1:
    case "BRIDGE_STATUS_OK":
      return BridgeStatus.BRIDGE_STATUS_OK;
    case 2:
    case "BRIDGE_STATUS_BLOCKED":
      return BridgeStatus.BRIDGE_STATUS_BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BridgeStatus.UNRECOGNIZED;
  }
}

export function bridgeStatusToJSON(object: BridgeStatus): string {
  switch (object) {
    case BridgeStatus.BRIDGE_STATUS_UNSPECIFIED:
      return "BRIDGE_STATUS_UNSPECIFIED";
    case BridgeStatus.BRIDGE_STATUS_OK:
      return "BRIDGE_STATUS_OK";
    case BridgeStatus.BRIDGE_STATUS_BLOCKED:
      return "BRIDGE_STATUS_BLOCKED";
    case BridgeStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AssetStatus {
  ASSET_STATUS_UNSPECIFIED = 0,
  ASSET_STATUS_OK = 1,
  ASSET_STATUS_BLOCKED = 5,
  UNRECOGNIZED = -1,
}

export function assetStatusFromJSON(object: any): AssetStatus {
  switch (object) {
    case 0:
    case "ASSET_STATUS_UNSPECIFIED":
      return AssetStatus.ASSET_STATUS_UNSPECIFIED;
    case 1:
    case "ASSET_STATUS_OK":
      return AssetStatus.ASSET_STATUS_OK;
    case 5:
    case "ASSET_STATUS_BLOCKED":
      return AssetStatus.ASSET_STATUS_BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetStatus.UNRECOGNIZED;
  }
}

export function assetStatusToJSON(object: AssetStatus): string {
  switch (object) {
    case AssetStatus.ASSET_STATUS_UNSPECIFIED:
      return "ASSET_STATUS_UNSPECIFIED";
    case AssetStatus.ASSET_STATUS_OK:
      return "ASSET_STATUS_OK";
    case AssetStatus.ASSET_STATUS_BLOCKED:
      return "ASSET_STATUS_BLOCKED";
    case AssetStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChainAssetStatus {
  CHAIN_ASSET_STATUS_UNSPECIFIED = 0,
  CHAIN_ASSET_STATUS_OK = 1,
  CHAIN_ASSET_STATUS_BLOCKED_INBOUND = 2,
  CHAIN_ASSET_STATUS_BLOCKED_OUTBOUND = 3,
  CHAIN_ASSET_STATUS_BLOCKED_BOTH = 4,
  UNRECOGNIZED = -1,
}

export function chainAssetStatusFromJSON(object: any): ChainAssetStatus {
  switch (object) {
    case 0:
    case "CHAIN_ASSET_STATUS_UNSPECIFIED":
      return ChainAssetStatus.CHAIN_ASSET_STATUS_UNSPECIFIED;
    case 1:
    case "CHAIN_ASSET_STATUS_OK":
      return ChainAssetStatus.CHAIN_ASSET_STATUS_OK;
    case 2:
    case "CHAIN_ASSET_STATUS_BLOCKED_INBOUND":
      return ChainAssetStatus.CHAIN_ASSET_STATUS_BLOCKED_INBOUND;
    case 3:
    case "CHAIN_ASSET_STATUS_BLOCKED_OUTBOUND":
      return ChainAssetStatus.CHAIN_ASSET_STATUS_BLOCKED_OUTBOUND;
    case 4:
    case "CHAIN_ASSET_STATUS_BLOCKED_BOTH":
      return ChainAssetStatus.CHAIN_ASSET_STATUS_BLOCKED_BOTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChainAssetStatus.UNRECOGNIZED;
  }
}

export function chainAssetStatusToJSON(object: ChainAssetStatus): string {
  switch (object) {
    case ChainAssetStatus.CHAIN_ASSET_STATUS_UNSPECIFIED:
      return "CHAIN_ASSET_STATUS_UNSPECIFIED";
    case ChainAssetStatus.CHAIN_ASSET_STATUS_OK:
      return "CHAIN_ASSET_STATUS_OK";
    case ChainAssetStatus.CHAIN_ASSET_STATUS_BLOCKED_INBOUND:
      return "CHAIN_ASSET_STATUS_BLOCKED_INBOUND";
    case ChainAssetStatus.CHAIN_ASSET_STATUS_BLOCKED_OUTBOUND:
      return "CHAIN_ASSET_STATUS_BLOCKED_OUTBOUND";
    case ChainAssetStatus.CHAIN_ASSET_STATUS_BLOCKED_BOTH:
      return "CHAIN_ASSET_STATUS_BLOCKED_BOTH";
    case ChainAssetStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChainStatus {
  CHAIN_STATUS_UNSPECIFIED = 0,
  CHAIN_STATUS_OK = 1,
  CHAIN_STATUS_BLOCKED = 2,
  UNRECOGNIZED = -1,
}

export function chainStatusFromJSON(object: any): ChainStatus {
  switch (object) {
    case 0:
    case "CHAIN_STATUS_UNSPECIFIED":
      return ChainStatus.CHAIN_STATUS_UNSPECIFIED;
    case 1:
    case "CHAIN_STATUS_OK":
      return ChainStatus.CHAIN_STATUS_OK;
    case 2:
    case "CHAIN_STATUS_BLOCKED":
      return ChainStatus.CHAIN_STATUS_BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChainStatus.UNRECOGNIZED;
  }
}

export function chainStatusToJSON(object: ChainStatus): string {
  switch (object) {
    case ChainStatus.CHAIN_STATUS_UNSPECIFIED:
      return "CHAIN_STATUS_UNSPECIFIED";
    case ChainStatus.CHAIN_STATUS_OK:
      return "CHAIN_STATUS_OK";
    case ChainStatus.CHAIN_STATUS_BLOCKED:
      return "CHAIN_STATUS_BLOCKED";
    case ChainStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ContractStatus {
  CONTRACT_STATUS_UNSPECIFIED = 0,
  CONTRACT_STATUS_OK = 1,
  CONTRACT_STATUS_BLOCKED_INBOUND = 2,
  CONTRACT_STATUS_BLOCKED_OUTBOUND = 3,
  CONTRACT_STATUS_BLOCKED_BOTH = 4,
  UNRECOGNIZED = -1,
}

export function contractStatusFromJSON(object: any): ContractStatus {
  switch (object) {
    case 0:
    case "CONTRACT_STATUS_UNSPECIFIED":
      return ContractStatus.CONTRACT_STATUS_UNSPECIFIED;
    case 1:
    case "CONTRACT_STATUS_OK":
      return ContractStatus.CONTRACT_STATUS_OK;
    case 2:
    case "CONTRACT_STATUS_BLOCKED_INBOUND":
      return ContractStatus.CONTRACT_STATUS_BLOCKED_INBOUND;
    case 3:
    case "CONTRACT_STATUS_BLOCKED_OUTBOUND":
      return ContractStatus.CONTRACT_STATUS_BLOCKED_OUTBOUND;
    case 4:
    case "CONTRACT_STATUS_BLOCKED_BOTH":
      return ContractStatus.CONTRACT_STATUS_BLOCKED_BOTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContractStatus.UNRECOGNIZED;
  }
}

export function contractStatusToJSON(object: ContractStatus): string {
  switch (object) {
    case ContractStatus.CONTRACT_STATUS_UNSPECIFIED:
      return "CONTRACT_STATUS_UNSPECIFIED";
    case ContractStatus.CONTRACT_STATUS_OK:
      return "CONTRACT_STATUS_OK";
    case ContractStatus.CONTRACT_STATUS_BLOCKED_INBOUND:
      return "CONTRACT_STATUS_BLOCKED_INBOUND";
    case ContractStatus.CONTRACT_STATUS_BLOCKED_OUTBOUND:
      return "CONTRACT_STATUS_BLOCKED_OUTBOUND";
    case ContractStatus.CONTRACT_STATUS_BLOCKED_BOTH:
      return "CONTRACT_STATUS_BLOCKED_BOTH";
    case ContractStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OutboundTransferStatus {
  PROCESSING = 0,
  FINALIZED = 1,
  FAILED = 2,
  UNRECOGNIZED = -1,
}

export function outboundTransferStatusFromJSON(object: any): OutboundTransferStatus {
  switch (object) {
    case 0:
    case "PROCESSING":
      return OutboundTransferStatus.PROCESSING;
    case 1:
    case "FINALIZED":
      return OutboundTransferStatus.FINALIZED;
    case 2:
    case "FAILED":
      return OutboundTransferStatus.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OutboundTransferStatus.UNRECOGNIZED;
  }
}

export function outboundTransferStatusToJSON(object: OutboundTransferStatus): string {
  switch (object) {
    case OutboundTransferStatus.PROCESSING:
      return "PROCESSING";
    case OutboundTransferStatus.FINALIZED:
      return "FINALIZED";
    case OutboundTransferStatus.FAILED:
      return "FAILED";
    case OutboundTransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransferProtocol {
  IBC = 0,
  BITFROST = 1,
  UNRECOGNIZED = -1,
}

export function transferProtocolFromJSON(object: any): TransferProtocol {
  switch (object) {
    case 0:
    case "IBC":
      return TransferProtocol.IBC;
    case 1:
    case "BITFROST":
      return TransferProtocol.BITFROST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferProtocol.UNRECOGNIZED;
  }
}

export function transferProtocolToJSON(object: TransferProtocol): string {
  switch (object) {
    case TransferProtocol.IBC:
      return "IBC";
    case TransferProtocol.BITFROST:
      return "BITFROST";
    case TransferProtocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IntegrationProtocol {
  INTEGRATION_PROTOCOL_UNSPECIFIED = 0,
  INTEGRATION_PROTOCOL_INTERNAL = 1,
  INTEGRATION_PROTOCOL_BITFROST = 2,
  INTEGRATION_PROTOCOL_IBC = 3,
  UNRECOGNIZED = -1,
}

export function integrationProtocolFromJSON(object: any): IntegrationProtocol {
  switch (object) {
    case 0:
    case "INTEGRATION_PROTOCOL_UNSPECIFIED":
      return IntegrationProtocol.INTEGRATION_PROTOCOL_UNSPECIFIED;
    case 1:
    case "INTEGRATION_PROTOCOL_INTERNAL":
      return IntegrationProtocol.INTEGRATION_PROTOCOL_INTERNAL;
    case 2:
    case "INTEGRATION_PROTOCOL_BITFROST":
      return IntegrationProtocol.INTEGRATION_PROTOCOL_BITFROST;
    case 3:
    case "INTEGRATION_PROTOCOL_IBC":
      return IntegrationProtocol.INTEGRATION_PROTOCOL_IBC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IntegrationProtocol.UNRECOGNIZED;
  }
}

export function integrationProtocolToJSON(object: IntegrationProtocol): string {
  switch (object) {
    case IntegrationProtocol.INTEGRATION_PROTOCOL_UNSPECIFIED:
      return "INTEGRATION_PROTOCOL_UNSPECIFIED";
    case IntegrationProtocol.INTEGRATION_PROTOCOL_INTERNAL:
      return "INTEGRATION_PROTOCOL_INTERNAL";
    case IntegrationProtocol.INTEGRATION_PROTOCOL_BITFROST:
      return "INTEGRATION_PROTOCOL_BITFROST";
    case IntegrationProtocol.INTEGRATION_PROTOCOL_IBC:
      return "INTEGRATION_PROTOCOL_IBC";
    case IntegrationProtocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChainType {
  CHAIN_TYPE_UNSPECIFIED = 0,
  CHAIN_TYPE_INT3FACE = 1,
  CHAIN_TYPE_UTXO = 2,
  CHAIN_TYPE_IBC = 3,
  CHAIN_TYPE_TON = 4,
  CHAIN_TYPE_SOLANA = 5,
  CHAIN_TYPE_EVM = 6,
  CHAIN_TYPE_NTT_EVM = 7,
  CHAIN_TYPE_PAYMENT = 8,
  UNRECOGNIZED = -1,
}

export function chainTypeFromJSON(object: any): ChainType {
  switch (object) {
    case 0:
    case "CHAIN_TYPE_UNSPECIFIED":
      return ChainType.CHAIN_TYPE_UNSPECIFIED;
    case 1:
    case "CHAIN_TYPE_INT3FACE":
      return ChainType.CHAIN_TYPE_INT3FACE;
    case 2:
    case "CHAIN_TYPE_UTXO":
      return ChainType.CHAIN_TYPE_UTXO;
    case 3:
    case "CHAIN_TYPE_IBC":
      return ChainType.CHAIN_TYPE_IBC;
    case 4:
    case "CHAIN_TYPE_TON":
      return ChainType.CHAIN_TYPE_TON;
    case 5:
    case "CHAIN_TYPE_SOLANA":
      return ChainType.CHAIN_TYPE_SOLANA;
    case 6:
    case "CHAIN_TYPE_EVM":
      return ChainType.CHAIN_TYPE_EVM;
    case 7:
    case "CHAIN_TYPE_NTT_EVM":
      return ChainType.CHAIN_TYPE_NTT_EVM;
    case 8:
    case "CHAIN_TYPE_PAYMENT":
      return ChainType.CHAIN_TYPE_PAYMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChainType.UNRECOGNIZED;
  }
}

export function chainTypeToJSON(object: ChainType): string {
  switch (object) {
    case ChainType.CHAIN_TYPE_UNSPECIFIED:
      return "CHAIN_TYPE_UNSPECIFIED";
    case ChainType.CHAIN_TYPE_INT3FACE:
      return "CHAIN_TYPE_INT3FACE";
    case ChainType.CHAIN_TYPE_UTXO:
      return "CHAIN_TYPE_UTXO";
    case ChainType.CHAIN_TYPE_IBC:
      return "CHAIN_TYPE_IBC";
    case ChainType.CHAIN_TYPE_TON:
      return "CHAIN_TYPE_TON";
    case ChainType.CHAIN_TYPE_SOLANA:
      return "CHAIN_TYPE_SOLANA";
    case ChainType.CHAIN_TYPE_EVM:
      return "CHAIN_TYPE_EVM";
    case ChainType.CHAIN_TYPE_NTT_EVM:
      return "CHAIN_TYPE_NTT_EVM";
    case ChainType.CHAIN_TYPE_PAYMENT:
      return "CHAIN_TYPE_PAYMENT";
    case ChainType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GasFeeType {
  GAS_FEE_TYPE_UNSPECIFIED = 0,
  GAS_FEE_TYPE_WITHDRAW_NATIVE_TOKEN = 1,
  GAS_FEE_TYPE_WITHDRAW_NON_NATIVE_TOKEN = 2,
  GAS_FEE_TYPE_DEPOSIT_NATIVE_TOKEN = 3,
  GAS_FEE_TYPE_DEPOSIT_NON_NATIVE_TOKEN = 4,
  GAS_FEE_TYPE_TSS_KEYGEN = 5,
  GAS_FEE_TYPE_CONTRACT_UPGRADE = 6,
  GAS_FEE_TYPE_CONTRACT_PRUNE = 7,
  GAS_FEE_TYPE_CONTRACT_ASSET_ADD = 8,
  GAS_FEE_TYPE_CONTRACT_ASSET_DELETE = 9,
  GAS_FEE_TYPE_CONTRACT_ASSET_WHITELIST = 10,
  GAS_FEE_TYPE_CONTRACT_ASSET_UNWHITELIST = 11,
  GAS_FEE_TYPE_CONTRACT_SIGNERS_UPDATE = 12,
  GAS_FEE_TYPE_CONTRACT_PARAMS_UPDATE = 13,
  GAS_FEE_TYPE_CONTRACT_STATUS_UPDATE = 14,
  GAS_FEE_TYPE_CONTRACT_STORAGE = 15,
  UNRECOGNIZED = -1,
}

export function gasFeeTypeFromJSON(object: any): GasFeeType {
  switch (object) {
    case 0:
    case "GAS_FEE_TYPE_UNSPECIFIED":
      return GasFeeType.GAS_FEE_TYPE_UNSPECIFIED;
    case 1:
    case "GAS_FEE_TYPE_WITHDRAW_NATIVE_TOKEN":
      return GasFeeType.GAS_FEE_TYPE_WITHDRAW_NATIVE_TOKEN;
    case 2:
    case "GAS_FEE_TYPE_WITHDRAW_NON_NATIVE_TOKEN":
      return GasFeeType.GAS_FEE_TYPE_WITHDRAW_NON_NATIVE_TOKEN;
    case 3:
    case "GAS_FEE_TYPE_DEPOSIT_NATIVE_TOKEN":
      return GasFeeType.GAS_FEE_TYPE_DEPOSIT_NATIVE_TOKEN;
    case 4:
    case "GAS_FEE_TYPE_DEPOSIT_NON_NATIVE_TOKEN":
      return GasFeeType.GAS_FEE_TYPE_DEPOSIT_NON_NATIVE_TOKEN;
    case 5:
    case "GAS_FEE_TYPE_TSS_KEYGEN":
      return GasFeeType.GAS_FEE_TYPE_TSS_KEYGEN;
    case 6:
    case "GAS_FEE_TYPE_CONTRACT_UPGRADE":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_UPGRADE;
    case 7:
    case "GAS_FEE_TYPE_CONTRACT_PRUNE":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_PRUNE;
    case 8:
    case "GAS_FEE_TYPE_CONTRACT_ASSET_ADD":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_ADD;
    case 9:
    case "GAS_FEE_TYPE_CONTRACT_ASSET_DELETE":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_DELETE;
    case 10:
    case "GAS_FEE_TYPE_CONTRACT_ASSET_WHITELIST":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_WHITELIST;
    case 11:
    case "GAS_FEE_TYPE_CONTRACT_ASSET_UNWHITELIST":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_UNWHITELIST;
    case 12:
    case "GAS_FEE_TYPE_CONTRACT_SIGNERS_UPDATE":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_SIGNERS_UPDATE;
    case 13:
    case "GAS_FEE_TYPE_CONTRACT_PARAMS_UPDATE":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_PARAMS_UPDATE;
    case 14:
    case "GAS_FEE_TYPE_CONTRACT_STATUS_UPDATE":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_STATUS_UPDATE;
    case 15:
    case "GAS_FEE_TYPE_CONTRACT_STORAGE":
      return GasFeeType.GAS_FEE_TYPE_CONTRACT_STORAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GasFeeType.UNRECOGNIZED;
  }
}

export function gasFeeTypeToJSON(object: GasFeeType): string {
  switch (object) {
    case GasFeeType.GAS_FEE_TYPE_UNSPECIFIED:
      return "GAS_FEE_TYPE_UNSPECIFIED";
    case GasFeeType.GAS_FEE_TYPE_WITHDRAW_NATIVE_TOKEN:
      return "GAS_FEE_TYPE_WITHDRAW_NATIVE_TOKEN";
    case GasFeeType.GAS_FEE_TYPE_WITHDRAW_NON_NATIVE_TOKEN:
      return "GAS_FEE_TYPE_WITHDRAW_NON_NATIVE_TOKEN";
    case GasFeeType.GAS_FEE_TYPE_DEPOSIT_NATIVE_TOKEN:
      return "GAS_FEE_TYPE_DEPOSIT_NATIVE_TOKEN";
    case GasFeeType.GAS_FEE_TYPE_DEPOSIT_NON_NATIVE_TOKEN:
      return "GAS_FEE_TYPE_DEPOSIT_NON_NATIVE_TOKEN";
    case GasFeeType.GAS_FEE_TYPE_TSS_KEYGEN:
      return "GAS_FEE_TYPE_TSS_KEYGEN";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_UPGRADE:
      return "GAS_FEE_TYPE_CONTRACT_UPGRADE";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_PRUNE:
      return "GAS_FEE_TYPE_CONTRACT_PRUNE";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_ADD:
      return "GAS_FEE_TYPE_CONTRACT_ASSET_ADD";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_DELETE:
      return "GAS_FEE_TYPE_CONTRACT_ASSET_DELETE";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_WHITELIST:
      return "GAS_FEE_TYPE_CONTRACT_ASSET_WHITELIST";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_ASSET_UNWHITELIST:
      return "GAS_FEE_TYPE_CONTRACT_ASSET_UNWHITELIST";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_SIGNERS_UPDATE:
      return "GAS_FEE_TYPE_CONTRACT_SIGNERS_UPDATE";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_PARAMS_UPDATE:
      return "GAS_FEE_TYPE_CONTRACT_PARAMS_UPDATE";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_STATUS_UPDATE:
      return "GAS_FEE_TYPE_CONTRACT_STATUS_UPDATE";
    case GasFeeType.GAS_FEE_TYPE_CONTRACT_STORAGE:
      return "GAS_FEE_TYPE_CONTRACT_STORAGE";
    case GasFeeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChainNetworkMode {
  CHAIN_NETWORK_MODE_UNSPECIFIED = 0,
  CHAIN_NETWORK_MODE_MAINNET = 1,
  CHAIN_NETWORK_MODE_TESTNET = 2,
  CHAIN_NETWORK_MODE_DEVNET = 3,
  CHAIN_NETWORK_MODE_REGTEST = 4,
  UNRECOGNIZED = -1,
}

export function chainNetworkModeFromJSON(object: any): ChainNetworkMode {
  switch (object) {
    case 0:
    case "CHAIN_NETWORK_MODE_UNSPECIFIED":
      return ChainNetworkMode.CHAIN_NETWORK_MODE_UNSPECIFIED;
    case 1:
    case "CHAIN_NETWORK_MODE_MAINNET":
      return ChainNetworkMode.CHAIN_NETWORK_MODE_MAINNET;
    case 2:
    case "CHAIN_NETWORK_MODE_TESTNET":
      return ChainNetworkMode.CHAIN_NETWORK_MODE_TESTNET;
    case 3:
    case "CHAIN_NETWORK_MODE_DEVNET":
      return ChainNetworkMode.CHAIN_NETWORK_MODE_DEVNET;
    case 4:
    case "CHAIN_NETWORK_MODE_REGTEST":
      return ChainNetworkMode.CHAIN_NETWORK_MODE_REGTEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChainNetworkMode.UNRECOGNIZED;
  }
}

export function chainNetworkModeToJSON(object: ChainNetworkMode): string {
  switch (object) {
    case ChainNetworkMode.CHAIN_NETWORK_MODE_UNSPECIFIED:
      return "CHAIN_NETWORK_MODE_UNSPECIFIED";
    case ChainNetworkMode.CHAIN_NETWORK_MODE_MAINNET:
      return "CHAIN_NETWORK_MODE_MAINNET";
    case ChainNetworkMode.CHAIN_NETWORK_MODE_TESTNET:
      return "CHAIN_NETWORK_MODE_TESTNET";
    case ChainNetworkMode.CHAIN_NETWORK_MODE_DEVNET:
      return "CHAIN_NETWORK_MODE_DEVNET";
    case ChainNetworkMode.CHAIN_NETWORK_MODE_REGTEST:
      return "CHAIN_NETWORK_MODE_REGTEST";
    case ChainNetworkMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProposalResult {
  PROPOSAL_RESULT_UNSPECIFIED = 0,
  PROPOSAL_RESULT_SUCCESS = 1,
  PROPOSAL_RESULT_FAILED = 2,
  UNRECOGNIZED = -1,
}

export function proposalResultFromJSON(object: any): ProposalResult {
  switch (object) {
    case 0:
    case "PROPOSAL_RESULT_UNSPECIFIED":
      return ProposalResult.PROPOSAL_RESULT_UNSPECIFIED;
    case 1:
    case "PROPOSAL_RESULT_SUCCESS":
      return ProposalResult.PROPOSAL_RESULT_SUCCESS;
    case 2:
    case "PROPOSAL_RESULT_FAILED":
      return ProposalResult.PROPOSAL_RESULT_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProposalResult.UNRECOGNIZED;
  }
}

export function proposalResultToJSON(object: ProposalResult): string {
  switch (object) {
    case ProposalResult.PROPOSAL_RESULT_UNSPECIFIED:
      return "PROPOSAL_RESULT_UNSPECIFIED";
    case ProposalResult.PROPOSAL_RESULT_SUCCESS:
      return "PROPOSAL_RESULT_SUCCESS";
    case ProposalResult.PROPOSAL_RESULT_FAILED:
      return "PROPOSAL_RESULT_FAILED";
    case ProposalResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProposalStatus {
  PROPOSAL_STATUS_UNSPECIFIED = 0,
  PROPOSAL_STATUS_PENDING = 1,
  PROPOSAL_STATUS_SUCCESS = 2,
  PROPOSAL_STATUS_FAILED = 3,
  PROPOSAL_STATUS_TIMEOUT = 4,
  UNRECOGNIZED = -1,
}

export function proposalStatusFromJSON(object: any): ProposalStatus {
  switch (object) {
    case 0:
    case "PROPOSAL_STATUS_UNSPECIFIED":
      return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
    case 1:
    case "PROPOSAL_STATUS_PENDING":
      return ProposalStatus.PROPOSAL_STATUS_PENDING;
    case 2:
    case "PROPOSAL_STATUS_SUCCESS":
      return ProposalStatus.PROPOSAL_STATUS_SUCCESS;
    case 3:
    case "PROPOSAL_STATUS_FAILED":
      return ProposalStatus.PROPOSAL_STATUS_FAILED;
    case 4:
    case "PROPOSAL_STATUS_TIMEOUT":
      return ProposalStatus.PROPOSAL_STATUS_TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProposalStatus.UNRECOGNIZED;
  }
}

export function proposalStatusToJSON(object: ProposalStatus): string {
  switch (object) {
    case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
      return "PROPOSAL_STATUS_UNSPECIFIED";
    case ProposalStatus.PROPOSAL_STATUS_PENDING:
      return "PROPOSAL_STATUS_PENDING";
    case ProposalStatus.PROPOSAL_STATUS_SUCCESS:
      return "PROPOSAL_STATUS_SUCCESS";
    case ProposalStatus.PROPOSAL_STATUS_FAILED:
      return "PROPOSAL_STATUS_FAILED";
    case ProposalStatus.PROPOSAL_STATUS_TIMEOUT:
      return "PROPOSAL_STATUS_TIMEOUT";
    case ProposalStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** InboundTransferStatus defines the status of an inbound transfer */
export enum InboundTransferStatus {
  /** INBOUND_TRANSFER_STATUS_UNSPECIFIED - INBOUND_TRANSFER_STATUS_UNSPECIFIED indicates an unspecified status */
  INBOUND_TRANSFER_STATUS_UNSPECIFIED = 0,
  /**
   * INBOUND_TRANSFER_STATUS_VOTING - INBOUND_TRANSFER_STATUS_VOTING indicates that the transfer is being voted
   * on
   */
  INBOUND_TRANSFER_STATUS_VOTING = 1,
  /**
   * INBOUND_TRANSFER_STATUS_RATELIMITED - INBOUND_TRANSFER_STATUS_RATELIMITED indicates that the transfer is rate
   * limited
   */
  INBOUND_TRANSFER_STATUS_RATELIMITED = 2,
  /**
   * INBOUND_TRANSFER_STATUS_FINALIZED - INBOUND_TRANSFER_STATUS_FINALIZED indicates that the transfer has been
   * finalized
   */
  INBOUND_TRANSFER_STATUS_FINALIZED = 3,
  UNRECOGNIZED = -1,
}

export function inboundTransferStatusFromJSON(object: any): InboundTransferStatus {
  switch (object) {
    case 0:
    case "INBOUND_TRANSFER_STATUS_UNSPECIFIED":
      return InboundTransferStatus.INBOUND_TRANSFER_STATUS_UNSPECIFIED;
    case 1:
    case "INBOUND_TRANSFER_STATUS_VOTING":
      return InboundTransferStatus.INBOUND_TRANSFER_STATUS_VOTING;
    case 2:
    case "INBOUND_TRANSFER_STATUS_RATELIMITED":
      return InboundTransferStatus.INBOUND_TRANSFER_STATUS_RATELIMITED;
    case 3:
    case "INBOUND_TRANSFER_STATUS_FINALIZED":
      return InboundTransferStatus.INBOUND_TRANSFER_STATUS_FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InboundTransferStatus.UNRECOGNIZED;
  }
}

export function inboundTransferStatusToJSON(object: InboundTransferStatus): string {
  switch (object) {
    case InboundTransferStatus.INBOUND_TRANSFER_STATUS_UNSPECIFIED:
      return "INBOUND_TRANSFER_STATUS_UNSPECIFIED";
    case InboundTransferStatus.INBOUND_TRANSFER_STATUS_VOTING:
      return "INBOUND_TRANSFER_STATUS_VOTING";
    case InboundTransferStatus.INBOUND_TRANSFER_STATUS_RATELIMITED:
      return "INBOUND_TRANSFER_STATUS_RATELIMITED";
    case InboundTransferStatus.INBOUND_TRANSFER_STATUS_FINALIZED:
      return "INBOUND_TRANSFER_STATUS_FINALIZED";
    case InboundTransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Params defines params for x/bridge module. */
export interface Params {
  /**
   * Signers used to sign inbound and release outbound transactions
   * Deprecated: moved to the corresponding `chains` entry
   *
   * @deprecated
   */
  signers: string[];
  /**
   * Assets is a list used to create tokenfactory denoms
   * for corresponding trading pairs
   */
  assets: Asset[];
  /**
   * VotesNeeded marks how many signers out of the list of signers need
   * to sign until a tx can be considered finalized
   * Deprecated: moved to the corresponding `chains` entry
   *
   * @deprecated
   */
  votesNeeded: Long;
  /**
   * Fee defines a param for fee that go towards the validator set
   * signing the incoming/outgoing txs. The fee is measured as a ratio,
   * so its value lies between 0 and 1.
   * Deprecated: moved to x/fees module
   *
   * @deprecated
   */
  fee: string;
  /**
   * TonParams defines params for the TON bridge contract
   * Deprecated: moved to corresponding `chains` entry
   *
   * @deprecated
   */
  tonParams:
    | TonContractParams
    | undefined;
  /**
   * SolanaParams defines params for the Solana bridge contract
   * Deprecated: moved to corresponding `chains` entry
   *
   * @deprecated
   */
  solanaParams:
    | SolanaContractParams
    | undefined;
  /**
   * IbcForwardParams defines params for the IBC forwarding
   * Deprecated: moved to corresponding `chains` entry
   *
   * @deprecated
   */
  ibcForwardingParams: IbcForwardingParams[];
  /**
   * BaseParams defines params for the Base chain bridge contract
   * Deprecated: moved to corresponding `chains` entry
   *
   * @deprecated
   */
  baseParams:
    | BaseContractParams
    | undefined;
  /** Chains is the list of supported chains */
  chains: Chain[];
  /** BridgeStatus is the current status of the bridge */
  bridgeStatus: BridgeStatus;
  /** TimeoutParams defines timeouts in blocks for different actions */
  timeoutParams: BridgeTimeouts | undefined;
}

/**
 * AssetID defines a pair of the source chain name and its Int3face
 * representation denoted by denom. AssetID is a primary key for Asset.
 */
export interface AssetID {
  /** SourceChain is a source chain name */
  sourceChain: string;
  /** Denom is the Int3face representation of the SourceChain */
  denom: string;
}

/** Asset is a representation of the asset. */
export interface Asset {
  /** ID is the asset's primary key */
  id:
    | AssetID
    | undefined;
  /** Status is a current status of the asset */
  status: AssetStatus;
  /** Exponent represents the power of 10 used for coin representation */
  exponent: Long;
  /**
   * ExternalConfirmations is a number of the confirmations on the external
   * chain needed to consider the transfer confirmed
   * Deprecated: moved to the corresponding `chains` entry
   *
   * @deprecated
   */
  externalConfirmations: Long;
  /** Minimal amount of tokens for transfer */
  minTransferAmount: string;
  /**
   * ExecutionPeriod defines how long transfer for the given asset required to
   * be in the execution unitl it can be retried.
   * Deprecated: moved to the ChainRetryParams
   *
   * @deprecated
   */
  executionPeriod: Long;
  /**
   * GracePeriod defines how long after the execution period transfer for the
   * given asset can be retried.
   * Deprecated: moved to the ChainRetryParams
   *
   * @deprecated
   */
  gracePeriod: Long;
}

/** Signer is a representation of the signer for a specific chain */
export interface Signer {
  /** Int3Address is the Int3face address of the signer */
  int3Address: string;
  /** ExternalKey is the pubkey/address of the signer on an external chain */
  externalKey: string;
}

/** Chain contain parameters for a specific chain */
export interface Chain {
  /** Id is the name-identifier of the chain */
  id: string;
  /**
   * CodeId is the short and unique code id of the chain like -> OSMO for
   * Osmosis or SOLN for Solana etc.
   */
  codeId: string;
  /** Type is the type of the chain */
  type: ChainType;
  /** Status is the current chain status */
  status: ChainStatus;
  /** RetryParams defines the parameters for the retry mechanism */
  retryParams:
    | ChainRetryParams
    | undefined;
  /** IntegrationProtocol is the type of the connection to the chain */
  integrationProtocol: IntegrationProtocol;
  /** Chain is the encoded data for a specific chain */
  chain: Any | undefined;
}

export interface ChainRetryParams {
  /**
   * ExecutionPeriod defines how long transfer for the chain required to
   * be in the execution until it can be retried.
   */
  executionPeriod: Long;
  /**
   * GracePeriod defines how long after the execution period transfer for the
   * chain can be retried.
   */
  gracePeriod: Long;
}

/** Int3faceAsset is a representation of an Int3face asset parameters */
export interface Int3faceAsset {
  /** Id is an identifier of the asset */
  id:
    | AssetID
    | undefined;
  /** Status is the current status of the asset */
  status: ChainAssetStatus;
}

/** Int3faceChain is a representation of the Int3face chain parameters */
export interface Int3faceChain {
  /** Assets is the list of supported assets */
  assets: Int3faceAsset[];
}

/** UtxoAsset is a representation of a UTXO asset parameters */
export interface UtxoAsset {
  /** Id is an identifier of the asset */
  id:
    | AssetID
    | undefined;
  /** Status is the current status of the asset */
  status: ChainAssetStatus;
}

/** UtxoChain is a representation of a UTXO chain parameters */
export interface UtxoChain {
  signers: Signer[];
  assets: UtxoAsset[];
  vaultPubkey: string;
  vaultAddress: string;
  gasParams:
    | GasParams
    | undefined;
  /**
   * ConfirmationsRequired is a number of the confirmations on the
   * chain needed to consider the transfer confirmed
   */
  confirmationsRequired: Long;
  relayerParams: UtxoRelayerParams | undefined;
  networkMode: ChainNetworkMode;
}

export interface UtxoRelayerParams {
  /**
   * MaxUtxoToSpend is a maximum number of UTXOs to spend in a single
   * transaction
   */
  maxUtxoToSpend: Long;
  /** MaxSatoshiPerByte is a maximum fee rate in satoshi per byte */
  maxSatoshiPerByte: Long;
}

export interface SmartContractAsset {
  id: AssetID | undefined;
  status: ChainAssetStatus;
  address: string;
  owned: boolean;
  destChainIds: string[];
}

export interface SmartContractChain {
  signers: Signer[];
  assets: SmartContractAsset[];
  contractAddress: string;
  chainWallet: string;
  gasParams:
    | GasParams
    | undefined;
  /**
   * ConfirmationsRequired is a number of the confirmations on the
   * chain needed to consider the transfer confirmed
   */
  confirmationsRequired: Long;
}

export interface GasParams {
  gasAsset: AssetID | undefined;
  gasFees: GasFee[];
}

export interface GasFee {
  type: GasFeeType;
  amount: string;
}

export interface IbcAssetSwap {
  enabled: boolean;
  contractAddress: string;
  sourceDenom: string;
  destDenom: string;
}

export interface IbcAsset {
  id: AssetID | undefined;
  status: ChainAssetStatus;
  localIbcDenom: string;
  externalIbcDenom: string;
  swap: IbcAssetSwap | undefined;
}

export interface IbcChain {
  bech32Prefix: string;
  channelId: string;
  portId: string;
  timeout: Long;
  assets: IbcAsset[];
  chainWallet: string;
}

export interface NttAsset {
  id: AssetID | undefined;
  status: ChainAssetStatus;
  nttManagerAddress: string;
  externalNttManagerAddress: string;
  externalTokenAddress: string;
  nttTransceivers: string[];
  externalNttTransceivers: string[];
}

export interface NttChain {
  forwardingChainId: string;
  signers: Signer[];
  assets: NttAsset[];
  chainWallet: string;
  wormholeProgram: string;
  nttChainId: Long;
}

export interface PaymentAsset {
  id: AssetID | undefined;
  status: ChainAssetStatus;
}

export interface PaymentChain {
  signers: Signer[];
  assets: PaymentAsset[];
  vaultPubkey: string;
  vaultAddress: string;
  gasParams:
    | GasParams
    | undefined;
  /**
   * ConfirmationsRequired is a number of the confirmations on the
   * chain needed to consider the transfer confirmed
   */
  confirmationsRequired: Long;
}

/** InboundTransfer is a representation of the inbound transfer. */
export interface InboundTransfer {
  /**
   * ExternalId is a unique ID of the transfer coming from outside.
   * Serves the purpose of uniquely identifying the transfer in another chain
   * (e.g., this might be the BTC tx hash).
   */
  externalId: string;
  /**
   * ExternalHeight is the height at which the transfer occurred in the external
   * chain
   */
  externalHeight: Long;
  /** DestAddr is a destination address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  /** Voters is a list of validators signed this transfer */
  voters: string[];
  /** Status indicates the current state of the transfer */
  status: InboundTransferStatus;
  /**
   * DestChainId is a destination chain of the transfer. If this id is not
   * Int3face chain, we need to perform forwarding of the tokens to the
   * destination chain.
   */
  destChainId: string;
  /** SrcChainId is a source chain of the transfer. */
  srcChainId: string;
  /**
   * FinalizedTxHash is a hash of the final int3face transaction which finalized
   * the transfer and minted the tokens.
   */
  finalizedTxHash: string;
  /** Fees defines the fees for the inbound transfer */
  fees:
    | TransferFees
    | undefined;
  /** VotesNeeded is the number of votes needed to finalize the transfer */
  votesNeeded: Long;
}

export interface KeyGen {
  /**
   * KeygenID is a unique identifier for the original keygen. May be either
   * proposal ID or keygen tx hash.
   */
  keygenId: string;
  /**
   * ParticipantsAddrs is a list of observers' addresses participating
   * in the newly generated committee.
   */
  participantsAddrs: string[];
  /** PoolPK is a newly generated pool public key of the committee. */
  poolPk: string;
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the keygen needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

/**
 * VaultAddress defines the message structure for the TSS vault address of the
 * UTXO chain.
 */
export interface TssVaultAddress {
  /** ChainID is the chain's primary key */
  chainId: string;
  /** VaultAddress is the TSS vault address */
  address: string;
}

export interface KeyGenResult {
  /**
   * KeygenID is a unique identifier for the original keygen. May be either
   * proposal ID or keygen tx hash.
   */
  keygenId: string;
  /**
   * ParticipantsAddrs is a list of observers' addresses participating
   * in the newly generated committee.
   */
  participantsAddrs: string[];
}

export interface ContractFee {
  type: string;
  fee: string;
}

/** Params defines params for the TON bridge contract */
export interface TonContractParams {
  /**
   * Signers used to authorize outbound transfers and param updates
   * Defined as a pair of Int3face address - TON address
   */
  signers: SignerPair[];
  /** Fees defines the size of the fee for specific operations */
  fees: ContractFee[];
  /** ContractAddress defines current TON bridge contract address */
  contractAddress: string;
  /** ContractStatus defines the status of the TON bridge contract */
  contractStatus: ContractStatus;
}

/** Params defines params for the Solana bridge contract */
export interface SolanaContractParams {
  /**
   * Signers used to authorize outbound transfers and param updates
   * Defined as a pair of Int3face address - Solana address
   */
  signers: SignerPair[];
  /** Fees defines the size of the fee for specific operations */
  fees: ContractFee[];
  /** ContractAddress defines current Solana bridge contract address */
  contractAddress: string;
  /** ContractStatus defines the status of the TON bridge contract */
  contractStatus: ContractStatus;
  /** AssetParams defines the list of the chain assets. */
  assetParams: ContractAssetParams[];
}

/** Params defines params for the Base chain bridge contract */
export interface BaseContractParams {
  /**
   * Signers used to authorize outbound transfers and param updates
   * Defined as a pair of Int3face address - Base chain address
   */
  signers: SignerPair[];
  /** Fees defines the size of the fee for specific operations */
  fees: ContractFee[];
  /** AssetParams defines the list of the chain assets. */
  assetParams: ContractAssetParams[];
  /** ContractAddress defines current Base chain bridge contract address */
  contractAddress: string;
  /** ContractStatus defines the status of the Base chain bridge contract */
  contractStatus: ContractStatus;
}

export interface ContractAssetParams {
  /** Denom is the denom (id) of the asset. */
  denom: string;
  /**
   * Address is the address of the asset on the chain. Empty address means
   * native asset.
   */
  address: string;
  /** MinTransferAmount minimal transfer amount for the bridge contract. */
  minTransferAmount: string;
  /**
   * DestinationChainIds is a list of the chain identifiers where the asset can
   * be transferred.
   */
  destinationChainIds: string[];
  /** Owned indicates whether the asset is owned and managed by the bridge. */
  owned: boolean;
  /** Whitelisted indicates whether the asset is whitelisted for transfers. */
  whitelisted: boolean;
  /** AssetID is the ID of the asset to identify it in the bridge. */
  assetId: AssetID | undefined;
}

export interface ContractAssetId {
  /** Denom is the denom (id) of the asset. */
  denom: string;
  /**
   * Address is the address of the asset on the chain. Empty address means
   * native asset.
   */
  address: string;
}

export interface SignerPair {
  /** Int3Addr is the Int3face address of the committee participant */
  int3Addr: string;
  /** External chain address of the committee participant */
  chainAddr: string;
}

export interface ContractSigners {
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /**
   * Signers is a list of observer's addresses that we expect to include in the
   * next comittee.
   */
  signers: SignerPair[];
}

export interface ContractSignersUpdate {
  /** UpdateId is a unqiue identifier of the update. */
  updateId: string;
  /** Signers is a list of new contract signers addresses. */
  signers: ContractSigners[];
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

export interface ContractSignersUpdateResult {
  /** UpdateId is a unqiue identifier of the update. */
  updateId: string;
  /** Signers is a list of new contract signers addresses. */
  signers: ContractSigners[];
}

export interface ContractParamsUpdate {
  /** UpdateId is a unqiue identifier of the update. */
  updateId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** ContractAddress is the new address of the bridge contract. */
  contractAddress: string;
  /**
   * Deprecated: use params instead. MinTransferAmount minimal transfer amount
   * for the bridge contract.
   */
  minTransferAmount: string;
  /** Fees is a list of the fees amount for different operations. */
  fees: ContractFee[];
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
  /** Params is the list of new parameters for the chain assets. */
  assetParams: ContractAssetParams[];
}

export interface ContractParamsUpdateResult {
  /** UpdateId is a unqiue identifier of the update. */
  updateId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** ContractAddress is the new address of the bridge contract. */
  contractAddress: string;
  /**
   * Deprecated: use params instead. MinTransferAmount minimal transfer amount
   * for the bridge contract.
   */
  minTransferAmount: string;
  /** Fees is a list of the fees amount for different operations. */
  fees: ContractFee[];
  /** Params is the list of new parameters for the chain assets. */
  assetParams: ContractAssetParams[];
}

export interface ContractStatusUpdate {
  /** UpdateId is a unique identifier of the update. */
  updateId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Status is a new status of the bridge contract. */
  status: ContractStatus;
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

export interface ContractStatusUpdateResult {
  /** UpdateId is a unique identifier of the update. */
  updateId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Status is a new status of the bridge contract. */
  status: ContractStatus;
}

export interface ContractPrune {
  /** PruneId is a unique identifier of the prune. */
  pruneId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** PruneBefore is a timestamp before which the data should be pruned. */
  pruneBefore: Long;
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

export interface ContractPruneResult {
  /** PruneId is a unique identifier of the prune. */
  pruneId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** PruneBefore is a timestamp before which the data should be pruned. */
  pruneBefore: Long;
}

export interface ContractUpgrade {
  /** UpgradeId is a unique identifier of the prune. */
  upgradeId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractData: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractCode: string;
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
  /** UpgradeData is the encoded contract data related to the concrete chain. */
  upgradeData: ContractUpgradeData | undefined;
}

export interface ContractUpgradeResult {
  /** UpgradeId is a unique identifier of the prune. */
  upgradeId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractData: string;
  /** Deprecated: use ContractUpgradeData instead. */
  contractCode: string;
  /** UpgradeData is the encoded contract data related to the concrete chain. */
  upgradeData: ContractUpgradeData | undefined;
}

export interface ContractUpgradeData {
  /** TonContractUpgradeData is the new encoded contract data. */
  tonData?:
    | TonContractUpgradeData
    | undefined;
  /** SolanaContractUpgradeData is the new encoded contract data. */
  solanaData?:
    | SolanaContractUpgradeData
    | undefined;
  /** BaseContractUpgradeData is the new encoded contract data. */
  baseData?: BaseContractUpgradeData | undefined;
}

export interface TonContractUpgradeData {
  /** ContractData is the new encoded contract data. */
  contractData: string;
  /** ContractCode is the new encoded contract code. */
  contractCode: string;
}

export interface SolanaContractUpgradeData {
  /** ContractAddress is the new address of the bridge contract. */
  contractAddress: string;
  /** MethodDescriptor is the descriptor of `migrate` method of the new program. */
  methodDescriptor: Uint8Array;
}

export interface BaseContractUpgradeData {
  /** ContractAddress is the new address of the bridge contract. */
  contractAddress: string;
}

export interface IbcForwardingParams {
  /** ChainId is the id of the IBC destination chain. */
  chainId: string;
  /** IbcChannelId is the IBC channel id for the given chain. */
  ibcChannelId: string;
  /** IbcPortId is the IBC port id for the given chain. */
  ibcPortId: string;
  /** IbcTimeout is the timeout in nanoseconds used for the IBC transfers. */
  ibcTimeout: Long;
  /** AssetSwaps is a list of the asset swaps for the given chain. */
  assetSwaps: AssetSwap[];
}

export interface AssetSwap {
  /** Enabled is a flag to enable or disable the asset swap. */
  enabled: boolean;
  /** ContractAddress is the address of the contract on the destination chain. */
  contractAddress: string;
  /** SourceDenom is the denom of the source asset. */
  sourceDenom: string;
  /** DestDenom is the denom of the destination asset. */
  destDenom: string;
}

export interface ContractAddAssets {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /**
   * NewAssets is the list of new assets parameters to add to the bridge
   * contract.
   */
  newAssets: ContractAssetParams[];
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

export interface ContractAddAssetsResult {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /**
   * NewAssets is the list of new assets parameters to add to the bridge
   * contract.
   */
  newAssets: ContractAssetParams[];
}

export interface ContractDeleteAsset {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** AssetAddress is the address of the asset to delete. */
  assetAddress: string;
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

export interface ContractDeleteAssetResult {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** AssetAddress is the address of the asset to delete. */
  assetAddress: string;
}

export interface ContractAssetsWhitelist {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to whitelist. */
  asset:
    | ContractAssetId
    | undefined;
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

export interface ContractAssetsWhitelistResult {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to whitelist. */
  asset: ContractAssetId | undefined;
}

export interface ContractAssetsUnwhitelist {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to unwhitelist. */
  asset:
    | ContractAssetId
    | undefined;
  /** Voters is a list of validators signed this keygen result. */
  voters: string[];
  /**
   * Finalized indicates whether the update needs more votes or has
   * already accumulated a sufficient number. The finalised flag is set
   * to true as soon as length(voters) is greater than or equal to
   * the 2/3th of the expected participants number.
   */
  finalized: boolean;
}

export interface ContractAssetsUnwhitelistResult {
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to unwhitelist. */
  asset: ContractAssetId | undefined;
}

export interface OutboundTransfer {
  /** Status is a current status of the outbound transfer */
  status: OutboundTransferStatus;
  /** TransferProtocol is a protocol used for the transfer to sent */
  transferProtocol: TransferProtocol;
  /** SrcChainId is a source chain of the transfer origin. */
  srcChainId: string;
  /** DestChainId is a destination chain of the transfer */
  destChainId: string;
  /** DestAddr is a destination address on the destination chain */
  destAddr: string;
  /** AssetId is the asset is being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  /** CreationTimestamp is a timestamp when the outbound transfer was created */
  creationTimestamp: Long;
  /**
   * ResolutionTimestamp is a timestamp when the outbound transfer was updated
   * last time
   */
  lastUpdateTimestamp: Long;
  /**
   * OutboundTransferVotes is a list of different votes collected during the
   * outbound transfer lifecycle
   */
  votes:
    | OutboundTransferVotes
    | undefined;
  /**
   * InboundContext is a context of the inbound transfer that was used to create
   * the outbound transfer
   */
  inboundContext:
    | InboundTransferContext
    | undefined;
  /** TxHash is a hash of the transaction on the Int3face chain */
  txHash: string;
  /**
   * Sender is a sender of the outbound transfer
   * Deprecated: was used to determine ibc transfer retry possibility
   * Now the logic is changed to checking by the src_chain_id != 'int3face'
   *
   * @deprecated
   */
  sender: string;
  /** Fees defines the fees for the outbound transfer */
  fees:
    | TransferFees
    | undefined;
  /**
   * FinalizedTxHash is a hash of the final int3face transaction which finalized
   * the transfer.
   */
  finalizedTxHash: string;
  /** VotesNeeded is the number of votes needed to finalize the transfer */
  votesNeeded: Long;
}

export interface InboundTransferContext {
  /** TransferId is a unique ID of the inbound transfer */
  transferId: string;
}

export interface OutboundTransferVotes {
  /** Finalized is a list of validators signed this transfer on finalization */
  finalized: VoteOnFinalization[];
  /** Failed is a list of validators signed this transfer on failure */
  failed: VoteOnFailure[];
}

export interface VoteOnFinalization {
  /** Voter is a validator signed this transfer on finalization */
  voter: string;
  /**
   * BroadcastedTxHash is a hash of the broadcasted transaction on the
   * destination chain
   */
  broadcastedTxHash: string;
}

export interface VoteOnFailure {
  /** Voter is a validator signed this transfer on refunding */
  voter: string;
}

export interface BridgeProposalVotes {
  chainId: string;
  expectedVoters: string[];
  finalized: VoteOnFinalization[];
  failed: VoteOnFailure[];
}

export interface BridgeProposal {
  proposalId: Long;
  status: ProposalStatus;
  votes: BridgeProposalVotes[];
}

export interface BridgeTimeouts {
  govTimeoutSeconds: Long;
  inboundTransferTimeoutSeconds: Long;
  outboundTransferTimeoutSeconds: Long;
}

export interface TransferFees {
  bridgeFee: string;
}

export interface QuarantineResolves {
  /** QuarantineId is the ID of the quarantined entity */
  quarantineId: string;
  /** VotingResult is the voting result (process or reject) */
  votingResult: QuarantineVotingResult;
  /** EntityType is the type of entity that is being quarantined */
  entityType: QuarantinedEntityType;
  /** EntityID is the ID of the entity that is being quarantined */
  entityId: string;
}

function createBaseParams(): Params {
  return {
    signers: [],
    assets: [],
    votesNeeded: Long.UZERO,
    fee: "",
    tonParams: undefined,
    solanaParams: undefined,
    ibcForwardingParams: [],
    baseParams: undefined,
    chains: [],
    bridgeStatus: 0,
    timeoutParams: undefined,
  };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signers) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(18).fork()).join();
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.votesNeeded.toString());
    }
    if (message.fee !== "") {
      writer.uint32(34).string(message.fee);
    }
    if (message.tonParams !== undefined) {
      TonContractParams.encode(message.tonParams, writer.uint32(42).fork()).join();
    }
    if (message.solanaParams !== undefined) {
      SolanaContractParams.encode(message.solanaParams, writer.uint32(50).fork()).join();
    }
    for (const v of message.ibcForwardingParams) {
      IbcForwardingParams.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.baseParams !== undefined) {
      BaseContractParams.encode(message.baseParams, writer.uint32(66).fork()).join();
    }
    for (const v of message.chains) {
      Chain.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.bridgeStatus !== 0) {
      writer.uint32(80).int32(message.bridgeStatus);
    }
    if (message.timeoutParams !== undefined) {
      BridgeTimeouts.encode(message.timeoutParams, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.votesNeeded = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fee = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tonParams = TonContractParams.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.solanaParams = SolanaContractParams.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ibcForwardingParams.push(IbcForwardingParams.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.baseParams = BaseContractParams.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.chains.push(Chain.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.bridgeStatus = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.timeoutParams = BridgeTimeouts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => globalThis.String(e)) : [],
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [],
      votesNeeded: isSet(object.votesNeeded) ? Long.fromValue(object.votesNeeded) : Long.UZERO,
      fee: isSet(object.fee) ? globalThis.String(object.fee) : "",
      tonParams: isSet(object.tonParams) ? TonContractParams.fromJSON(object.tonParams) : undefined,
      solanaParams: isSet(object.solanaParams) ? SolanaContractParams.fromJSON(object.solanaParams) : undefined,
      ibcForwardingParams: globalThis.Array.isArray(object?.ibcForwardingParams)
        ? object.ibcForwardingParams.map((e: any) => IbcForwardingParams.fromJSON(e))
        : [],
      baseParams: isSet(object.baseParams) ? BaseContractParams.fromJSON(object.baseParams) : undefined,
      chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => Chain.fromJSON(e)) : [],
      bridgeStatus: isSet(object.bridgeStatus) ? bridgeStatusFromJSON(object.bridgeStatus) : 0,
      timeoutParams: isSet(object.timeoutParams) ? BridgeTimeouts.fromJSON(object.timeoutParams) : undefined,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.signers?.length) {
      obj.signers = message.signers;
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      obj.votesNeeded = (message.votesNeeded || Long.UZERO).toString();
    }
    if (message.fee !== "") {
      obj.fee = message.fee;
    }
    if (message.tonParams !== undefined) {
      obj.tonParams = TonContractParams.toJSON(message.tonParams);
    }
    if (message.solanaParams !== undefined) {
      obj.solanaParams = SolanaContractParams.toJSON(message.solanaParams);
    }
    if (message.ibcForwardingParams?.length) {
      obj.ibcForwardingParams = message.ibcForwardingParams.map((e) => IbcForwardingParams.toJSON(e));
    }
    if (message.baseParams !== undefined) {
      obj.baseParams = BaseContractParams.toJSON(message.baseParams);
    }
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => Chain.toJSON(e));
    }
    if (message.bridgeStatus !== 0) {
      obj.bridgeStatus = bridgeStatusToJSON(message.bridgeStatus);
    }
    if (message.timeoutParams !== undefined) {
      obj.timeoutParams = BridgeTimeouts.toJSON(message.timeoutParams);
    }
    return obj;
  },

  create(base?: DeepPartial<Params>): Params {
    return Params.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.signers = object.signers?.map((e) => e) || [];
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    message.votesNeeded = (object.votesNeeded !== undefined && object.votesNeeded !== null)
      ? Long.fromValue(object.votesNeeded)
      : Long.UZERO;
    message.fee = object.fee ?? "";
    message.tonParams = (object.tonParams !== undefined && object.tonParams !== null)
      ? TonContractParams.fromPartial(object.tonParams)
      : undefined;
    message.solanaParams = (object.solanaParams !== undefined && object.solanaParams !== null)
      ? SolanaContractParams.fromPartial(object.solanaParams)
      : undefined;
    message.ibcForwardingParams = object.ibcForwardingParams?.map((e) => IbcForwardingParams.fromPartial(e)) || [];
    message.baseParams = (object.baseParams !== undefined && object.baseParams !== null)
      ? BaseContractParams.fromPartial(object.baseParams)
      : undefined;
    message.chains = object.chains?.map((e) => Chain.fromPartial(e)) || [];
    message.bridgeStatus = object.bridgeStatus ?? 0;
    message.timeoutParams = (object.timeoutParams !== undefined && object.timeoutParams !== null)
      ? BridgeTimeouts.fromPartial(object.timeoutParams)
      : undefined;
    return message;
  },
};

function createBaseAssetID(): AssetID {
  return { sourceChain: "", denom: "" };
}

export const AssetID: MessageFns<AssetID> = {
  encode(message: AssetID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceChain !== "") {
      writer.uint32(10).string(message.sourceChain);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceChain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetID {
    return {
      sourceChain: isSet(object.sourceChain) ? globalThis.String(object.sourceChain) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
    };
  },

  toJSON(message: AssetID): unknown {
    const obj: any = {};
    if (message.sourceChain !== "") {
      obj.sourceChain = message.sourceChain;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetID>): AssetID {
    return AssetID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetID>): AssetID {
    const message = createBaseAssetID();
    message.sourceChain = object.sourceChain ?? "";
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return {
    id: undefined,
    status: 0,
    exponent: Long.UZERO,
    externalConfirmations: Long.UZERO,
    minTransferAmount: "",
    executionPeriod: Long.UZERO,
    gracePeriod: Long.UZERO,
  };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (!message.exponent.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.exponent.toString());
    }
    if (!message.externalConfirmations.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.externalConfirmations.toString());
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(42).string(message.minTransferAmount);
    }
    if (!message.executionPeriod.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.executionPeriod.toString());
    }
    if (!message.gracePeriod.equals(Long.UZERO)) {
      writer.uint32(56).uint64(message.gracePeriod.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exponent = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.externalConfirmations = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.executionPeriod = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gracePeriod = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? assetStatusFromJSON(object.status) : 0,
      exponent: isSet(object.exponent) ? Long.fromValue(object.exponent) : Long.UZERO,
      externalConfirmations: isSet(object.externalConfirmations)
        ? Long.fromValue(object.externalConfirmations)
        : Long.UZERO,
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
      executionPeriod: isSet(object.executionPeriod) ? Long.fromValue(object.executionPeriod) : Long.UZERO,
      gracePeriod: isSet(object.gracePeriod) ? Long.fromValue(object.gracePeriod) : Long.UZERO,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = assetStatusToJSON(message.status);
    }
    if (!message.exponent.equals(Long.UZERO)) {
      obj.exponent = (message.exponent || Long.UZERO).toString();
    }
    if (!message.externalConfirmations.equals(Long.UZERO)) {
      obj.externalConfirmations = (message.externalConfirmations || Long.UZERO).toString();
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    if (!message.executionPeriod.equals(Long.UZERO)) {
      obj.executionPeriod = (message.executionPeriod || Long.UZERO).toString();
    }
    if (!message.gracePeriod.equals(Long.UZERO)) {
      obj.gracePeriod = (message.gracePeriod || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    message.exponent = (object.exponent !== undefined && object.exponent !== null)
      ? Long.fromValue(object.exponent)
      : Long.UZERO;
    message.externalConfirmations =
      (object.externalConfirmations !== undefined && object.externalConfirmations !== null)
        ? Long.fromValue(object.externalConfirmations)
        : Long.UZERO;
    message.minTransferAmount = object.minTransferAmount ?? "";
    message.executionPeriod = (object.executionPeriod !== undefined && object.executionPeriod !== null)
      ? Long.fromValue(object.executionPeriod)
      : Long.UZERO;
    message.gracePeriod = (object.gracePeriod !== undefined && object.gracePeriod !== null)
      ? Long.fromValue(object.gracePeriod)
      : Long.UZERO;
    return message;
  },
};

function createBaseSigner(): Signer {
  return { int3Address: "", externalKey: "" };
}

export const Signer: MessageFns<Signer> = {
  encode(message: Signer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.int3Address !== "") {
      writer.uint32(10).string(message.int3Address);
    }
    if (message.externalKey !== "") {
      writer.uint32(18).string(message.externalKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.int3Address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signer {
    return {
      int3Address: isSet(object.int3Address) ? globalThis.String(object.int3Address) : "",
      externalKey: isSet(object.externalKey) ? globalThis.String(object.externalKey) : "",
    };
  },

  toJSON(message: Signer): unknown {
    const obj: any = {};
    if (message.int3Address !== "") {
      obj.int3Address = message.int3Address;
    }
    if (message.externalKey !== "") {
      obj.externalKey = message.externalKey;
    }
    return obj;
  },

  create(base?: DeepPartial<Signer>): Signer {
    return Signer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Signer>): Signer {
    const message = createBaseSigner();
    message.int3Address = object.int3Address ?? "";
    message.externalKey = object.externalKey ?? "";
    return message;
  },
};

function createBaseChain(): Chain {
  return { id: "", codeId: "", type: 0, status: 0, retryParams: undefined, integrationProtocol: 0, chain: undefined };
}

export const Chain: MessageFns<Chain> = {
  encode(message: Chain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.codeId !== "") {
      writer.uint32(18).string(message.codeId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.retryParams !== undefined) {
      ChainRetryParams.encode(message.retryParams, writer.uint32(42).fork()).join();
    }
    if (message.integrationProtocol !== 0) {
      writer.uint32(48).int32(message.integrationProtocol);
    }
    if (message.chain !== undefined) {
      Any.encode(message.chain, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Chain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.retryParams = ChainRetryParams.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.integrationProtocol = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.chain = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chain {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      codeId: isSet(object.codeId) ? globalThis.String(object.codeId) : "",
      type: isSet(object.type) ? chainTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? chainStatusFromJSON(object.status) : 0,
      retryParams: isSet(object.retryParams) ? ChainRetryParams.fromJSON(object.retryParams) : undefined,
      integrationProtocol: isSet(object.integrationProtocol)
        ? integrationProtocolFromJSON(object.integrationProtocol)
        : 0,
      chain: isSet(object.chain) ? Any.fromJSON(object.chain) : undefined,
    };
  },

  toJSON(message: Chain): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.codeId !== "") {
      obj.codeId = message.codeId;
    }
    if (message.type !== 0) {
      obj.type = chainTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = chainStatusToJSON(message.status);
    }
    if (message.retryParams !== undefined) {
      obj.retryParams = ChainRetryParams.toJSON(message.retryParams);
    }
    if (message.integrationProtocol !== 0) {
      obj.integrationProtocol = integrationProtocolToJSON(message.integrationProtocol);
    }
    if (message.chain !== undefined) {
      obj.chain = Any.toJSON(message.chain);
    }
    return obj;
  },

  create(base?: DeepPartial<Chain>): Chain {
    return Chain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Chain>): Chain {
    const message = createBaseChain();
    message.id = object.id ?? "";
    message.codeId = object.codeId ?? "";
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.retryParams = (object.retryParams !== undefined && object.retryParams !== null)
      ? ChainRetryParams.fromPartial(object.retryParams)
      : undefined;
    message.integrationProtocol = object.integrationProtocol ?? 0;
    message.chain = (object.chain !== undefined && object.chain !== null) ? Any.fromPartial(object.chain) : undefined;
    return message;
  },
};

function createBaseChainRetryParams(): ChainRetryParams {
  return { executionPeriod: Long.UZERO, gracePeriod: Long.UZERO };
}

export const ChainRetryParams: MessageFns<ChainRetryParams> = {
  encode(message: ChainRetryParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.executionPeriod.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.executionPeriod.toString());
    }
    if (!message.gracePeriod.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.gracePeriod.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainRetryParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainRetryParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.executionPeriod = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gracePeriod = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainRetryParams {
    return {
      executionPeriod: isSet(object.executionPeriod) ? Long.fromValue(object.executionPeriod) : Long.UZERO,
      gracePeriod: isSet(object.gracePeriod) ? Long.fromValue(object.gracePeriod) : Long.UZERO,
    };
  },

  toJSON(message: ChainRetryParams): unknown {
    const obj: any = {};
    if (!message.executionPeriod.equals(Long.UZERO)) {
      obj.executionPeriod = (message.executionPeriod || Long.UZERO).toString();
    }
    if (!message.gracePeriod.equals(Long.UZERO)) {
      obj.gracePeriod = (message.gracePeriod || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ChainRetryParams>): ChainRetryParams {
    return ChainRetryParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainRetryParams>): ChainRetryParams {
    const message = createBaseChainRetryParams();
    message.executionPeriod = (object.executionPeriod !== undefined && object.executionPeriod !== null)
      ? Long.fromValue(object.executionPeriod)
      : Long.UZERO;
    message.gracePeriod = (object.gracePeriod !== undefined && object.gracePeriod !== null)
      ? Long.fromValue(object.gracePeriod)
      : Long.UZERO;
    return message;
  },
};

function createBaseInt3faceAsset(): Int3faceAsset {
  return { id: undefined, status: 0 };
}

export const Int3faceAsset: MessageFns<Int3faceAsset> = {
  encode(message: Int3faceAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int3faceAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt3faceAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int3faceAsset {
    return {
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: Int3faceAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<Int3faceAsset>): Int3faceAsset {
    return Int3faceAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int3faceAsset>): Int3faceAsset {
    const message = createBaseInt3faceAsset();
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseInt3faceChain(): Int3faceChain {
  return { assets: [] };
}

export const Int3faceChain: MessageFns<Int3faceChain> = {
  encode(message: Int3faceChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Int3faceAsset.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int3faceChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt3faceChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assets.push(Int3faceAsset.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int3faceChain {
    return {
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Int3faceAsset.fromJSON(e)) : [],
    };
  },

  toJSON(message: Int3faceChain): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Int3faceAsset.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Int3faceChain>): Int3faceChain {
    return Int3faceChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int3faceChain>): Int3faceChain {
    const message = createBaseInt3faceChain();
    message.assets = object.assets?.map((e) => Int3faceAsset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUtxoAsset(): UtxoAsset {
  return { id: undefined, status: 0 };
}

export const UtxoAsset: MessageFns<UtxoAsset> = {
  encode(message: UtxoAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UtxoAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUtxoAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UtxoAsset {
    return {
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: UtxoAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<UtxoAsset>): UtxoAsset {
    return UtxoAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UtxoAsset>): UtxoAsset {
    const message = createBaseUtxoAsset();
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseUtxoChain(): UtxoChain {
  return {
    signers: [],
    assets: [],
    vaultPubkey: "",
    vaultAddress: "",
    gasParams: undefined,
    confirmationsRequired: Long.UZERO,
    relayerParams: undefined,
    networkMode: 0,
  };
}

export const UtxoChain: MessageFns<UtxoChain> = {
  encode(message: UtxoChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signers) {
      Signer.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.assets) {
      UtxoAsset.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.vaultPubkey !== "") {
      writer.uint32(26).string(message.vaultPubkey);
    }
    if (message.vaultAddress !== "") {
      writer.uint32(34).string(message.vaultAddress);
    }
    if (message.gasParams !== undefined) {
      GasParams.encode(message.gasParams, writer.uint32(42).fork()).join();
    }
    if (!message.confirmationsRequired.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.confirmationsRequired.toString());
    }
    if (message.relayerParams !== undefined) {
      UtxoRelayerParams.encode(message.relayerParams, writer.uint32(58).fork()).join();
    }
    if (message.networkMode !== 0) {
      writer.uint32(64).int32(message.networkMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UtxoChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUtxoChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signers.push(Signer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assets.push(UtxoAsset.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vaultPubkey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vaultAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gasParams = GasParams.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.confirmationsRequired = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.relayerParams = UtxoRelayerParams.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.networkMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UtxoChain {
    return {
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => Signer.fromJSON(e)) : [],
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => UtxoAsset.fromJSON(e)) : [],
      vaultPubkey: isSet(object.vaultPubkey) ? globalThis.String(object.vaultPubkey) : "",
      vaultAddress: isSet(object.vaultAddress) ? globalThis.String(object.vaultAddress) : "",
      gasParams: isSet(object.gasParams) ? GasParams.fromJSON(object.gasParams) : undefined,
      confirmationsRequired: isSet(object.confirmationsRequired)
        ? Long.fromValue(object.confirmationsRequired)
        : Long.UZERO,
      relayerParams: isSet(object.relayerParams) ? UtxoRelayerParams.fromJSON(object.relayerParams) : undefined,
      networkMode: isSet(object.networkMode) ? chainNetworkModeFromJSON(object.networkMode) : 0,
    };
  },

  toJSON(message: UtxoChain): unknown {
    const obj: any = {};
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => UtxoAsset.toJSON(e));
    }
    if (message.vaultPubkey !== "") {
      obj.vaultPubkey = message.vaultPubkey;
    }
    if (message.vaultAddress !== "") {
      obj.vaultAddress = message.vaultAddress;
    }
    if (message.gasParams !== undefined) {
      obj.gasParams = GasParams.toJSON(message.gasParams);
    }
    if (!message.confirmationsRequired.equals(Long.UZERO)) {
      obj.confirmationsRequired = (message.confirmationsRequired || Long.UZERO).toString();
    }
    if (message.relayerParams !== undefined) {
      obj.relayerParams = UtxoRelayerParams.toJSON(message.relayerParams);
    }
    if (message.networkMode !== 0) {
      obj.networkMode = chainNetworkModeToJSON(message.networkMode);
    }
    return obj;
  },

  create(base?: DeepPartial<UtxoChain>): UtxoChain {
    return UtxoChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UtxoChain>): UtxoChain {
    const message = createBaseUtxoChain();
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.assets = object.assets?.map((e) => UtxoAsset.fromPartial(e)) || [];
    message.vaultPubkey = object.vaultPubkey ?? "";
    message.vaultAddress = object.vaultAddress ?? "";
    message.gasParams = (object.gasParams !== undefined && object.gasParams !== null)
      ? GasParams.fromPartial(object.gasParams)
      : undefined;
    message.confirmationsRequired =
      (object.confirmationsRequired !== undefined && object.confirmationsRequired !== null)
        ? Long.fromValue(object.confirmationsRequired)
        : Long.UZERO;
    message.relayerParams = (object.relayerParams !== undefined && object.relayerParams !== null)
      ? UtxoRelayerParams.fromPartial(object.relayerParams)
      : undefined;
    message.networkMode = object.networkMode ?? 0;
    return message;
  },
};

function createBaseUtxoRelayerParams(): UtxoRelayerParams {
  return { maxUtxoToSpend: Long.UZERO, maxSatoshiPerByte: Long.UZERO };
}

export const UtxoRelayerParams: MessageFns<UtxoRelayerParams> = {
  encode(message: UtxoRelayerParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.maxUtxoToSpend.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.maxUtxoToSpend.toString());
    }
    if (!message.maxSatoshiPerByte.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.maxSatoshiPerByte.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UtxoRelayerParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUtxoRelayerParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxUtxoToSpend = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxSatoshiPerByte = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UtxoRelayerParams {
    return {
      maxUtxoToSpend: isSet(object.maxUtxoToSpend) ? Long.fromValue(object.maxUtxoToSpend) : Long.UZERO,
      maxSatoshiPerByte: isSet(object.maxSatoshiPerByte) ? Long.fromValue(object.maxSatoshiPerByte) : Long.UZERO,
    };
  },

  toJSON(message: UtxoRelayerParams): unknown {
    const obj: any = {};
    if (!message.maxUtxoToSpend.equals(Long.UZERO)) {
      obj.maxUtxoToSpend = (message.maxUtxoToSpend || Long.UZERO).toString();
    }
    if (!message.maxSatoshiPerByte.equals(Long.UZERO)) {
      obj.maxSatoshiPerByte = (message.maxSatoshiPerByte || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UtxoRelayerParams>): UtxoRelayerParams {
    return UtxoRelayerParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UtxoRelayerParams>): UtxoRelayerParams {
    const message = createBaseUtxoRelayerParams();
    message.maxUtxoToSpend = (object.maxUtxoToSpend !== undefined && object.maxUtxoToSpend !== null)
      ? Long.fromValue(object.maxUtxoToSpend)
      : Long.UZERO;
    message.maxSatoshiPerByte = (object.maxSatoshiPerByte !== undefined && object.maxSatoshiPerByte !== null)
      ? Long.fromValue(object.maxSatoshiPerByte)
      : Long.UZERO;
    return message;
  },
};

function createBaseSmartContractAsset(): SmartContractAsset {
  return { id: undefined, status: 0, address: "", owned: false, destChainIds: [] };
}

export const SmartContractAsset: MessageFns<SmartContractAsset> = {
  encode(message: SmartContractAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.owned !== false) {
      writer.uint32(32).bool(message.owned);
    }
    for (const v of message.destChainIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartContractAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartContractAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.owned = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.destChainIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartContractAsset {
    return {
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      owned: isSet(object.owned) ? globalThis.Boolean(object.owned) : false,
      destChainIds: globalThis.Array.isArray(object?.destChainIds)
        ? object.destChainIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SmartContractAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.owned !== false) {
      obj.owned = message.owned;
    }
    if (message.destChainIds?.length) {
      obj.destChainIds = message.destChainIds;
    }
    return obj;
  },

  create(base?: DeepPartial<SmartContractAsset>): SmartContractAsset {
    return SmartContractAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartContractAsset>): SmartContractAsset {
    const message = createBaseSmartContractAsset();
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    message.address = object.address ?? "";
    message.owned = object.owned ?? false;
    message.destChainIds = object.destChainIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseSmartContractChain(): SmartContractChain {
  return {
    signers: [],
    assets: [],
    contractAddress: "",
    chainWallet: "",
    gasParams: undefined,
    confirmationsRequired: Long.UZERO,
  };
}

export const SmartContractChain: MessageFns<SmartContractChain> = {
  encode(message: SmartContractChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signers) {
      Signer.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.assets) {
      SmartContractAsset.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.chainWallet !== "") {
      writer.uint32(34).string(message.chainWallet);
    }
    if (message.gasParams !== undefined) {
      GasParams.encode(message.gasParams, writer.uint32(42).fork()).join();
    }
    if (!message.confirmationsRequired.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.confirmationsRequired.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartContractChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartContractChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signers.push(Signer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assets.push(SmartContractAsset.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chainWallet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gasParams = GasParams.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.confirmationsRequired = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartContractChain {
    return {
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => Signer.fromJSON(e)) : [],
      assets: globalThis.Array.isArray(object?.assets)
        ? object.assets.map((e: any) => SmartContractAsset.fromJSON(e))
        : [],
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      chainWallet: isSet(object.chainWallet) ? globalThis.String(object.chainWallet) : "",
      gasParams: isSet(object.gasParams) ? GasParams.fromJSON(object.gasParams) : undefined,
      confirmationsRequired: isSet(object.confirmationsRequired)
        ? Long.fromValue(object.confirmationsRequired)
        : Long.UZERO,
    };
  },

  toJSON(message: SmartContractChain): unknown {
    const obj: any = {};
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => SmartContractAsset.toJSON(e));
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.chainWallet !== "") {
      obj.chainWallet = message.chainWallet;
    }
    if (message.gasParams !== undefined) {
      obj.gasParams = GasParams.toJSON(message.gasParams);
    }
    if (!message.confirmationsRequired.equals(Long.UZERO)) {
      obj.confirmationsRequired = (message.confirmationsRequired || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SmartContractChain>): SmartContractChain {
    return SmartContractChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartContractChain>): SmartContractChain {
    const message = createBaseSmartContractChain();
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.assets = object.assets?.map((e) => SmartContractAsset.fromPartial(e)) || [];
    message.contractAddress = object.contractAddress ?? "";
    message.chainWallet = object.chainWallet ?? "";
    message.gasParams = (object.gasParams !== undefined && object.gasParams !== null)
      ? GasParams.fromPartial(object.gasParams)
      : undefined;
    message.confirmationsRequired =
      (object.confirmationsRequired !== undefined && object.confirmationsRequired !== null)
        ? Long.fromValue(object.confirmationsRequired)
        : Long.UZERO;
    return message;
  },
};

function createBaseGasParams(): GasParams {
  return { gasAsset: undefined, gasFees: [] };
}

export const GasParams: MessageFns<GasParams> = {
  encode(message: GasParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gasAsset !== undefined) {
      AssetID.encode(message.gasAsset, writer.uint32(10).fork()).join();
    }
    for (const v of message.gasFees) {
      GasFee.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GasParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGasParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gasAsset = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gasFees.push(GasFee.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GasParams {
    return {
      gasAsset: isSet(object.gasAsset) ? AssetID.fromJSON(object.gasAsset) : undefined,
      gasFees: globalThis.Array.isArray(object?.gasFees) ? object.gasFees.map((e: any) => GasFee.fromJSON(e)) : [],
    };
  },

  toJSON(message: GasParams): unknown {
    const obj: any = {};
    if (message.gasAsset !== undefined) {
      obj.gasAsset = AssetID.toJSON(message.gasAsset);
    }
    if (message.gasFees?.length) {
      obj.gasFees = message.gasFees.map((e) => GasFee.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GasParams>): GasParams {
    return GasParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GasParams>): GasParams {
    const message = createBaseGasParams();
    message.gasAsset = (object.gasAsset !== undefined && object.gasAsset !== null)
      ? AssetID.fromPartial(object.gasAsset)
      : undefined;
    message.gasFees = object.gasFees?.map((e) => GasFee.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGasFee(): GasFee {
  return { type: 0, amount: "" };
}

export const GasFee: MessageFns<GasFee> = {
  encode(message: GasFee, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GasFee {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGasFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GasFee {
    return {
      type: isSet(object.type) ? gasFeeTypeFromJSON(object.type) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: GasFee): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = gasFeeTypeToJSON(message.type);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GasFee>): GasFee {
    return GasFee.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GasFee>): GasFee {
    const message = createBaseGasFee();
    message.type = object.type ?? 0;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseIbcAssetSwap(): IbcAssetSwap {
  return { enabled: false, contractAddress: "", sourceDenom: "", destDenom: "" };
}

export const IbcAssetSwap: MessageFns<IbcAssetSwap> = {
  encode(message: IbcAssetSwap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.contractAddress !== "") {
      writer.uint32(18).string(message.contractAddress);
    }
    if (message.sourceDenom !== "") {
      writer.uint32(26).string(message.sourceDenom);
    }
    if (message.destDenom !== "") {
      writer.uint32(34).string(message.destDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IbcAssetSwap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIbcAssetSwap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IbcAssetSwap {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      sourceDenom: isSet(object.sourceDenom) ? globalThis.String(object.sourceDenom) : "",
      destDenom: isSet(object.destDenom) ? globalThis.String(object.destDenom) : "",
    };
  },

  toJSON(message: IbcAssetSwap): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.sourceDenom !== "") {
      obj.sourceDenom = message.sourceDenom;
    }
    if (message.destDenom !== "") {
      obj.destDenom = message.destDenom;
    }
    return obj;
  },

  create(base?: DeepPartial<IbcAssetSwap>): IbcAssetSwap {
    return IbcAssetSwap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IbcAssetSwap>): IbcAssetSwap {
    const message = createBaseIbcAssetSwap();
    message.enabled = object.enabled ?? false;
    message.contractAddress = object.contractAddress ?? "";
    message.sourceDenom = object.sourceDenom ?? "";
    message.destDenom = object.destDenom ?? "";
    return message;
  },
};

function createBaseIbcAsset(): IbcAsset {
  return { id: undefined, status: 0, localIbcDenom: "", externalIbcDenom: "", swap: undefined };
}

export const IbcAsset: MessageFns<IbcAsset> = {
  encode(message: IbcAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.localIbcDenom !== "") {
      writer.uint32(26).string(message.localIbcDenom);
    }
    if (message.externalIbcDenom !== "") {
      writer.uint32(34).string(message.externalIbcDenom);
    }
    if (message.swap !== undefined) {
      IbcAssetSwap.encode(message.swap, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IbcAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIbcAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.localIbcDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalIbcDenom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.swap = IbcAssetSwap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IbcAsset {
    return {
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
      localIbcDenom: isSet(object.localIbcDenom) ? globalThis.String(object.localIbcDenom) : "",
      externalIbcDenom: isSet(object.externalIbcDenom) ? globalThis.String(object.externalIbcDenom) : "",
      swap: isSet(object.swap) ? IbcAssetSwap.fromJSON(object.swap) : undefined,
    };
  },

  toJSON(message: IbcAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    if (message.localIbcDenom !== "") {
      obj.localIbcDenom = message.localIbcDenom;
    }
    if (message.externalIbcDenom !== "") {
      obj.externalIbcDenom = message.externalIbcDenom;
    }
    if (message.swap !== undefined) {
      obj.swap = IbcAssetSwap.toJSON(message.swap);
    }
    return obj;
  },

  create(base?: DeepPartial<IbcAsset>): IbcAsset {
    return IbcAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IbcAsset>): IbcAsset {
    const message = createBaseIbcAsset();
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    message.localIbcDenom = object.localIbcDenom ?? "";
    message.externalIbcDenom = object.externalIbcDenom ?? "";
    message.swap = (object.swap !== undefined && object.swap !== null)
      ? IbcAssetSwap.fromPartial(object.swap)
      : undefined;
    return message;
  },
};

function createBaseIbcChain(): IbcChain {
  return { bech32Prefix: "", channelId: "", portId: "", timeout: Long.UZERO, assets: [], chainWallet: "" };
}

export const IbcChain: MessageFns<IbcChain> = {
  encode(message: IbcChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bech32Prefix !== "") {
      writer.uint32(10).string(message.bech32Prefix);
    }
    if (message.channelId !== "") {
      writer.uint32(18).string(message.channelId);
    }
    if (message.portId !== "") {
      writer.uint32(26).string(message.portId);
    }
    if (!message.timeout.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.timeout.toString());
    }
    for (const v of message.assets) {
      IbcAsset.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.chainWallet !== "") {
      writer.uint32(50).string(message.chainWallet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IbcChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIbcChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bech32Prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.portId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timeout = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assets.push(IbcAsset.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chainWallet = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IbcChain {
    return {
      bech32Prefix: isSet(object.bech32Prefix) ? globalThis.String(object.bech32Prefix) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      portId: isSet(object.portId) ? globalThis.String(object.portId) : "",
      timeout: isSet(object.timeout) ? Long.fromValue(object.timeout) : Long.UZERO,
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => IbcAsset.fromJSON(e)) : [],
      chainWallet: isSet(object.chainWallet) ? globalThis.String(object.chainWallet) : "",
    };
  },

  toJSON(message: IbcChain): unknown {
    const obj: any = {};
    if (message.bech32Prefix !== "") {
      obj.bech32Prefix = message.bech32Prefix;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.portId !== "") {
      obj.portId = message.portId;
    }
    if (!message.timeout.equals(Long.UZERO)) {
      obj.timeout = (message.timeout || Long.UZERO).toString();
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => IbcAsset.toJSON(e));
    }
    if (message.chainWallet !== "") {
      obj.chainWallet = message.chainWallet;
    }
    return obj;
  },

  create(base?: DeepPartial<IbcChain>): IbcChain {
    return IbcChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IbcChain>): IbcChain {
    const message = createBaseIbcChain();
    message.bech32Prefix = object.bech32Prefix ?? "";
    message.channelId = object.channelId ?? "";
    message.portId = object.portId ?? "";
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Long.fromValue(object.timeout)
      : Long.UZERO;
    message.assets = object.assets?.map((e) => IbcAsset.fromPartial(e)) || [];
    message.chainWallet = object.chainWallet ?? "";
    return message;
  },
};

function createBaseNttAsset(): NttAsset {
  return {
    id: undefined,
    status: 0,
    nttManagerAddress: "",
    externalNttManagerAddress: "",
    externalTokenAddress: "",
    nttTransceivers: [],
    externalNttTransceivers: [],
  };
}

export const NttAsset: MessageFns<NttAsset> = {
  encode(message: NttAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.nttManagerAddress !== "") {
      writer.uint32(26).string(message.nttManagerAddress);
    }
    if (message.externalNttManagerAddress !== "") {
      writer.uint32(34).string(message.externalNttManagerAddress);
    }
    if (message.externalTokenAddress !== "") {
      writer.uint32(42).string(message.externalTokenAddress);
    }
    for (const v of message.nttTransceivers) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.externalNttTransceivers) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NttAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNttAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nttManagerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalNttManagerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalTokenAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nttTransceivers.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.externalNttTransceivers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NttAsset {
    return {
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
      nttManagerAddress: isSet(object.nttManagerAddress) ? globalThis.String(object.nttManagerAddress) : "",
      externalNttManagerAddress: isSet(object.externalNttManagerAddress)
        ? globalThis.String(object.externalNttManagerAddress)
        : "",
      externalTokenAddress: isSet(object.externalTokenAddress) ? globalThis.String(object.externalTokenAddress) : "",
      nttTransceivers: globalThis.Array.isArray(object?.nttTransceivers)
        ? object.nttTransceivers.map((e: any) => globalThis.String(e))
        : [],
      externalNttTransceivers: globalThis.Array.isArray(object?.externalNttTransceivers)
        ? object.externalNttTransceivers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: NttAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    if (message.nttManagerAddress !== "") {
      obj.nttManagerAddress = message.nttManagerAddress;
    }
    if (message.externalNttManagerAddress !== "") {
      obj.externalNttManagerAddress = message.externalNttManagerAddress;
    }
    if (message.externalTokenAddress !== "") {
      obj.externalTokenAddress = message.externalTokenAddress;
    }
    if (message.nttTransceivers?.length) {
      obj.nttTransceivers = message.nttTransceivers;
    }
    if (message.externalNttTransceivers?.length) {
      obj.externalNttTransceivers = message.externalNttTransceivers;
    }
    return obj;
  },

  create(base?: DeepPartial<NttAsset>): NttAsset {
    return NttAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NttAsset>): NttAsset {
    const message = createBaseNttAsset();
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    message.nttManagerAddress = object.nttManagerAddress ?? "";
    message.externalNttManagerAddress = object.externalNttManagerAddress ?? "";
    message.externalTokenAddress = object.externalTokenAddress ?? "";
    message.nttTransceivers = object.nttTransceivers?.map((e) => e) || [];
    message.externalNttTransceivers = object.externalNttTransceivers?.map((e) => e) || [];
    return message;
  },
};

function createBaseNttChain(): NttChain {
  return {
    forwardingChainId: "",
    signers: [],
    assets: [],
    chainWallet: "",
    wormholeProgram: "",
    nttChainId: Long.UZERO,
  };
}

export const NttChain: MessageFns<NttChain> = {
  encode(message: NttChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.forwardingChainId !== "") {
      writer.uint32(10).string(message.forwardingChainId);
    }
    for (const v of message.signers) {
      Signer.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.assets) {
      NttAsset.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.chainWallet !== "") {
      writer.uint32(34).string(message.chainWallet);
    }
    if (message.wormholeProgram !== "") {
      writer.uint32(42).string(message.wormholeProgram);
    }
    if (!message.nttChainId.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.nttChainId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NttChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNttChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.forwardingChainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signers.push(Signer.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assets.push(NttAsset.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chainWallet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.wormholeProgram = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nttChainId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NttChain {
    return {
      forwardingChainId: isSet(object.forwardingChainId) ? globalThis.String(object.forwardingChainId) : "",
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => Signer.fromJSON(e)) : [],
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => NttAsset.fromJSON(e)) : [],
      chainWallet: isSet(object.chainWallet) ? globalThis.String(object.chainWallet) : "",
      wormholeProgram: isSet(object.wormholeProgram) ? globalThis.String(object.wormholeProgram) : "",
      nttChainId: isSet(object.nttChainId) ? Long.fromValue(object.nttChainId) : Long.UZERO,
    };
  },

  toJSON(message: NttChain): unknown {
    const obj: any = {};
    if (message.forwardingChainId !== "") {
      obj.forwardingChainId = message.forwardingChainId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => NttAsset.toJSON(e));
    }
    if (message.chainWallet !== "") {
      obj.chainWallet = message.chainWallet;
    }
    if (message.wormholeProgram !== "") {
      obj.wormholeProgram = message.wormholeProgram;
    }
    if (!message.nttChainId.equals(Long.UZERO)) {
      obj.nttChainId = (message.nttChainId || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<NttChain>): NttChain {
    return NttChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NttChain>): NttChain {
    const message = createBaseNttChain();
    message.forwardingChainId = object.forwardingChainId ?? "";
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.assets = object.assets?.map((e) => NttAsset.fromPartial(e)) || [];
    message.chainWallet = object.chainWallet ?? "";
    message.wormholeProgram = object.wormholeProgram ?? "";
    message.nttChainId = (object.nttChainId !== undefined && object.nttChainId !== null)
      ? Long.fromValue(object.nttChainId)
      : Long.UZERO;
    return message;
  },
};

function createBasePaymentAsset(): PaymentAsset {
  return { id: undefined, status: 0 };
}

export const PaymentAsset: MessageFns<PaymentAsset> = {
  encode(message: PaymentAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentAsset {
    return {
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: PaymentAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<PaymentAsset>): PaymentAsset {
    return PaymentAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaymentAsset>): PaymentAsset {
    const message = createBasePaymentAsset();
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBasePaymentChain(): PaymentChain {
  return {
    signers: [],
    assets: [],
    vaultPubkey: "",
    vaultAddress: "",
    gasParams: undefined,
    confirmationsRequired: Long.UZERO,
  };
}

export const PaymentChain: MessageFns<PaymentChain> = {
  encode(message: PaymentChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signers) {
      Signer.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.assets) {
      PaymentAsset.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.vaultPubkey !== "") {
      writer.uint32(26).string(message.vaultPubkey);
    }
    if (message.vaultAddress !== "") {
      writer.uint32(34).string(message.vaultAddress);
    }
    if (message.gasParams !== undefined) {
      GasParams.encode(message.gasParams, writer.uint32(42).fork()).join();
    }
    if (!message.confirmationsRequired.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.confirmationsRequired.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signers.push(Signer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assets.push(PaymentAsset.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vaultPubkey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vaultAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gasParams = GasParams.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.confirmationsRequired = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentChain {
    return {
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => Signer.fromJSON(e)) : [],
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => PaymentAsset.fromJSON(e)) : [],
      vaultPubkey: isSet(object.vaultPubkey) ? globalThis.String(object.vaultPubkey) : "",
      vaultAddress: isSet(object.vaultAddress) ? globalThis.String(object.vaultAddress) : "",
      gasParams: isSet(object.gasParams) ? GasParams.fromJSON(object.gasParams) : undefined,
      confirmationsRequired: isSet(object.confirmationsRequired)
        ? Long.fromValue(object.confirmationsRequired)
        : Long.UZERO,
    };
  },

  toJSON(message: PaymentChain): unknown {
    const obj: any = {};
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => PaymentAsset.toJSON(e));
    }
    if (message.vaultPubkey !== "") {
      obj.vaultPubkey = message.vaultPubkey;
    }
    if (message.vaultAddress !== "") {
      obj.vaultAddress = message.vaultAddress;
    }
    if (message.gasParams !== undefined) {
      obj.gasParams = GasParams.toJSON(message.gasParams);
    }
    if (!message.confirmationsRequired.equals(Long.UZERO)) {
      obj.confirmationsRequired = (message.confirmationsRequired || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PaymentChain>): PaymentChain {
    return PaymentChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PaymentChain>): PaymentChain {
    const message = createBasePaymentChain();
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.assets = object.assets?.map((e) => PaymentAsset.fromPartial(e)) || [];
    message.vaultPubkey = object.vaultPubkey ?? "";
    message.vaultAddress = object.vaultAddress ?? "";
    message.gasParams = (object.gasParams !== undefined && object.gasParams !== null)
      ? GasParams.fromPartial(object.gasParams)
      : undefined;
    message.confirmationsRequired =
      (object.confirmationsRequired !== undefined && object.confirmationsRequired !== null)
        ? Long.fromValue(object.confirmationsRequired)
        : Long.UZERO;
    return message;
  },
};

function createBaseInboundTransfer(): InboundTransfer {
  return {
    externalId: "",
    externalHeight: Long.UZERO,
    destAddr: "",
    assetId: undefined,
    amount: "",
    voters: [],
    status: 0,
    destChainId: "",
    srcChainId: "",
    finalizedTxHash: "",
    fees: undefined,
    votesNeeded: Long.UZERO,
  };
}

export const InboundTransfer: MessageFns<InboundTransfer> = {
  encode(message: InboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalId !== "") {
      writer.uint32(10).string(message.externalId);
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.externalHeight.toString());
    }
    if (message.destAddr !== "") {
      writer.uint32(26).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(34).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    for (const v of message.voters) {
      writer.uint32(50).string(v!);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.destChainId !== "") {
      writer.uint32(66).string(message.destChainId);
    }
    if (message.srcChainId !== "") {
      writer.uint32(74).string(message.srcChainId);
    }
    if (message.finalizedTxHash !== "") {
      writer.uint32(82).string(message.finalizedTxHash);
    }
    if (message.fees !== undefined) {
      TransferFees.encode(message.fees, writer.uint32(90).fork()).join();
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      writer.uint32(96).uint64(message.votesNeeded.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.externalHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.finalizedTxHash = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.fees = TransferFees.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.votesNeeded = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundTransfer {
    return {
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      externalHeight: isSet(object.externalHeight) ? Long.fromValue(object.externalHeight) : Long.UZERO,
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      status: isSet(object.status) ? inboundTransferStatusFromJSON(object.status) : 0,
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      finalizedTxHash: isSet(object.finalizedTxHash) ? globalThis.String(object.finalizedTxHash) : "",
      fees: isSet(object.fees) ? TransferFees.fromJSON(object.fees) : undefined,
      votesNeeded: isSet(object.votesNeeded) ? Long.fromValue(object.votesNeeded) : Long.UZERO,
    };
  },

  toJSON(message: InboundTransfer): unknown {
    const obj: any = {};
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      obj.externalHeight = (message.externalHeight || Long.UZERO).toString();
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.status !== 0) {
      obj.status = inboundTransferStatusToJSON(message.status);
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.finalizedTxHash !== "") {
      obj.finalizedTxHash = message.finalizedTxHash;
    }
    if (message.fees !== undefined) {
      obj.fees = TransferFees.toJSON(message.fees);
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      obj.votesNeeded = (message.votesNeeded || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<InboundTransfer>): InboundTransfer {
    return InboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InboundTransfer>): InboundTransfer {
    const message = createBaseInboundTransfer();
    message.externalId = object.externalId ?? "";
    message.externalHeight = (object.externalHeight !== undefined && object.externalHeight !== null)
      ? Long.fromValue(object.externalHeight)
      : Long.UZERO;
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.voters = object.voters?.map((e) => e) || [];
    message.status = object.status ?? 0;
    message.destChainId = object.destChainId ?? "";
    message.srcChainId = object.srcChainId ?? "";
    message.finalizedTxHash = object.finalizedTxHash ?? "";
    message.fees = (object.fees !== undefined && object.fees !== null)
      ? TransferFees.fromPartial(object.fees)
      : undefined;
    message.votesNeeded = (object.votesNeeded !== undefined && object.votesNeeded !== null)
      ? Long.fromValue(object.votesNeeded)
      : Long.UZERO;
    return message;
  },
};

function createBaseKeyGen(): KeyGen {
  return { keygenId: "", participantsAddrs: [], poolPk: "", voters: [], finalized: false };
}

export const KeyGen: MessageFns<KeyGen> = {
  encode(message: KeyGen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keygenId !== "") {
      writer.uint32(10).string(message.keygenId);
    }
    for (const v of message.participantsAddrs) {
      writer.uint32(18).string(v!);
    }
    if (message.poolPk !== "") {
      writer.uint32(26).string(message.poolPk);
    }
    for (const v of message.voters) {
      writer.uint32(34).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyGen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyGen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participantsAddrs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.poolPk = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyGen {
    return {
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
      participantsAddrs: globalThis.Array.isArray(object?.participantsAddrs)
        ? object.participantsAddrs.map((e: any) => globalThis.String(e))
        : [],
      poolPk: isSet(object.poolPk) ? globalThis.String(object.poolPk) : "",
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: KeyGen): unknown {
    const obj: any = {};
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    if (message.participantsAddrs?.length) {
      obj.participantsAddrs = message.participantsAddrs;
    }
    if (message.poolPk !== "") {
      obj.poolPk = message.poolPk;
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyGen>): KeyGen {
    return KeyGen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyGen>): KeyGen {
    const message = createBaseKeyGen();
    message.keygenId = object.keygenId ?? "";
    message.participantsAddrs = object.participantsAddrs?.map((e) => e) || [];
    message.poolPk = object.poolPk ?? "";
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseTssVaultAddress(): TssVaultAddress {
  return { chainId: "", address: "" };
}

export const TssVaultAddress: MessageFns<TssVaultAddress> = {
  encode(message: TssVaultAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TssVaultAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTssVaultAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TssVaultAddress {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: TssVaultAddress): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<TssVaultAddress>): TssVaultAddress {
    return TssVaultAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TssVaultAddress>): TssVaultAddress {
    const message = createBaseTssVaultAddress();
    message.chainId = object.chainId ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseKeyGenResult(): KeyGenResult {
  return { keygenId: "", participantsAddrs: [] };
}

export const KeyGenResult: MessageFns<KeyGenResult> = {
  encode(message: KeyGenResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keygenId !== "") {
      writer.uint32(10).string(message.keygenId);
    }
    for (const v of message.participantsAddrs) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyGenResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyGenResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participantsAddrs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyGenResult {
    return {
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
      participantsAddrs: globalThis.Array.isArray(object?.participantsAddrs)
        ? object.participantsAddrs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: KeyGenResult): unknown {
    const obj: any = {};
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    if (message.participantsAddrs?.length) {
      obj.participantsAddrs = message.participantsAddrs;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyGenResult>): KeyGenResult {
    return KeyGenResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyGenResult>): KeyGenResult {
    const message = createBaseKeyGenResult();
    message.keygenId = object.keygenId ?? "";
    message.participantsAddrs = object.participantsAddrs?.map((e) => e) || [];
    return message;
  },
};

function createBaseContractFee(): ContractFee {
  return { type: "", fee: "" };
}

export const ContractFee: MessageFns<ContractFee> = {
  encode(message: ContractFee, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.fee !== "") {
      writer.uint32(18).string(message.fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractFee {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractFee {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      fee: isSet(object.fee) ? globalThis.String(object.fee) : "",
    };
  },

  toJSON(message: ContractFee): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.fee !== "") {
      obj.fee = message.fee;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractFee>): ContractFee {
    return ContractFee.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractFee>): ContractFee {
    const message = createBaseContractFee();
    message.type = object.type ?? "";
    message.fee = object.fee ?? "";
    return message;
  },
};

function createBaseTonContractParams(): TonContractParams {
  return { signers: [], fees: [], contractAddress: "", contractStatus: 0 };
}

export const TonContractParams: MessageFns<TonContractParams> = {
  encode(message: TonContractParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signers) {
      SignerPair.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.contractStatus !== 0) {
      writer.uint32(32).int32(message.contractStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TonContractParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTonContractParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signers.push(SignerPair.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.contractStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TonContractParams {
    return {
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => SignerPair.fromJSON(e)) : [],
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      contractStatus: isSet(object.contractStatus) ? contractStatusFromJSON(object.contractStatus) : 0,
    };
  },

  toJSON(message: TonContractParams): unknown {
    const obj: any = {};
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => SignerPair.toJSON(e));
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.contractStatus !== 0) {
      obj.contractStatus = contractStatusToJSON(message.contractStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<TonContractParams>): TonContractParams {
    return TonContractParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TonContractParams>): TonContractParams {
    const message = createBaseTonContractParams();
    message.signers = object.signers?.map((e) => SignerPair.fromPartial(e)) || [];
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.contractAddress = object.contractAddress ?? "";
    message.contractStatus = object.contractStatus ?? 0;
    return message;
  },
};

function createBaseSolanaContractParams(): SolanaContractParams {
  return { signers: [], fees: [], contractAddress: "", contractStatus: 0, assetParams: [] };
}

export const SolanaContractParams: MessageFns<SolanaContractParams> = {
  encode(message: SolanaContractParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signers) {
      SignerPair.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.contractStatus !== 0) {
      writer.uint32(32).int32(message.contractStatus);
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolanaContractParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolanaContractParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signers.push(SignerPair.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.contractStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolanaContractParams {
    return {
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => SignerPair.fromJSON(e)) : [],
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      contractStatus: isSet(object.contractStatus) ? contractStatusFromJSON(object.contractStatus) : 0,
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SolanaContractParams): unknown {
    const obj: any = {};
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => SignerPair.toJSON(e));
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.contractStatus !== 0) {
      obj.contractStatus = contractStatusToJSON(message.contractStatus);
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SolanaContractParams>): SolanaContractParams {
    return SolanaContractParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolanaContractParams>): SolanaContractParams {
    const message = createBaseSolanaContractParams();
    message.signers = object.signers?.map((e) => SignerPair.fromPartial(e)) || [];
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.contractAddress = object.contractAddress ?? "";
    message.contractStatus = object.contractStatus ?? 0;
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBaseContractParams(): BaseContractParams {
  return { signers: [], fees: [], assetParams: [], contractAddress: "", contractStatus: 0 };
}

export const BaseContractParams: MessageFns<BaseContractParams> = {
  encode(message: BaseContractParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signers) {
      SignerPair.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.contractAddress !== "") {
      writer.uint32(34).string(message.contractAddress);
    }
    if (message.contractStatus !== 0) {
      writer.uint32(40).int32(message.contractStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseContractParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseContractParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signers.push(SignerPair.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.contractStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaseContractParams {
    return {
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => SignerPair.fromJSON(e)) : [],
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      contractStatus: isSet(object.contractStatus) ? contractStatusFromJSON(object.contractStatus) : 0,
    };
  },

  toJSON(message: BaseContractParams): unknown {
    const obj: any = {};
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => SignerPair.toJSON(e));
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.contractStatus !== 0) {
      obj.contractStatus = contractStatusToJSON(message.contractStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<BaseContractParams>): BaseContractParams {
    return BaseContractParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BaseContractParams>): BaseContractParams {
    const message = createBaseBaseContractParams();
    message.signers = object.signers?.map((e) => SignerPair.fromPartial(e)) || [];
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    message.contractAddress = object.contractAddress ?? "";
    message.contractStatus = object.contractStatus ?? 0;
    return message;
  },
};

function createBaseContractAssetParams(): ContractAssetParams {
  return {
    denom: "",
    address: "",
    minTransferAmount: "",
    destinationChainIds: [],
    owned: false,
    whitelisted: false,
    assetId: undefined,
  };
}

export const ContractAssetParams: MessageFns<ContractAssetParams> = {
  encode(message: ContractAssetParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(26).string(message.minTransferAmount);
    }
    for (const v of message.destinationChainIds) {
      writer.uint32(34).string(v!);
    }
    if (message.owned !== false) {
      writer.uint32(40).bool(message.owned);
    }
    if (message.whitelisted !== false) {
      writer.uint32(48).bool(message.whitelisted);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAssetParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAssetParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinationChainIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.owned = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.whitelisted = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAssetParams {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
      destinationChainIds: globalThis.Array.isArray(object?.destinationChainIds)
        ? object.destinationChainIds.map((e: any) => globalThis.String(e))
        : [],
      owned: isSet(object.owned) ? globalThis.Boolean(object.owned) : false,
      whitelisted: isSet(object.whitelisted) ? globalThis.Boolean(object.whitelisted) : false,
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
    };
  },

  toJSON(message: ContractAssetParams): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    if (message.destinationChainIds?.length) {
      obj.destinationChainIds = message.destinationChainIds;
    }
    if (message.owned !== false) {
      obj.owned = message.owned;
    }
    if (message.whitelisted !== false) {
      obj.whitelisted = message.whitelisted;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAssetParams>): ContractAssetParams {
    return ContractAssetParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAssetParams>): ContractAssetParams {
    const message = createBaseContractAssetParams();
    message.denom = object.denom ?? "";
    message.address = object.address ?? "";
    message.minTransferAmount = object.minTransferAmount ?? "";
    message.destinationChainIds = object.destinationChainIds?.map((e) => e) || [];
    message.owned = object.owned ?? false;
    message.whitelisted = object.whitelisted ?? false;
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    return message;
  },
};

function createBaseContractAssetId(): ContractAssetId {
  return { denom: "", address: "" };
}

export const ContractAssetId: MessageFns<ContractAssetId> = {
  encode(message: ContractAssetId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAssetId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAssetId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAssetId {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: ContractAssetId): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAssetId>): ContractAssetId {
    return ContractAssetId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAssetId>): ContractAssetId {
    const message = createBaseContractAssetId();
    message.denom = object.denom ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseSignerPair(): SignerPair {
  return { int3Addr: "", chainAddr: "" };
}

export const SignerPair: MessageFns<SignerPair> = {
  encode(message: SignerPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.int3Addr !== "") {
      writer.uint32(10).string(message.int3Addr);
    }
    if (message.chainAddr !== "") {
      writer.uint32(18).string(message.chainAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignerPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignerPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.int3Addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainAddr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignerPair {
    return {
      int3Addr: isSet(object.int3Addr) ? globalThis.String(object.int3Addr) : "",
      chainAddr: isSet(object.chainAddr) ? globalThis.String(object.chainAddr) : "",
    };
  },

  toJSON(message: SignerPair): unknown {
    const obj: any = {};
    if (message.int3Addr !== "") {
      obj.int3Addr = message.int3Addr;
    }
    if (message.chainAddr !== "") {
      obj.chainAddr = message.chainAddr;
    }
    return obj;
  },

  create(base?: DeepPartial<SignerPair>): SignerPair {
    return SignerPair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignerPair>): SignerPair {
    const message = createBaseSignerPair();
    message.int3Addr = object.int3Addr ?? "";
    message.chainAddr = object.chainAddr ?? "";
    return message;
  },
};

function createBaseContractSigners(): ContractSigners {
  return { chainId: "", signers: [] };
}

export const ContractSigners: MessageFns<ContractSigners> = {
  encode(message: ContractSigners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    for (const v of message.signers) {
      SignerPair.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractSigners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractSigners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signers.push(SignerPair.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractSigners {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => SignerPair.fromJSON(e)) : [],
    };
  },

  toJSON(message: ContractSigners): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => SignerPair.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ContractSigners>): ContractSigners {
    return ContractSigners.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractSigners>): ContractSigners {
    const message = createBaseContractSigners();
    message.chainId = object.chainId ?? "";
    message.signers = object.signers?.map((e) => SignerPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContractSignersUpdate(): ContractSignersUpdate {
  return { updateId: "", signers: [], voters: [], finalized: false };
}

export const ContractSignersUpdate: MessageFns<ContractSignersUpdate> = {
  encode(message: ContractSignersUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    for (const v of message.signers) {
      ContractSigners.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.voters) {
      writer.uint32(26).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(32).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractSignersUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractSignersUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signers.push(ContractSigners.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractSignersUpdate {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => ContractSigners.fromJSON(e))
        : [],
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: ContractSignersUpdate): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => ContractSigners.toJSON(e));
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractSignersUpdate>): ContractSignersUpdate {
    return ContractSignersUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractSignersUpdate>): ContractSignersUpdate {
    const message = createBaseContractSignersUpdate();
    message.updateId = object.updateId ?? "";
    message.signers = object.signers?.map((e) => ContractSigners.fromPartial(e)) || [];
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseContractSignersUpdateResult(): ContractSignersUpdateResult {
  return { updateId: "", signers: [] };
}

export const ContractSignersUpdateResult: MessageFns<ContractSignersUpdateResult> = {
  encode(message: ContractSignersUpdateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    for (const v of message.signers) {
      ContractSigners.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractSignersUpdateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractSignersUpdateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signers.push(ContractSigners.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractSignersUpdateResult {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => ContractSigners.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ContractSignersUpdateResult): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => ContractSigners.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ContractSignersUpdateResult>): ContractSignersUpdateResult {
    return ContractSignersUpdateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractSignersUpdateResult>): ContractSignersUpdateResult {
    const message = createBaseContractSignersUpdateResult();
    message.updateId = object.updateId ?? "";
    message.signers = object.signers?.map((e) => ContractSigners.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContractParamsUpdate(): ContractParamsUpdate {
  return {
    updateId: "",
    chainId: "",
    contractAddress: "",
    minTransferAmount: "",
    fees: [],
    voters: [],
    finalized: false,
    assetParams: [],
  };
}

export const ContractParamsUpdate: MessageFns<ContractParamsUpdate> = {
  encode(message: ContractParamsUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(34).string(message.minTransferAmount);
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.voters) {
      writer.uint32(50).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(56).bool(message.finalized);
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractParamsUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractParamsUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractParamsUpdate {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ContractParamsUpdate): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ContractParamsUpdate>): ContractParamsUpdate {
    return ContractParamsUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractParamsUpdate>): ContractParamsUpdate {
    const message = createBaseContractParamsUpdate();
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.minTransferAmount = object.minTransferAmount ?? "";
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContractParamsUpdateResult(): ContractParamsUpdateResult {
  return { updateId: "", chainId: "", contractAddress: "", minTransferAmount: "", fees: [], assetParams: [] };
}

export const ContractParamsUpdateResult: MessageFns<ContractParamsUpdateResult> = {
  encode(message: ContractParamsUpdateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(34).string(message.minTransferAmount);
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractParamsUpdateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractParamsUpdateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractParamsUpdateResult {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ContractParamsUpdateResult): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ContractParamsUpdateResult>): ContractParamsUpdateResult {
    return ContractParamsUpdateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractParamsUpdateResult>): ContractParamsUpdateResult {
    const message = createBaseContractParamsUpdateResult();
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.minTransferAmount = object.minTransferAmount ?? "";
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContractStatusUpdate(): ContractStatusUpdate {
  return { updateId: "", chainId: "", status: 0, voters: [], finalized: false };
}

export const ContractStatusUpdate: MessageFns<ContractStatusUpdate> = {
  encode(message: ContractStatusUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    for (const v of message.voters) {
      writer.uint32(34).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractStatusUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractStatusUpdate {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? contractStatusFromJSON(object.status) : 0,
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: ContractStatusUpdate): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = contractStatusToJSON(message.status);
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractStatusUpdate>): ContractStatusUpdate {
    return ContractStatusUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractStatusUpdate>): ContractStatusUpdate {
    const message = createBaseContractStatusUpdate();
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseContractStatusUpdateResult(): ContractStatusUpdateResult {
  return { updateId: "", chainId: "", status: 0 };
}

export const ContractStatusUpdateResult: MessageFns<ContractStatusUpdateResult> = {
  encode(message: ContractStatusUpdateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractStatusUpdateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractStatusUpdateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractStatusUpdateResult {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? contractStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: ContractStatusUpdateResult): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = contractStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractStatusUpdateResult>): ContractStatusUpdateResult {
    return ContractStatusUpdateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractStatusUpdateResult>): ContractStatusUpdateResult {
    const message = createBaseContractStatusUpdateResult();
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseContractPrune(): ContractPrune {
  return { pruneId: "", chainId: "", pruneBefore: Long.UZERO, voters: [], finalized: false };
}

export const ContractPrune: MessageFns<ContractPrune> = {
  encode(message: ContractPrune, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pruneId !== "") {
      writer.uint32(10).string(message.pruneId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pruneBefore.toString());
    }
    for (const v of message.voters) {
      writer.uint32(34).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractPrune {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractPrune();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pruneId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractPrune {
    return {
      pruneId: isSet(object.pruneId) ? globalThis.String(object.pruneId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: ContractPrune): unknown {
    const obj: any = {};
    if (message.pruneId !== "") {
      obj.pruneId = message.pruneId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractPrune>): ContractPrune {
    return ContractPrune.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractPrune>): ContractPrune {
    const message = createBaseContractPrune();
    message.pruneId = object.pruneId ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseContractPruneResult(): ContractPruneResult {
  return { pruneId: "", chainId: "", pruneBefore: Long.UZERO };
}

export const ContractPruneResult: MessageFns<ContractPruneResult> = {
  encode(message: ContractPruneResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pruneId !== "") {
      writer.uint32(10).string(message.pruneId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pruneBefore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractPruneResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractPruneResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pruneId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractPruneResult {
    return {
      pruneId: isSet(object.pruneId) ? globalThis.String(object.pruneId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
    };
  },

  toJSON(message: ContractPruneResult): unknown {
    const obj: any = {};
    if (message.pruneId !== "") {
      obj.pruneId = message.pruneId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ContractPruneResult>): ContractPruneResult {
    return ContractPruneResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractPruneResult>): ContractPruneResult {
    const message = createBaseContractPruneResult();
    message.pruneId = object.pruneId ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    return message;
  },
};

function createBaseContractUpgrade(): ContractUpgrade {
  return {
    upgradeId: "",
    chainId: "",
    contractData: "",
    contractCode: "",
    voters: [],
    finalized: false,
    upgradeData: undefined,
  };
}

export const ContractUpgrade: MessageFns<ContractUpgrade> = {
  encode(message: ContractUpgrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upgradeId !== "") {
      writer.uint32(10).string(message.upgradeId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.contractData !== "") {
      writer.uint32(26).string(message.contractData);
    }
    if (message.contractCode !== "") {
      writer.uint32(34).string(message.contractCode);
    }
    for (const v of message.voters) {
      writer.uint32(42).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(48).bool(message.finalized);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractUpgrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractUpgrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upgradeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractData = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractUpgrade {
    return {
      upgradeId: isSet(object.upgradeId) ? globalThis.String(object.upgradeId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractData: isSet(object.contractData) ? globalThis.String(object.contractData) : "",
      contractCode: isSet(object.contractCode) ? globalThis.String(object.contractCode) : "",
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
    };
  },

  toJSON(message: ContractUpgrade): unknown {
    const obj: any = {};
    if (message.upgradeId !== "") {
      obj.upgradeId = message.upgradeId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractData !== "") {
      obj.contractData = message.contractData;
    }
    if (message.contractCode !== "") {
      obj.contractCode = message.contractCode;
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractUpgrade>): ContractUpgrade {
    return ContractUpgrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractUpgrade>): ContractUpgrade {
    const message = createBaseContractUpgrade();
    message.upgradeId = object.upgradeId ?? "";
    message.chainId = object.chainId ?? "";
    message.contractData = object.contractData ?? "";
    message.contractCode = object.contractCode ?? "";
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    return message;
  },
};

function createBaseContractUpgradeResult(): ContractUpgradeResult {
  return { upgradeId: "", chainId: "", contractData: "", contractCode: "", upgradeData: undefined };
}

export const ContractUpgradeResult: MessageFns<ContractUpgradeResult> = {
  encode(message: ContractUpgradeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upgradeId !== "") {
      writer.uint32(10).string(message.upgradeId);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.contractData !== "") {
      writer.uint32(26).string(message.contractData);
    }
    if (message.contractCode !== "") {
      writer.uint32(34).string(message.contractCode);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractUpgradeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractUpgradeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upgradeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractData = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractUpgradeResult {
    return {
      upgradeId: isSet(object.upgradeId) ? globalThis.String(object.upgradeId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractData: isSet(object.contractData) ? globalThis.String(object.contractData) : "",
      contractCode: isSet(object.contractCode) ? globalThis.String(object.contractCode) : "",
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
    };
  },

  toJSON(message: ContractUpgradeResult): unknown {
    const obj: any = {};
    if (message.upgradeId !== "") {
      obj.upgradeId = message.upgradeId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractData !== "") {
      obj.contractData = message.contractData;
    }
    if (message.contractCode !== "") {
      obj.contractCode = message.contractCode;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractUpgradeResult>): ContractUpgradeResult {
    return ContractUpgradeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractUpgradeResult>): ContractUpgradeResult {
    const message = createBaseContractUpgradeResult();
    message.upgradeId = object.upgradeId ?? "";
    message.chainId = object.chainId ?? "";
    message.contractData = object.contractData ?? "";
    message.contractCode = object.contractCode ?? "";
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    return message;
  },
};

function createBaseContractUpgradeData(): ContractUpgradeData {
  return { tonData: undefined, solanaData: undefined, baseData: undefined };
}

export const ContractUpgradeData: MessageFns<ContractUpgradeData> = {
  encode(message: ContractUpgradeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tonData !== undefined) {
      TonContractUpgradeData.encode(message.tonData, writer.uint32(10).fork()).join();
    }
    if (message.solanaData !== undefined) {
      SolanaContractUpgradeData.encode(message.solanaData, writer.uint32(18).fork()).join();
    }
    if (message.baseData !== undefined) {
      BaseContractUpgradeData.encode(message.baseData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractUpgradeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractUpgradeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tonData = TonContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.solanaData = SolanaContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseData = BaseContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractUpgradeData {
    return {
      tonData: isSet(object.tonData) ? TonContractUpgradeData.fromJSON(object.tonData) : undefined,
      solanaData: isSet(object.solanaData) ? SolanaContractUpgradeData.fromJSON(object.solanaData) : undefined,
      baseData: isSet(object.baseData) ? BaseContractUpgradeData.fromJSON(object.baseData) : undefined,
    };
  },

  toJSON(message: ContractUpgradeData): unknown {
    const obj: any = {};
    if (message.tonData !== undefined) {
      obj.tonData = TonContractUpgradeData.toJSON(message.tonData);
    }
    if (message.solanaData !== undefined) {
      obj.solanaData = SolanaContractUpgradeData.toJSON(message.solanaData);
    }
    if (message.baseData !== undefined) {
      obj.baseData = BaseContractUpgradeData.toJSON(message.baseData);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractUpgradeData>): ContractUpgradeData {
    return ContractUpgradeData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractUpgradeData>): ContractUpgradeData {
    const message = createBaseContractUpgradeData();
    message.tonData = (object.tonData !== undefined && object.tonData !== null)
      ? TonContractUpgradeData.fromPartial(object.tonData)
      : undefined;
    message.solanaData = (object.solanaData !== undefined && object.solanaData !== null)
      ? SolanaContractUpgradeData.fromPartial(object.solanaData)
      : undefined;
    message.baseData = (object.baseData !== undefined && object.baseData !== null)
      ? BaseContractUpgradeData.fromPartial(object.baseData)
      : undefined;
    return message;
  },
};

function createBaseTonContractUpgradeData(): TonContractUpgradeData {
  return { contractData: "", contractCode: "" };
}

export const TonContractUpgradeData: MessageFns<TonContractUpgradeData> = {
  encode(message: TonContractUpgradeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractData !== "") {
      writer.uint32(10).string(message.contractData);
    }
    if (message.contractCode !== "") {
      writer.uint32(18).string(message.contractCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TonContractUpgradeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTonContractUpgradeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractData = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TonContractUpgradeData {
    return {
      contractData: isSet(object.contractData) ? globalThis.String(object.contractData) : "",
      contractCode: isSet(object.contractCode) ? globalThis.String(object.contractCode) : "",
    };
  },

  toJSON(message: TonContractUpgradeData): unknown {
    const obj: any = {};
    if (message.contractData !== "") {
      obj.contractData = message.contractData;
    }
    if (message.contractCode !== "") {
      obj.contractCode = message.contractCode;
    }
    return obj;
  },

  create(base?: DeepPartial<TonContractUpgradeData>): TonContractUpgradeData {
    return TonContractUpgradeData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TonContractUpgradeData>): TonContractUpgradeData {
    const message = createBaseTonContractUpgradeData();
    message.contractData = object.contractData ?? "";
    message.contractCode = object.contractCode ?? "";
    return message;
  },
};

function createBaseSolanaContractUpgradeData(): SolanaContractUpgradeData {
  return { contractAddress: "", methodDescriptor: new Uint8Array(0) };
}

export const SolanaContractUpgradeData: MessageFns<SolanaContractUpgradeData> = {
  encode(message: SolanaContractUpgradeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.methodDescriptor.length !== 0) {
      writer.uint32(18).bytes(message.methodDescriptor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolanaContractUpgradeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolanaContractUpgradeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.methodDescriptor = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolanaContractUpgradeData {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      methodDescriptor: isSet(object.methodDescriptor) ? bytesFromBase64(object.methodDescriptor) : new Uint8Array(0),
    };
  },

  toJSON(message: SolanaContractUpgradeData): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.methodDescriptor.length !== 0) {
      obj.methodDescriptor = base64FromBytes(message.methodDescriptor);
    }
    return obj;
  },

  create(base?: DeepPartial<SolanaContractUpgradeData>): SolanaContractUpgradeData {
    return SolanaContractUpgradeData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolanaContractUpgradeData>): SolanaContractUpgradeData {
    const message = createBaseSolanaContractUpgradeData();
    message.contractAddress = object.contractAddress ?? "";
    message.methodDescriptor = object.methodDescriptor ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBaseContractUpgradeData(): BaseContractUpgradeData {
  return { contractAddress: "" };
}

export const BaseContractUpgradeData: MessageFns<BaseContractUpgradeData> = {
  encode(message: BaseContractUpgradeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseContractUpgradeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseContractUpgradeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaseContractUpgradeData {
    return { contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "" };
  },

  toJSON(message: BaseContractUpgradeData): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<BaseContractUpgradeData>): BaseContractUpgradeData {
    return BaseContractUpgradeData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BaseContractUpgradeData>): BaseContractUpgradeData {
    const message = createBaseBaseContractUpgradeData();
    message.contractAddress = object.contractAddress ?? "";
    return message;
  },
};

function createBaseIbcForwardingParams(): IbcForwardingParams {
  return { chainId: "", ibcChannelId: "", ibcPortId: "", ibcTimeout: Long.UZERO, assetSwaps: [] };
}

export const IbcForwardingParams: MessageFns<IbcForwardingParams> = {
  encode(message: IbcForwardingParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.ibcChannelId !== "") {
      writer.uint32(18).string(message.ibcChannelId);
    }
    if (message.ibcPortId !== "") {
      writer.uint32(26).string(message.ibcPortId);
    }
    if (!message.ibcTimeout.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.ibcTimeout.toString());
    }
    for (const v of message.assetSwaps) {
      AssetSwap.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IbcForwardingParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIbcForwardingParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ibcChannelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ibcPortId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ibcTimeout = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetSwaps.push(AssetSwap.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IbcForwardingParams {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      ibcChannelId: isSet(object.ibcChannelId) ? globalThis.String(object.ibcChannelId) : "",
      ibcPortId: isSet(object.ibcPortId) ? globalThis.String(object.ibcPortId) : "",
      ibcTimeout: isSet(object.ibcTimeout) ? Long.fromValue(object.ibcTimeout) : Long.UZERO,
      assetSwaps: globalThis.Array.isArray(object?.assetSwaps)
        ? object.assetSwaps.map((e: any) => AssetSwap.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IbcForwardingParams): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.ibcChannelId !== "") {
      obj.ibcChannelId = message.ibcChannelId;
    }
    if (message.ibcPortId !== "") {
      obj.ibcPortId = message.ibcPortId;
    }
    if (!message.ibcTimeout.equals(Long.UZERO)) {
      obj.ibcTimeout = (message.ibcTimeout || Long.UZERO).toString();
    }
    if (message.assetSwaps?.length) {
      obj.assetSwaps = message.assetSwaps.map((e) => AssetSwap.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IbcForwardingParams>): IbcForwardingParams {
    return IbcForwardingParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IbcForwardingParams>): IbcForwardingParams {
    const message = createBaseIbcForwardingParams();
    message.chainId = object.chainId ?? "";
    message.ibcChannelId = object.ibcChannelId ?? "";
    message.ibcPortId = object.ibcPortId ?? "";
    message.ibcTimeout = (object.ibcTimeout !== undefined && object.ibcTimeout !== null)
      ? Long.fromValue(object.ibcTimeout)
      : Long.UZERO;
    message.assetSwaps = object.assetSwaps?.map((e) => AssetSwap.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssetSwap(): AssetSwap {
  return { enabled: false, contractAddress: "", sourceDenom: "", destDenom: "" };
}

export const AssetSwap: MessageFns<AssetSwap> = {
  encode(message: AssetSwap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.contractAddress !== "") {
      writer.uint32(18).string(message.contractAddress);
    }
    if (message.sourceDenom !== "") {
      writer.uint32(26).string(message.sourceDenom);
    }
    if (message.destDenom !== "") {
      writer.uint32(34).string(message.destDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetSwap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetSwap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetSwap {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      sourceDenom: isSet(object.sourceDenom) ? globalThis.String(object.sourceDenom) : "",
      destDenom: isSet(object.destDenom) ? globalThis.String(object.destDenom) : "",
    };
  },

  toJSON(message: AssetSwap): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.sourceDenom !== "") {
      obj.sourceDenom = message.sourceDenom;
    }
    if (message.destDenom !== "") {
      obj.destDenom = message.destDenom;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetSwap>): AssetSwap {
    return AssetSwap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetSwap>): AssetSwap {
    const message = createBaseAssetSwap();
    message.enabled = object.enabled ?? false;
    message.contractAddress = object.contractAddress ?? "";
    message.sourceDenom = object.sourceDenom ?? "";
    message.destDenom = object.destDenom ?? "";
    return message;
  },
};

function createBaseContractAddAssets(): ContractAddAssets {
  return { id: "", chainId: "", newAssets: [], voters: [], finalized: false };
}

export const ContractAddAssets: MessageFns<ContractAddAssets> = {
  encode(message: ContractAddAssets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.newAssets) {
      ContractAssetParams.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.voters) {
      writer.uint32(34).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAddAssets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAddAssets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAssets.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAddAssets {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      newAssets: globalThis.Array.isArray(object?.newAssets)
        ? object.newAssets.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: ContractAddAssets): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.newAssets?.length) {
      obj.newAssets = message.newAssets.map((e) => ContractAssetParams.toJSON(e));
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAddAssets>): ContractAddAssets {
    return ContractAddAssets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAddAssets>): ContractAddAssets {
    const message = createBaseContractAddAssets();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.newAssets = object.newAssets?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseContractAddAssetsResult(): ContractAddAssetsResult {
  return { id: "", chainId: "", newAssets: [] };
}

export const ContractAddAssetsResult: MessageFns<ContractAddAssetsResult> = {
  encode(message: ContractAddAssetsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.newAssets) {
      ContractAssetParams.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAddAssetsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAddAssetsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAssets.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAddAssetsResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      newAssets: globalThis.Array.isArray(object?.newAssets)
        ? object.newAssets.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ContractAddAssetsResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.newAssets?.length) {
      obj.newAssets = message.newAssets.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAddAssetsResult>): ContractAddAssetsResult {
    return ContractAddAssetsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAddAssetsResult>): ContractAddAssetsResult {
    const message = createBaseContractAddAssetsResult();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.newAssets = object.newAssets?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContractDeleteAsset(): ContractDeleteAsset {
  return { id: "", chainId: "", assetAddress: "", voters: [], finalized: false };
}

export const ContractDeleteAsset: MessageFns<ContractDeleteAsset> = {
  encode(message: ContractDeleteAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetAddress !== "") {
      writer.uint32(26).string(message.assetAddress);
    }
    for (const v of message.voters) {
      writer.uint32(34).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractDeleteAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractDeleteAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractDeleteAsset {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetAddress: isSet(object.assetAddress) ? globalThis.String(object.assetAddress) : "",
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: ContractDeleteAsset): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetAddress !== "") {
      obj.assetAddress = message.assetAddress;
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractDeleteAsset>): ContractDeleteAsset {
    return ContractDeleteAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractDeleteAsset>): ContractDeleteAsset {
    const message = createBaseContractDeleteAsset();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.assetAddress = object.assetAddress ?? "";
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseContractDeleteAssetResult(): ContractDeleteAssetResult {
  return { id: "", chainId: "", assetAddress: "" };
}

export const ContractDeleteAssetResult: MessageFns<ContractDeleteAssetResult> = {
  encode(message: ContractDeleteAssetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetAddress !== "") {
      writer.uint32(26).string(message.assetAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractDeleteAssetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractDeleteAssetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractDeleteAssetResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetAddress: isSet(object.assetAddress) ? globalThis.String(object.assetAddress) : "",
    };
  },

  toJSON(message: ContractDeleteAssetResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetAddress !== "") {
      obj.assetAddress = message.assetAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractDeleteAssetResult>): ContractDeleteAssetResult {
    return ContractDeleteAssetResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractDeleteAssetResult>): ContractDeleteAssetResult {
    const message = createBaseContractDeleteAssetResult();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.assetAddress = object.assetAddress ?? "";
    return message;
  },
};

function createBaseContractAssetsWhitelist(): ContractAssetsWhitelist {
  return { id: "", chainId: "", asset: undefined, voters: [], finalized: false };
}

export const ContractAssetsWhitelist: MessageFns<ContractAssetsWhitelist> = {
  encode(message: ContractAssetsWhitelist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    for (const v of message.voters) {
      writer.uint32(34).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAssetsWhitelist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAssetsWhitelist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAssetsWhitelist {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: ContractAssetsWhitelist): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAssetsWhitelist>): ContractAssetsWhitelist {
    return ContractAssetsWhitelist.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAssetsWhitelist>): ContractAssetsWhitelist {
    const message = createBaseContractAssetsWhitelist();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseContractAssetsWhitelistResult(): ContractAssetsWhitelistResult {
  return { id: "", chainId: "", asset: undefined };
}

export const ContractAssetsWhitelistResult: MessageFns<ContractAssetsWhitelistResult> = {
  encode(message: ContractAssetsWhitelistResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAssetsWhitelistResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAssetsWhitelistResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAssetsWhitelistResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: ContractAssetsWhitelistResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAssetsWhitelistResult>): ContractAssetsWhitelistResult {
    return ContractAssetsWhitelistResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAssetsWhitelistResult>): ContractAssetsWhitelistResult {
    const message = createBaseContractAssetsWhitelistResult();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseContractAssetsUnwhitelist(): ContractAssetsUnwhitelist {
  return { id: "", chainId: "", asset: undefined, voters: [], finalized: false };
}

export const ContractAssetsUnwhitelist: MessageFns<ContractAssetsUnwhitelist> = {
  encode(message: ContractAssetsUnwhitelist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    for (const v of message.voters) {
      writer.uint32(34).string(v!);
    }
    if (message.finalized !== false) {
      writer.uint32(40).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAssetsUnwhitelist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAssetsUnwhitelist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.voters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAssetsUnwhitelist {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
      voters: globalThis.Array.isArray(object?.voters) ? object.voters.map((e: any) => globalThis.String(e)) : [],
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: ContractAssetsUnwhitelist): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    if (message.voters?.length) {
      obj.voters = message.voters;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAssetsUnwhitelist>): ContractAssetsUnwhitelist {
    return ContractAssetsUnwhitelist.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAssetsUnwhitelist>): ContractAssetsUnwhitelist {
    const message = createBaseContractAssetsUnwhitelist();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    message.voters = object.voters?.map((e) => e) || [];
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseContractAssetsUnwhitelistResult(): ContractAssetsUnwhitelistResult {
  return { id: "", chainId: "", asset: undefined };
}

export const ContractAssetsUnwhitelistResult: MessageFns<ContractAssetsUnwhitelistResult> = {
  encode(message: ContractAssetsUnwhitelistResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractAssetsUnwhitelistResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractAssetsUnwhitelistResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractAssetsUnwhitelistResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: ContractAssetsUnwhitelistResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractAssetsUnwhitelistResult>): ContractAssetsUnwhitelistResult {
    return ContractAssetsUnwhitelistResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractAssetsUnwhitelistResult>): ContractAssetsUnwhitelistResult {
    const message = createBaseContractAssetsUnwhitelistResult();
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseOutboundTransfer(): OutboundTransfer {
  return {
    status: 0,
    transferProtocol: 0,
    srcChainId: "",
    destChainId: "",
    destAddr: "",
    assetId: undefined,
    amount: "",
    creationTimestamp: Long.UZERO,
    lastUpdateTimestamp: Long.UZERO,
    votes: undefined,
    inboundContext: undefined,
    txHash: "",
    sender: "",
    fees: undefined,
    finalizedTxHash: "",
    votesNeeded: Long.UZERO,
  };
}

export const OutboundTransfer: MessageFns<OutboundTransfer> = {
  encode(message: OutboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.transferProtocol !== 0) {
      writer.uint32(16).int32(message.transferProtocol);
    }
    if (message.srcChainId !== "") {
      writer.uint32(26).string(message.srcChainId);
    }
    if (message.destChainId !== "") {
      writer.uint32(34).string(message.destChainId);
    }
    if (message.destAddr !== "") {
      writer.uint32(42).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(50).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(58).string(message.amount);
    }
    if (!message.creationTimestamp.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.creationTimestamp.toString());
    }
    if (!message.lastUpdateTimestamp.equals(Long.UZERO)) {
      writer.uint32(72).uint64(message.lastUpdateTimestamp.toString());
    }
    if (message.votes !== undefined) {
      OutboundTransferVotes.encode(message.votes, writer.uint32(82).fork()).join();
    }
    if (message.inboundContext !== undefined) {
      InboundTransferContext.encode(message.inboundContext, writer.uint32(90).fork()).join();
    }
    if (message.txHash !== "") {
      writer.uint32(98).string(message.txHash);
    }
    if (message.sender !== "") {
      writer.uint32(106).string(message.sender);
    }
    if (message.fees !== undefined) {
      TransferFees.encode(message.fees, writer.uint32(114).fork()).join();
    }
    if (message.finalizedTxHash !== "") {
      writer.uint32(122).string(message.finalizedTxHash);
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      writer.uint32(128).uint64(message.votesNeeded.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transferProtocol = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.creationTimestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.lastUpdateTimestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.votes = OutboundTransferVotes.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.inboundContext = InboundTransferContext.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.fees = TransferFees.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.finalizedTxHash = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.votesNeeded = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundTransfer {
    return {
      status: isSet(object.status) ? outboundTransferStatusFromJSON(object.status) : 0,
      transferProtocol: isSet(object.transferProtocol) ? transferProtocolFromJSON(object.transferProtocol) : 0,
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      creationTimestamp: isSet(object.creationTimestamp) ? Long.fromValue(object.creationTimestamp) : Long.UZERO,
      lastUpdateTimestamp: isSet(object.lastUpdateTimestamp) ? Long.fromValue(object.lastUpdateTimestamp) : Long.UZERO,
      votes: isSet(object.votes) ? OutboundTransferVotes.fromJSON(object.votes) : undefined,
      inboundContext: isSet(object.inboundContext) ? InboundTransferContext.fromJSON(object.inboundContext) : undefined,
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      fees: isSet(object.fees) ? TransferFees.fromJSON(object.fees) : undefined,
      finalizedTxHash: isSet(object.finalizedTxHash) ? globalThis.String(object.finalizedTxHash) : "",
      votesNeeded: isSet(object.votesNeeded) ? Long.fromValue(object.votesNeeded) : Long.UZERO,
    };
  },

  toJSON(message: OutboundTransfer): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = outboundTransferStatusToJSON(message.status);
    }
    if (message.transferProtocol !== 0) {
      obj.transferProtocol = transferProtocolToJSON(message.transferProtocol);
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (!message.creationTimestamp.equals(Long.UZERO)) {
      obj.creationTimestamp = (message.creationTimestamp || Long.UZERO).toString();
    }
    if (!message.lastUpdateTimestamp.equals(Long.UZERO)) {
      obj.lastUpdateTimestamp = (message.lastUpdateTimestamp || Long.UZERO).toString();
    }
    if (message.votes !== undefined) {
      obj.votes = OutboundTransferVotes.toJSON(message.votes);
    }
    if (message.inboundContext !== undefined) {
      obj.inboundContext = InboundTransferContext.toJSON(message.inboundContext);
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.fees !== undefined) {
      obj.fees = TransferFees.toJSON(message.fees);
    }
    if (message.finalizedTxHash !== "") {
      obj.finalizedTxHash = message.finalizedTxHash;
    }
    if (!message.votesNeeded.equals(Long.UZERO)) {
      obj.votesNeeded = (message.votesNeeded || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<OutboundTransfer>): OutboundTransfer {
    return OutboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutboundTransfer>): OutboundTransfer {
    const message = createBaseOutboundTransfer();
    message.status = object.status ?? 0;
    message.transferProtocol = object.transferProtocol ?? 0;
    message.srcChainId = object.srcChainId ?? "";
    message.destChainId = object.destChainId ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.creationTimestamp = (object.creationTimestamp !== undefined && object.creationTimestamp !== null)
      ? Long.fromValue(object.creationTimestamp)
      : Long.UZERO;
    message.lastUpdateTimestamp = (object.lastUpdateTimestamp !== undefined && object.lastUpdateTimestamp !== null)
      ? Long.fromValue(object.lastUpdateTimestamp)
      : Long.UZERO;
    message.votes = (object.votes !== undefined && object.votes !== null)
      ? OutboundTransferVotes.fromPartial(object.votes)
      : undefined;
    message.inboundContext = (object.inboundContext !== undefined && object.inboundContext !== null)
      ? InboundTransferContext.fromPartial(object.inboundContext)
      : undefined;
    message.txHash = object.txHash ?? "";
    message.sender = object.sender ?? "";
    message.fees = (object.fees !== undefined && object.fees !== null)
      ? TransferFees.fromPartial(object.fees)
      : undefined;
    message.finalizedTxHash = object.finalizedTxHash ?? "";
    message.votesNeeded = (object.votesNeeded !== undefined && object.votesNeeded !== null)
      ? Long.fromValue(object.votesNeeded)
      : Long.UZERO;
    return message;
  },
};

function createBaseInboundTransferContext(): InboundTransferContext {
  return { transferId: "" };
}

export const InboundTransferContext: MessageFns<InboundTransferContext> = {
  encode(message: InboundTransferContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InboundTransferContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundTransferContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundTransferContext {
    return { transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "" };
  },

  toJSON(message: InboundTransferContext): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    return obj;
  },

  create(base?: DeepPartial<InboundTransferContext>): InboundTransferContext {
    return InboundTransferContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InboundTransferContext>): InboundTransferContext {
    const message = createBaseInboundTransferContext();
    message.transferId = object.transferId ?? "";
    return message;
  },
};

function createBaseOutboundTransferVotes(): OutboundTransferVotes {
  return { finalized: [], failed: [] };
}

export const OutboundTransferVotes: MessageFns<OutboundTransferVotes> = {
  encode(message: OutboundTransferVotes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.finalized) {
      VoteOnFinalization.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.failed) {
      VoteOnFailure.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundTransferVotes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundTransferVotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalized.push(VoteOnFinalization.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.failed.push(VoteOnFailure.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundTransferVotes {
    return {
      finalized: globalThis.Array.isArray(object?.finalized)
        ? object.finalized.map((e: any) => VoteOnFinalization.fromJSON(e))
        : [],
      failed: globalThis.Array.isArray(object?.failed) ? object.failed.map((e: any) => VoteOnFailure.fromJSON(e)) : [],
    };
  },

  toJSON(message: OutboundTransferVotes): unknown {
    const obj: any = {};
    if (message.finalized?.length) {
      obj.finalized = message.finalized.map((e) => VoteOnFinalization.toJSON(e));
    }
    if (message.failed?.length) {
      obj.failed = message.failed.map((e) => VoteOnFailure.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OutboundTransferVotes>): OutboundTransferVotes {
    return OutboundTransferVotes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutboundTransferVotes>): OutboundTransferVotes {
    const message = createBaseOutboundTransferVotes();
    message.finalized = object.finalized?.map((e) => VoteOnFinalization.fromPartial(e)) || [];
    message.failed = object.failed?.map((e) => VoteOnFailure.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVoteOnFinalization(): VoteOnFinalization {
  return { voter: "", broadcastedTxHash: "" };
}

export const VoteOnFinalization: MessageFns<VoteOnFinalization> = {
  encode(message: VoteOnFinalization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.voter !== "") {
      writer.uint32(10).string(message.voter);
    }
    if (message.broadcastedTxHash !== "") {
      writer.uint32(18).string(message.broadcastedTxHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteOnFinalization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteOnFinalization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.voter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.broadcastedTxHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteOnFinalization {
    return {
      voter: isSet(object.voter) ? globalThis.String(object.voter) : "",
      broadcastedTxHash: isSet(object.broadcastedTxHash) ? globalThis.String(object.broadcastedTxHash) : "",
    };
  },

  toJSON(message: VoteOnFinalization): unknown {
    const obj: any = {};
    if (message.voter !== "") {
      obj.voter = message.voter;
    }
    if (message.broadcastedTxHash !== "") {
      obj.broadcastedTxHash = message.broadcastedTxHash;
    }
    return obj;
  },

  create(base?: DeepPartial<VoteOnFinalization>): VoteOnFinalization {
    return VoteOnFinalization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VoteOnFinalization>): VoteOnFinalization {
    const message = createBaseVoteOnFinalization();
    message.voter = object.voter ?? "";
    message.broadcastedTxHash = object.broadcastedTxHash ?? "";
    return message;
  },
};

function createBaseVoteOnFailure(): VoteOnFailure {
  return { voter: "" };
}

export const VoteOnFailure: MessageFns<VoteOnFailure> = {
  encode(message: VoteOnFailure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.voter !== "") {
      writer.uint32(10).string(message.voter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteOnFailure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteOnFailure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.voter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoteOnFailure {
    return { voter: isSet(object.voter) ? globalThis.String(object.voter) : "" };
  },

  toJSON(message: VoteOnFailure): unknown {
    const obj: any = {};
    if (message.voter !== "") {
      obj.voter = message.voter;
    }
    return obj;
  },

  create(base?: DeepPartial<VoteOnFailure>): VoteOnFailure {
    return VoteOnFailure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VoteOnFailure>): VoteOnFailure {
    const message = createBaseVoteOnFailure();
    message.voter = object.voter ?? "";
    return message;
  },
};

function createBaseBridgeProposalVotes(): BridgeProposalVotes {
  return { chainId: "", expectedVoters: [], finalized: [], failed: [] };
}

export const BridgeProposalVotes: MessageFns<BridgeProposalVotes> = {
  encode(message: BridgeProposalVotes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    for (const v of message.expectedVoters) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.finalized) {
      VoteOnFinalization.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.failed) {
      VoteOnFailure.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BridgeProposalVotes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBridgeProposalVotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expectedVoters.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.finalized.push(VoteOnFinalization.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.failed.push(VoteOnFailure.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BridgeProposalVotes {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      expectedVoters: globalThis.Array.isArray(object?.expectedVoters)
        ? object.expectedVoters.map((e: any) => globalThis.String(e))
        : [],
      finalized: globalThis.Array.isArray(object?.finalized)
        ? object.finalized.map((e: any) => VoteOnFinalization.fromJSON(e))
        : [],
      failed: globalThis.Array.isArray(object?.failed) ? object.failed.map((e: any) => VoteOnFailure.fromJSON(e)) : [],
    };
  },

  toJSON(message: BridgeProposalVotes): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.expectedVoters?.length) {
      obj.expectedVoters = message.expectedVoters;
    }
    if (message.finalized?.length) {
      obj.finalized = message.finalized.map((e) => VoteOnFinalization.toJSON(e));
    }
    if (message.failed?.length) {
      obj.failed = message.failed.map((e) => VoteOnFailure.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BridgeProposalVotes>): BridgeProposalVotes {
    return BridgeProposalVotes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BridgeProposalVotes>): BridgeProposalVotes {
    const message = createBaseBridgeProposalVotes();
    message.chainId = object.chainId ?? "";
    message.expectedVoters = object.expectedVoters?.map((e) => e) || [];
    message.finalized = object.finalized?.map((e) => VoteOnFinalization.fromPartial(e)) || [];
    message.failed = object.failed?.map((e) => VoteOnFailure.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBridgeProposal(): BridgeProposal {
  return { proposalId: Long.UZERO, status: 0, votes: [] };
}

export const BridgeProposal: MessageFns<BridgeProposal> = {
  encode(message: BridgeProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.proposalId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.proposalId.toString());
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.votes) {
      BridgeProposalVotes.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BridgeProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBridgeProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.proposalId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.votes.push(BridgeProposalVotes.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BridgeProposal {
    return {
      proposalId: isSet(object.proposalId) ? Long.fromValue(object.proposalId) : Long.UZERO,
      status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,
      votes: globalThis.Array.isArray(object?.votes)
        ? object.votes.map((e: any) => BridgeProposalVotes.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BridgeProposal): unknown {
    const obj: any = {};
    if (!message.proposalId.equals(Long.UZERO)) {
      obj.proposalId = (message.proposalId || Long.UZERO).toString();
    }
    if (message.status !== 0) {
      obj.status = proposalStatusToJSON(message.status);
    }
    if (message.votes?.length) {
      obj.votes = message.votes.map((e) => BridgeProposalVotes.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BridgeProposal>): BridgeProposal {
    return BridgeProposal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BridgeProposal>): BridgeProposal {
    const message = createBaseBridgeProposal();
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.UZERO;
    message.status = object.status ?? 0;
    message.votes = object.votes?.map((e) => BridgeProposalVotes.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBridgeTimeouts(): BridgeTimeouts {
  return {
    govTimeoutSeconds: Long.UZERO,
    inboundTransferTimeoutSeconds: Long.UZERO,
    outboundTransferTimeoutSeconds: Long.UZERO,
  };
}

export const BridgeTimeouts: MessageFns<BridgeTimeouts> = {
  encode(message: BridgeTimeouts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.govTimeoutSeconds.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.govTimeoutSeconds.toString());
    }
    if (!message.inboundTransferTimeoutSeconds.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.inboundTransferTimeoutSeconds.toString());
    }
    if (!message.outboundTransferTimeoutSeconds.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.outboundTransferTimeoutSeconds.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BridgeTimeouts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBridgeTimeouts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.govTimeoutSeconds = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inboundTransferTimeoutSeconds = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outboundTransferTimeoutSeconds = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BridgeTimeouts {
    return {
      govTimeoutSeconds: isSet(object.govTimeoutSeconds) ? Long.fromValue(object.govTimeoutSeconds) : Long.UZERO,
      inboundTransferTimeoutSeconds: isSet(object.inboundTransferTimeoutSeconds)
        ? Long.fromValue(object.inboundTransferTimeoutSeconds)
        : Long.UZERO,
      outboundTransferTimeoutSeconds: isSet(object.outboundTransferTimeoutSeconds)
        ? Long.fromValue(object.outboundTransferTimeoutSeconds)
        : Long.UZERO,
    };
  },

  toJSON(message: BridgeTimeouts): unknown {
    const obj: any = {};
    if (!message.govTimeoutSeconds.equals(Long.UZERO)) {
      obj.govTimeoutSeconds = (message.govTimeoutSeconds || Long.UZERO).toString();
    }
    if (!message.inboundTransferTimeoutSeconds.equals(Long.UZERO)) {
      obj.inboundTransferTimeoutSeconds = (message.inboundTransferTimeoutSeconds || Long.UZERO).toString();
    }
    if (!message.outboundTransferTimeoutSeconds.equals(Long.UZERO)) {
      obj.outboundTransferTimeoutSeconds = (message.outboundTransferTimeoutSeconds || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<BridgeTimeouts>): BridgeTimeouts {
    return BridgeTimeouts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BridgeTimeouts>): BridgeTimeouts {
    const message = createBaseBridgeTimeouts();
    message.govTimeoutSeconds = (object.govTimeoutSeconds !== undefined && object.govTimeoutSeconds !== null)
      ? Long.fromValue(object.govTimeoutSeconds)
      : Long.UZERO;
    message.inboundTransferTimeoutSeconds =
      (object.inboundTransferTimeoutSeconds !== undefined && object.inboundTransferTimeoutSeconds !== null)
        ? Long.fromValue(object.inboundTransferTimeoutSeconds)
        : Long.UZERO;
    message.outboundTransferTimeoutSeconds =
      (object.outboundTransferTimeoutSeconds !== undefined && object.outboundTransferTimeoutSeconds !== null)
        ? Long.fromValue(object.outboundTransferTimeoutSeconds)
        : Long.UZERO;
    return message;
  },
};

function createBaseTransferFees(): TransferFees {
  return { bridgeFee: "" };
}

export const TransferFees: MessageFns<TransferFees> = {
  encode(message: TransferFees, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bridgeFee !== "") {
      writer.uint32(10).string(message.bridgeFee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferFees {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bridgeFee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferFees {
    return { bridgeFee: isSet(object.bridgeFee) ? globalThis.String(object.bridgeFee) : "" };
  },

  toJSON(message: TransferFees): unknown {
    const obj: any = {};
    if (message.bridgeFee !== "") {
      obj.bridgeFee = message.bridgeFee;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferFees>): TransferFees {
    return TransferFees.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferFees>): TransferFees {
    const message = createBaseTransferFees();
    message.bridgeFee = object.bridgeFee ?? "";
    return message;
  },
};

function createBaseQuarantineResolves(): QuarantineResolves {
  return { quarantineId: "", votingResult: 0, entityType: 0, entityId: "" };
}

export const QuarantineResolves: MessageFns<QuarantineResolves> = {
  encode(message: QuarantineResolves, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quarantineId !== "") {
      writer.uint32(10).string(message.quarantineId);
    }
    if (message.votingResult !== 0) {
      writer.uint32(16).int32(message.votingResult);
    }
    if (message.entityType !== 0) {
      writer.uint32(24).int32(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuarantineResolves {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuarantineResolves();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quarantineId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.votingResult = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.entityType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuarantineResolves {
    return {
      quarantineId: isSet(object.quarantineId) ? globalThis.String(object.quarantineId) : "",
      votingResult: isSet(object.votingResult) ? quarantineVotingResultFromJSON(object.votingResult) : 0,
      entityType: isSet(object.entityType) ? quarantinedEntityTypeFromJSON(object.entityType) : 0,
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
    };
  },

  toJSON(message: QuarantineResolves): unknown {
    const obj: any = {};
    if (message.quarantineId !== "") {
      obj.quarantineId = message.quarantineId;
    }
    if (message.votingResult !== 0) {
      obj.votingResult = quarantineVotingResultToJSON(message.votingResult);
    }
    if (message.entityType !== 0) {
      obj.entityType = quarantinedEntityTypeToJSON(message.entityType);
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    return obj;
  },

  create(base?: DeepPartial<QuarantineResolves>): QuarantineResolves {
    return QuarantineResolves.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuarantineResolves>): QuarantineResolves {
    const message = createBaseQuarantineResolves();
    message.quarantineId = object.quarantineId ?? "";
    message.votingResult = object.votingResult ?? 0;
    message.entityType = object.entityType ?? 0;
    message.entityId = object.entityId ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
