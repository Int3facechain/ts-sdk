// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               unknown
// source: int3face/bridge/v1beta1/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../../google/protobuf/any";
import {
  QuarantineVotingResult,
  quarantineVotingResultFromJSON,
  quarantineVotingResultToJSON,
} from "../../quarantine/quarantine";
import {
  AssetID,
  AssetStatus,
  assetStatusFromJSON,
  assetStatusToJSON,
  BridgeStatus,
  bridgeStatusFromJSON,
  bridgeStatusToJSON,
  Chain,
  ChainAssetStatus,
  chainAssetStatusFromJSON,
  chainAssetStatusToJSON,
  ChainRetryParams,
  ChainStatus,
  chainStatusFromJSON,
  chainStatusToJSON,
  ContractAssetId,
  ContractAssetParams,
  ContractFee,
  ContractSigners,
  ContractStatus,
  contractStatusFromJSON,
  contractStatusToJSON,
  ContractUpgradeData,
  GasParams,
  IbcAsset,
  IbcAssetSwap,
  IbcForwardingParams,
  ProposalResult,
  proposalResultFromJSON,
  proposalResultToJSON,
  ProposalStatus,
  proposalStatusFromJSON,
  proposalStatusToJSON,
  Signer,
  SmartContractAsset,
  TransferFees,
  TransferProtocol,
  transferProtocolFromJSON,
  transferProtocolToJSON,
  UtxoAsset,
  UtxoRelayerParams,
} from "./bridge";
import { AssetDestChainIds, TssChainToMigrate } from "./proposals";
import { OutboundTransferResult } from "./tx";

export const protobufPackage = "int3face.bridge.v1beta1";

export interface EventInboundTransfer {
  /** Sender is a sender's address */
  sender: string;
  /** DestAddr is a destination address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  externalId: string;
  /** DestChainId is a destination chain of the transfer. */
  destChainId: string;
  /** Fees defines the fees for the inbound transfer */
  fees:
    | TransferFees
    | undefined;
  /** TransferProtocol is a protocol to use for the transfer */
  transferProtocol: TransferProtocol;
}

export interface EventInboundTransferRetry {
  /** SrcChainId is a source chain of the transfer to retry */
  srcChainId: string;
  /** ExternalId is an external ID of the transfer to retry */
  externalId: string;
  /** ExternalHeight is an external height of the transfer to retry */
  externalHeight: Long;
}

export interface EventIbcInboundTransfer {
  /** Sender is a sender's address */
  sender: string;
  /** DestAddr is a destination address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  /** DestChainId is a destination chain of the transfer. */
  destChainId: string;
  /** SrcChainId is a source chain of the transfer. */
  srcChainId: string;
  /** SourceChannel is a source channel from which the transfer is coming */
  sourceChannel: string;
  /** DestChannel is a destination channel to which the transfer is going */
  destChannel: string;
  /** Sequence is a sequence number of the transfer */
  sequence: Long;
  /** Fees defines the fees for the ibc inbound transfer */
  fees: TransferFees | undefined;
}

export interface EventInboundTransferFinalized {
  /** Sender is a sender's address */
  sender: string;
  /** DestAddr is a destination Int3face address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  externalId: string;
  /** DestChainId is a destination chain of the transfer. */
  destChainId: string;
  /**
   * FinalizedTxHash is a hash of the final int3face transaction which finalized
   * the transfer and minted the tokens
   */
  finalizedTxHash: string;
  /** Fees defines the fees for the inbound transfer */
  fees: TransferFees | undefined;
}

export interface EventForceInboundTransfer {
  /** Sender is a sender's address */
  sender: string;
  /** DestAddr is a destination Int3face address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** Amount of coins to transfer */
  amount: string;
  externalId: string;
  /** DestChainId is a destination chain of the transfer. */
  destChainId: string;
  /** Fees defines the fees for the force inbound transfer */
  fees: TransferFees | undefined;
}

export interface EventOutboundTransfer {
  /** Sender is a sender's address */
  sender: string;
  /** DestAddr is a destination Int3face address */
  destAddr: string;
  /** AssetID is the ID of the asset being transferred */
  assetId:
    | AssetID
    | undefined;
  /** DestChainId is a destination chain of the transfer. */
  destChainId: string;
  /** Amount of coins to transfer */
  amount: string;
  /** SrcChainId is a source chain of the transfer. */
  srcChainId: string;
  /** TransferProtocol is a protocol to use for the transfer */
  transferProtocol: TransferProtocol;
  /** Fees defines the fees for the outbound transfer */
  fees: TransferFees | undefined;
}

export interface EventOutboundTransferRetry {
  /** Sender is a sender's address */
  sender: string;
  /** TransferHash of the transfer to retry */
  transferHash: string;
}

export interface EventOutboundTransferResult {
  /** Sender is a sender's address */
  sender: string;
  /** TxHash of the transfer */
  txHash: string;
  /** Result is a result of the outbound transfer */
  result: OutboundTransferResult | undefined;
}

export interface EventOutboundTransferFinalized {
  /** TxHash is a hash of the outbound transfer transaction on Int3face chain */
  txHash: string;
}

export interface EventOutboundTransferFailed {
  /** TxHash is a hash of the outbound transfer transaction on Int3face chain */
  txHash: string;
}

export interface EventUpdateBridgeStatus {
  sender: string;
  status: BridgeStatus;
}

export interface EventCreateAsset {
  sender: string;
  id: AssetID | undefined;
  exponent: Long;
  minTransferAmount: string;
}

export interface EventRemoveAsset {
  sender: string;
  id: AssetID | undefined;
}

export interface EventUpdateAssetStatus {
  sender: string;
  id: AssetID | undefined;
  status: AssetStatus;
}

export interface EventUpdateAssetMinTransferAmount {
  sender: string;
  id: AssetID | undefined;
  minTransferAmount: string;
}

export interface EventSetChainParams {
  sender: string;
  chainId: string;
  chainParams: Chain | undefined;
}

export interface EventAddChain {
  sender: string;
  chain: Chain | undefined;
}

export interface EventRemoveChain {
  sender: string;
  chainId: string;
}

export interface EventUpdateChainStatus {
  sender: string;
  chainId: string;
  status: ChainStatus;
}

export interface EventUpdateChainRetryParams {
  sender: string;
  chainId: string;
  retryParams: ChainRetryParams | undefined;
}

export interface EventUpdateChainAssetStatus {
  sender: string;
  chainId: string;
  assetId: AssetID | undefined;
  status: ChainAssetStatus;
}

export interface EventAddChainAsset {
  sender: string;
  chainId: string;
  asset: Any | undefined;
}

export interface EventRemoveChainAsset {
  sender: string;
  chainId: string;
  assetId: AssetID | undefined;
}

export interface EventSetChainSigners {
  sender: string;
  chainId: string;
  signers: Signer[];
}

export interface EventSetChainGasParams {
  sender: string;
  chainId: string;
  gasParams: GasParams | undefined;
}

export interface EventSetChainConfirmationsRequired {
  sender: string;
  chainId: string;
  confirmations: Long;
}

export interface EventSubmitProposalResult {
  sender: string;
  proposalId: Long;
  chainId: string;
  result: ProposalResult;
}

export interface EventSubmitProposalResultFinalized {
  sender: string;
  proposalId: Long;
  status: ProposalStatus;
}

export interface EventSetUtxoChainRelayerParams {
  sender: string;
  chainId: string;
  relayerParams: UtxoRelayerParams | undefined;
}

export interface EventAddUtxoChainAsset {
  sender: string;
  asset: UtxoAsset | undefined;
}

export interface EventTssKeyGen {
  sender: string;
  tssSigners: string[];
  randomness: Long;
}

export interface EventTssKeyGenResult {
  sender: string;
  keygenId: string;
  tssSigners: string[];
  tssPoolPk: string;
}

export interface EventTssVaultMigration {
  sender: string;
  chains: TssChainToMigrate[];
  keygenId: string;
  skipVaultUpdate: boolean;
}

export interface EventTssVaultUpdate {
  sender: string;
  chainIds: string[];
  keygenId: string;
}

export interface EventPruneSmartContractChainContract {
  sender: string;
  chainId: string;
  pruneBefore: Long;
}

export interface EventUpgradeSmartContractChainContract {
  sender: string;
  chainId: string;
  upgradeData: ContractUpgradeData | undefined;
}

export interface EventSetSmartContractChainAssetsDestChainIds {
  sender: string;
  chainId: string;
  assets: AssetDestChainIds[];
}

export interface EventAddSmartContractChainAsset {
  sender: string;
  asset: SmartContractAsset | undefined;
}

export interface EventUpdateIbcChainParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** ChannelId is the channel on the local chain */
  channelId: string;
  /** PortId is the port on the local chain */
  portId: string;
  /** Timeout is the timeout height of the IBC chain */
  timeout: Long;
}

export interface EventAddIbcChainAsset {
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** Asset is the asset parameters */
  asset: IbcAsset | undefined;
}

export interface EventUpdateIbcChainAssetParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** ChainID is the chain's primary key */
  chainId: string;
  /** AssetID is the asset's primary key */
  assetId:
    | AssetID
    | undefined;
  /** LocalIbcDenom is the denom's representation on the Int3face chain */
  localIbcDenom: string;
  /** ExternalIbcDenom is the denom's representation on the external chain */
  externalIbcDenom: string;
  /** Swap is the asset swap parameters */
  swap: IbcAssetSwap | undefined;
}

export interface EventChangeAssetStatus {
  sender: string;
  assetId: AssetID | undefined;
  oldStatus: AssetStatus;
  newStatus: AssetStatus;
}

export interface EventUpdateSigners {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** CreatedSigners is a list of signers added to the signes pool */
  CreatedSigners: string[];
  /** DeletedSigners is a list of signers removed from the signers pool */
  DeletedSigners: string[];
}

export interface EventUpdateParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** NewVotesNeeded is a new amount of votes needed to accept an inbound tranfer */
  newVotesNeeded: Long;
  /** NewFee is a new fee value */
  newFee: string;
}

export interface EventUpdateIbcForwardingParams {
  /** Sender is a sender's Int3face address */
  sender: string;
  /** Params is the new IBC forwarding parameters */
  params: IbcForwardingParams[];
}

export interface EventUpdateContractSigners {
  /** Sender is a sinder's Int3face address. */
  sender: string;
  /** Signers is a list of observer's addresses for each chain to update. */
  signers: ContractSigners[];
}

export interface EventSubmitUpdateContractSignersResult {
  /** Sender is a sinder's Int3face address. */
  sender: string;
  /** UpdateId is a unique identifier for the update request. */
  updateId: string;
  /** Signers is a list of observer's addresses for each chain to update. */
  signers: ContractSigners[];
}

export interface EventUpdateContractParams {
  /** Sender is a sinder's Int3face address. */
  sender: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** ContractAddress is an address of the bridge contract. */
  contractAddress: string;
  /** Fees is new fees amounts for the bridge contract operations. */
  fees: ContractFee[];
  /** Params is the list of new parameters for the chain assets. */
  assetParams: ContractAssetParams[];
}

export interface EventSubmitUpdateContractParamsResult {
  /** Sender is a sender's address. */
  sender: string;
  /** UpdateId is a unique identifier for the update request. */
  updateId: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** ContractAddress is an address of the bridge contract. */
  contractAddress: string;
  /** Fees is new fees amounts for the bridge contract operations. */
  fees: ContractFee[];
  /** Params is the list of new parameters for the chain assets. */
  assetParams: ContractAssetParams[];
}

export interface EventUpdateContractStatus {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** Status is a new status of the bridge contract. */
  status: ContractStatus;
}

export interface EventSubmitUpdateContractStatusResult {
  /** Sender is a sender's address. */
  sender: string;
  /** UpdateId is a unique identifier of the update. */
  updateId: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** Status is a new status of the bridge contract. */
  status: ContractStatus;
}

export interface EventPruneContract {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to prune. */
  chainId: string;
  /** PruneBefore is a timestamp before which the data should be pruned. */
  pruneBefore: Long;
}

export interface EventSubmitPruneContractResult {
  /** Sender is a sender's address. */
  sender: string;
  /** PruneId is a unique identifier for the prune request. */
  pruneId: string;
  /** ChainId is a id of the chain to prune. */
  chainId: string;
  /** PruneBefore is a timestamp before which the data should be pruned. */
  pruneBefore: Long;
}

export interface EventUpgradeContract {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** UpgradeData is the encoded contract data related to the concrete chain. */
  upgradeData: ContractUpgradeData | undefined;
}

export interface EventSubmitUpgradeContractResult {
  /** Sender is a sender's address. */
  sender: string;
  /** UpgradeId is a unique identifier of the prune. */
  upgradeId: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** UpgradeData is the encoded contract data related to the concrete chain. */
  upgradeData: ContractUpgradeData | undefined;
}

export interface EventAddContractAssets {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /**
   * NewAssets is the list of new assets parameters to add to the bridge
   * contract.
   */
  newAssets: ContractAssetParams[];
}

export interface EventSubmitAddContractAssetsResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier for the add assets request. */
  id: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /**
   * NewAssets is the list of new assets parameters to add to the bridge
   * contract.
   */
  newAssets: ContractAssetParams[];
}

export interface EventDeleteContractAsset {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** AssetAddress is the address of the asset to delete. */
  assetAddress: string;
}

export interface EventSubmitDeleteContractAssetResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier for the add assets request. */
  id: string;
  /** ChainId is a id of the chain to update. */
  chainId: string;
  /** AssetAddress is the address of the asset to delete. */
  assetAddress: string;
}

export interface EventWhitelistContractAsset {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to whitelist. */
  asset: ContractAssetId | undefined;
}

export interface EventSubmitWhitelistContractAssetResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to whitelist. */
  asset: ContractAssetId | undefined;
}

export interface EventUnwhitelistContractAsset {
  /** Sender is a sender's address. */
  sender: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to unwhitelist. */
  asset: ContractAssetId | undefined;
}

export interface EventSubmitUnwhitelistContractAssetResult {
  /** Sender is a sender's address. */
  sender: string;
  /** Id is a unique identifier of the request. */
  id: string;
  /** ChainId is the identifier of a chain to update. */
  chainId: string;
  /** Asset is the asset to unwhitelist. */
  asset: ContractAssetId | undefined;
}

export interface EventUpdateNttChainParams {
  sender: string;
  chainId: string;
  wormholeProgram: string;
  nttChainId: Long;
}

export interface EventUpdateNttChainAssetAddresses {
  sender: string;
  chainId: string;
  assetId: AssetID | undefined;
  nttManagerAddress: string;
  externalNttManagerAddress: string;
  externalTokenAddress: string;
  nttTransceivers: string[];
  externalNttTransceivers: string[];
}

export interface EventVoteQuarantinedEntity {
  /** Sender is a sender's address */
  sender: string;
  /** EntityId is the ID of the quarantined entity */
  entityId: string;
  /** VotingResult is the voting result (process or reject) */
  votingResult: QuarantineVotingResult;
}

export interface EventSetTssVaultFromKeygen {
  sender: string;
  chainIds: string[];
  keygenId: string;
}

function createBaseEventInboundTransfer(): EventInboundTransfer {
  return {
    sender: "",
    destAddr: "",
    assetId: undefined,
    amount: "",
    externalId: "",
    destChainId: "",
    fees: undefined,
    transferProtocol: 0,
  };
}

export const EventInboundTransfer: MessageFns<EventInboundTransfer> = {
  encode(message: EventInboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(18).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.externalId !== "") {
      writer.uint32(42).string(message.externalId);
    }
    if (message.destChainId !== "") {
      writer.uint32(50).string(message.destChainId);
    }
    if (message.fees !== undefined) {
      TransferFees.encode(message.fees, writer.uint32(58).fork()).join();
    }
    if (message.transferProtocol !== 0) {
      writer.uint32(64).int32(message.transferProtocol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventInboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventInboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fees = TransferFees.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.transferProtocol = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventInboundTransfer {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      fees: isSet(object.fees) ? TransferFees.fromJSON(object.fees) : undefined,
      transferProtocol: isSet(object.transferProtocol) ? transferProtocolFromJSON(object.transferProtocol) : 0,
    };
  },

  toJSON(message: EventInboundTransfer): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.fees !== undefined) {
      obj.fees = TransferFees.toJSON(message.fees);
    }
    if (message.transferProtocol !== 0) {
      obj.transferProtocol = transferProtocolToJSON(message.transferProtocol);
    }
    return obj;
  },

  create(base?: DeepPartial<EventInboundTransfer>): EventInboundTransfer {
    return EventInboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventInboundTransfer>): EventInboundTransfer {
    const message = createBaseEventInboundTransfer();
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.externalId = object.externalId ?? "";
    message.destChainId = object.destChainId ?? "";
    message.fees = (object.fees !== undefined && object.fees !== null)
      ? TransferFees.fromPartial(object.fees)
      : undefined;
    message.transferProtocol = object.transferProtocol ?? 0;
    return message;
  },
};

function createBaseEventInboundTransferRetry(): EventInboundTransferRetry {
  return { srcChainId: "", externalId: "", externalHeight: Long.UZERO };
}

export const EventInboundTransferRetry: MessageFns<EventInboundTransferRetry> = {
  encode(message: EventInboundTransferRetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.srcChainId !== "") {
      writer.uint32(10).string(message.srcChainId);
    }
    if (message.externalId !== "") {
      writer.uint32(18).string(message.externalId);
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.externalHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventInboundTransferRetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventInboundTransferRetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.externalHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventInboundTransferRetry {
    return {
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      externalHeight: isSet(object.externalHeight) ? Long.fromValue(object.externalHeight) : Long.UZERO,
    };
  },

  toJSON(message: EventInboundTransferRetry): unknown {
    const obj: any = {};
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (!message.externalHeight.equals(Long.UZERO)) {
      obj.externalHeight = (message.externalHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventInboundTransferRetry>): EventInboundTransferRetry {
    return EventInboundTransferRetry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventInboundTransferRetry>): EventInboundTransferRetry {
    const message = createBaseEventInboundTransferRetry();
    message.srcChainId = object.srcChainId ?? "";
    message.externalId = object.externalId ?? "";
    message.externalHeight = (object.externalHeight !== undefined && object.externalHeight !== null)
      ? Long.fromValue(object.externalHeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventIbcInboundTransfer(): EventIbcInboundTransfer {
  return {
    sender: "",
    destAddr: "",
    assetId: undefined,
    amount: "",
    destChainId: "",
    srcChainId: "",
    sourceChannel: "",
    destChannel: "",
    sequence: Long.UZERO,
    fees: undefined,
  };
}

export const EventIbcInboundTransfer: MessageFns<EventIbcInboundTransfer> = {
  encode(message: EventIbcInboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(18).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.destChainId !== "") {
      writer.uint32(42).string(message.destChainId);
    }
    if (message.srcChainId !== "") {
      writer.uint32(50).string(message.srcChainId);
    }
    if (message.sourceChannel !== "") {
      writer.uint32(58).string(message.sourceChannel);
    }
    if (message.destChannel !== "") {
      writer.uint32(66).string(message.destChannel);
    }
    if (!message.sequence.equals(Long.UZERO)) {
      writer.uint32(72).uint64(message.sequence.toString());
    }
    if (message.fees !== undefined) {
      TransferFees.encode(message.fees, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventIbcInboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventIbcInboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sourceChannel = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.destChannel = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sequence = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.fees = TransferFees.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventIbcInboundTransfer {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      sourceChannel: isSet(object.sourceChannel) ? globalThis.String(object.sourceChannel) : "",
      destChannel: isSet(object.destChannel) ? globalThis.String(object.destChannel) : "",
      sequence: isSet(object.sequence) ? Long.fromValue(object.sequence) : Long.UZERO,
      fees: isSet(object.fees) ? TransferFees.fromJSON(object.fees) : undefined,
    };
  },

  toJSON(message: EventIbcInboundTransfer): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.sourceChannel !== "") {
      obj.sourceChannel = message.sourceChannel;
    }
    if (message.destChannel !== "") {
      obj.destChannel = message.destChannel;
    }
    if (!message.sequence.equals(Long.UZERO)) {
      obj.sequence = (message.sequence || Long.UZERO).toString();
    }
    if (message.fees !== undefined) {
      obj.fees = TransferFees.toJSON(message.fees);
    }
    return obj;
  },

  create(base?: DeepPartial<EventIbcInboundTransfer>): EventIbcInboundTransfer {
    return EventIbcInboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventIbcInboundTransfer>): EventIbcInboundTransfer {
    const message = createBaseEventIbcInboundTransfer();
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.destChainId = object.destChainId ?? "";
    message.srcChainId = object.srcChainId ?? "";
    message.sourceChannel = object.sourceChannel ?? "";
    message.destChannel = object.destChannel ?? "";
    message.sequence = (object.sequence !== undefined && object.sequence !== null)
      ? Long.fromValue(object.sequence)
      : Long.UZERO;
    message.fees = (object.fees !== undefined && object.fees !== null)
      ? TransferFees.fromPartial(object.fees)
      : undefined;
    return message;
  },
};

function createBaseEventInboundTransferFinalized(): EventInboundTransferFinalized {
  return {
    sender: "",
    destAddr: "",
    assetId: undefined,
    amount: "",
    externalId: "",
    destChainId: "",
    finalizedTxHash: "",
    fees: undefined,
  };
}

export const EventInboundTransferFinalized: MessageFns<EventInboundTransferFinalized> = {
  encode(message: EventInboundTransferFinalized, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(18).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.externalId !== "") {
      writer.uint32(42).string(message.externalId);
    }
    if (message.destChainId !== "") {
      writer.uint32(50).string(message.destChainId);
    }
    if (message.finalizedTxHash !== "") {
      writer.uint32(58).string(message.finalizedTxHash);
    }
    if (message.fees !== undefined) {
      TransferFees.encode(message.fees, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventInboundTransferFinalized {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventInboundTransferFinalized();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.finalizedTxHash = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fees = TransferFees.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventInboundTransferFinalized {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      finalizedTxHash: isSet(object.finalizedTxHash) ? globalThis.String(object.finalizedTxHash) : "",
      fees: isSet(object.fees) ? TransferFees.fromJSON(object.fees) : undefined,
    };
  },

  toJSON(message: EventInboundTransferFinalized): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.finalizedTxHash !== "") {
      obj.finalizedTxHash = message.finalizedTxHash;
    }
    if (message.fees !== undefined) {
      obj.fees = TransferFees.toJSON(message.fees);
    }
    return obj;
  },

  create(base?: DeepPartial<EventInboundTransferFinalized>): EventInboundTransferFinalized {
    return EventInboundTransferFinalized.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventInboundTransferFinalized>): EventInboundTransferFinalized {
    const message = createBaseEventInboundTransferFinalized();
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.externalId = object.externalId ?? "";
    message.destChainId = object.destChainId ?? "";
    message.finalizedTxHash = object.finalizedTxHash ?? "";
    message.fees = (object.fees !== undefined && object.fees !== null)
      ? TransferFees.fromPartial(object.fees)
      : undefined;
    return message;
  },
};

function createBaseEventForceInboundTransfer(): EventForceInboundTransfer {
  return { sender: "", destAddr: "", assetId: undefined, amount: "", externalId: "", destChainId: "", fees: undefined };
}

export const EventForceInboundTransfer: MessageFns<EventForceInboundTransfer> = {
  encode(message: EventForceInboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(18).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.externalId !== "") {
      writer.uint32(42).string(message.externalId);
    }
    if (message.destChainId !== "") {
      writer.uint32(50).string(message.destChainId);
    }
    if (message.fees !== undefined) {
      TransferFees.encode(message.fees, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventForceInboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventForceInboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fees = TransferFees.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventForceInboundTransfer {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      fees: isSet(object.fees) ? TransferFees.fromJSON(object.fees) : undefined,
    };
  },

  toJSON(message: EventForceInboundTransfer): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.fees !== undefined) {
      obj.fees = TransferFees.toJSON(message.fees);
    }
    return obj;
  },

  create(base?: DeepPartial<EventForceInboundTransfer>): EventForceInboundTransfer {
    return EventForceInboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventForceInboundTransfer>): EventForceInboundTransfer {
    const message = createBaseEventForceInboundTransfer();
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.amount = object.amount ?? "";
    message.externalId = object.externalId ?? "";
    message.destChainId = object.destChainId ?? "";
    message.fees = (object.fees !== undefined && object.fees !== null)
      ? TransferFees.fromPartial(object.fees)
      : undefined;
    return message;
  },
};

function createBaseEventOutboundTransfer(): EventOutboundTransfer {
  return {
    sender: "",
    destAddr: "",
    assetId: undefined,
    destChainId: "",
    amount: "",
    srcChainId: "",
    transferProtocol: 0,
    fees: undefined,
  };
}

export const EventOutboundTransfer: MessageFns<EventOutboundTransfer> = {
  encode(message: EventOutboundTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.destAddr !== "") {
      writer.uint32(18).string(message.destAddr);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.destChainId !== "") {
      writer.uint32(34).string(message.destChainId);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    if (message.srcChainId !== "") {
      writer.uint32(50).string(message.srcChainId);
    }
    if (message.transferProtocol !== 0) {
      writer.uint32(56).int32(message.transferProtocol);
    }
    if (message.fees !== undefined) {
      TransferFees.encode(message.fees, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOutboundTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOutboundTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destChainId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.srcChainId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.transferProtocol = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fees = TransferFees.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOutboundTransfer {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      destAddr: isSet(object.destAddr) ? globalThis.String(object.destAddr) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      destChainId: isSet(object.destChainId) ? globalThis.String(object.destChainId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      srcChainId: isSet(object.srcChainId) ? globalThis.String(object.srcChainId) : "",
      transferProtocol: isSet(object.transferProtocol) ? transferProtocolFromJSON(object.transferProtocol) : 0,
      fees: isSet(object.fees) ? TransferFees.fromJSON(object.fees) : undefined,
    };
  },

  toJSON(message: EventOutboundTransfer): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.destAddr !== "") {
      obj.destAddr = message.destAddr;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.destChainId !== "") {
      obj.destChainId = message.destChainId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.srcChainId !== "") {
      obj.srcChainId = message.srcChainId;
    }
    if (message.transferProtocol !== 0) {
      obj.transferProtocol = transferProtocolToJSON(message.transferProtocol);
    }
    if (message.fees !== undefined) {
      obj.fees = TransferFees.toJSON(message.fees);
    }
    return obj;
  },

  create(base?: DeepPartial<EventOutboundTransfer>): EventOutboundTransfer {
    return EventOutboundTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventOutboundTransfer>): EventOutboundTransfer {
    const message = createBaseEventOutboundTransfer();
    message.sender = object.sender ?? "";
    message.destAddr = object.destAddr ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.destChainId = object.destChainId ?? "";
    message.amount = object.amount ?? "";
    message.srcChainId = object.srcChainId ?? "";
    message.transferProtocol = object.transferProtocol ?? 0;
    message.fees = (object.fees !== undefined && object.fees !== null)
      ? TransferFees.fromPartial(object.fees)
      : undefined;
    return message;
  },
};

function createBaseEventOutboundTransferRetry(): EventOutboundTransferRetry {
  return { sender: "", transferHash: "" };
}

export const EventOutboundTransferRetry: MessageFns<EventOutboundTransferRetry> = {
  encode(message: EventOutboundTransferRetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.transferHash !== "") {
      writer.uint32(18).string(message.transferHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOutboundTransferRetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOutboundTransferRetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transferHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOutboundTransferRetry {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      transferHash: isSet(object.transferHash) ? globalThis.String(object.transferHash) : "",
    };
  },

  toJSON(message: EventOutboundTransferRetry): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.transferHash !== "") {
      obj.transferHash = message.transferHash;
    }
    return obj;
  },

  create(base?: DeepPartial<EventOutboundTransferRetry>): EventOutboundTransferRetry {
    return EventOutboundTransferRetry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventOutboundTransferRetry>): EventOutboundTransferRetry {
    const message = createBaseEventOutboundTransferRetry();
    message.sender = object.sender ?? "";
    message.transferHash = object.transferHash ?? "";
    return message;
  },
};

function createBaseEventOutboundTransferResult(): EventOutboundTransferResult {
  return { sender: "", txHash: "", result: undefined };
}

export const EventOutboundTransferResult: MessageFns<EventOutboundTransferResult> = {
  encode(message: EventOutboundTransferResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.txHash !== "") {
      writer.uint32(18).string(message.txHash);
    }
    if (message.result !== undefined) {
      OutboundTransferResult.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOutboundTransferResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOutboundTransferResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = OutboundTransferResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOutboundTransferResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      result: isSet(object.result) ? OutboundTransferResult.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: EventOutboundTransferResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.result !== undefined) {
      obj.result = OutboundTransferResult.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<EventOutboundTransferResult>): EventOutboundTransferResult {
    return EventOutboundTransferResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventOutboundTransferResult>): EventOutboundTransferResult {
    const message = createBaseEventOutboundTransferResult();
    message.sender = object.sender ?? "";
    message.txHash = object.txHash ?? "";
    message.result = (object.result !== undefined && object.result !== null)
      ? OutboundTransferResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseEventOutboundTransferFinalized(): EventOutboundTransferFinalized {
  return { txHash: "" };
}

export const EventOutboundTransferFinalized: MessageFns<EventOutboundTransferFinalized> = {
  encode(message: EventOutboundTransferFinalized, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOutboundTransferFinalized {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOutboundTransferFinalized();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOutboundTransferFinalized {
    return { txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "" };
  },

  toJSON(message: EventOutboundTransferFinalized): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    return obj;
  },

  create(base?: DeepPartial<EventOutboundTransferFinalized>): EventOutboundTransferFinalized {
    return EventOutboundTransferFinalized.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventOutboundTransferFinalized>): EventOutboundTransferFinalized {
    const message = createBaseEventOutboundTransferFinalized();
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseEventOutboundTransferFailed(): EventOutboundTransferFailed {
  return { txHash: "" };
}

export const EventOutboundTransferFailed: MessageFns<EventOutboundTransferFailed> = {
  encode(message: EventOutboundTransferFailed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOutboundTransferFailed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOutboundTransferFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOutboundTransferFailed {
    return { txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "" };
  },

  toJSON(message: EventOutboundTransferFailed): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    return obj;
  },

  create(base?: DeepPartial<EventOutboundTransferFailed>): EventOutboundTransferFailed {
    return EventOutboundTransferFailed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventOutboundTransferFailed>): EventOutboundTransferFailed {
    const message = createBaseEventOutboundTransferFailed();
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseEventUpdateBridgeStatus(): EventUpdateBridgeStatus {
  return { sender: "", status: 0 };
}

export const EventUpdateBridgeStatus: MessageFns<EventUpdateBridgeStatus> = {
  encode(message: EventUpdateBridgeStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateBridgeStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateBridgeStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateBridgeStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      status: isSet(object.status) ? bridgeStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EventUpdateBridgeStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.status !== 0) {
      obj.status = bridgeStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateBridgeStatus>): EventUpdateBridgeStatus {
    return EventUpdateBridgeStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateBridgeStatus>): EventUpdateBridgeStatus {
    const message = createBaseEventUpdateBridgeStatus();
    message.sender = object.sender ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseEventCreateAsset(): EventCreateAsset {
  return { sender: "", id: undefined, exponent: Long.UZERO, minTransferAmount: "" };
}

export const EventCreateAsset: MessageFns<EventCreateAsset> = {
  encode(message: EventCreateAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (!message.exponent.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.exponent.toString());
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(34).string(message.minTransferAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventCreateAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exponent = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCreateAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      exponent: isSet(object.exponent) ? Long.fromValue(object.exponent) : Long.UZERO,
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
    };
  },

  toJSON(message: EventCreateAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (!message.exponent.equals(Long.UZERO)) {
      obj.exponent = (message.exponent || Long.UZERO).toString();
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<EventCreateAsset>): EventCreateAsset {
    return EventCreateAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventCreateAsset>): EventCreateAsset {
    const message = createBaseEventCreateAsset();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.exponent = (object.exponent !== undefined && object.exponent !== null)
      ? Long.fromValue(object.exponent)
      : Long.UZERO;
    message.minTransferAmount = object.minTransferAmount ?? "";
    return message;
  },
};

function createBaseEventRemoveAsset(): EventRemoveAsset {
  return { sender: "", id: undefined };
}

export const EventRemoveAsset: MessageFns<EventRemoveAsset> = {
  encode(message: EventRemoveAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventRemoveAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRemoveAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventRemoveAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: EventRemoveAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<EventRemoveAsset>): EventRemoveAsset {
    return EventRemoveAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventRemoveAsset>): EventRemoveAsset {
    const message = createBaseEventRemoveAsset();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseEventUpdateAssetStatus(): EventUpdateAssetStatus {
  return { sender: "", id: undefined, status: 0 };
}

export const EventUpdateAssetStatus: MessageFns<EventUpdateAssetStatus> = {
  encode(message: EventUpdateAssetStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateAssetStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateAssetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateAssetStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      status: isSet(object.status) ? assetStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EventUpdateAssetStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.status !== 0) {
      obj.status = assetStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateAssetStatus>): EventUpdateAssetStatus {
    return EventUpdateAssetStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateAssetStatus>): EventUpdateAssetStatus {
    const message = createBaseEventUpdateAssetStatus();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseEventUpdateAssetMinTransferAmount(): EventUpdateAssetMinTransferAmount {
  return { sender: "", id: undefined, minTransferAmount: "" };
}

export const EventUpdateAssetMinTransferAmount: MessageFns<EventUpdateAssetMinTransferAmount> = {
  encode(message: EventUpdateAssetMinTransferAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== undefined) {
      AssetID.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.minTransferAmount !== "") {
      writer.uint32(26).string(message.minTransferAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateAssetMinTransferAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateAssetMinTransferAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minTransferAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateAssetMinTransferAmount {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? AssetID.fromJSON(object.id) : undefined,
      minTransferAmount: isSet(object.minTransferAmount) ? globalThis.String(object.minTransferAmount) : "",
    };
  },

  toJSON(message: EventUpdateAssetMinTransferAmount): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== undefined) {
      obj.id = AssetID.toJSON(message.id);
    }
    if (message.minTransferAmount !== "") {
      obj.minTransferAmount = message.minTransferAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateAssetMinTransferAmount>): EventUpdateAssetMinTransferAmount {
    return EventUpdateAssetMinTransferAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateAssetMinTransferAmount>): EventUpdateAssetMinTransferAmount {
    const message = createBaseEventUpdateAssetMinTransferAmount();
    message.sender = object.sender ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? AssetID.fromPartial(object.id) : undefined;
    message.minTransferAmount = object.minTransferAmount ?? "";
    return message;
  },
};

function createBaseEventSetChainParams(): EventSetChainParams {
  return { sender: "", chainId: "", chainParams: undefined };
}

export const EventSetChainParams: MessageFns<EventSetChainParams> = {
  encode(message: EventSetChainParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.chainParams !== undefined) {
      Chain.encode(message.chainParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetChainParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainParams = Chain.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetChainParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      chainParams: isSet(object.chainParams) ? Chain.fromJSON(object.chainParams) : undefined,
    };
  },

  toJSON(message: EventSetChainParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.chainParams !== undefined) {
      obj.chainParams = Chain.toJSON(message.chainParams);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSetChainParams>): EventSetChainParams {
    return EventSetChainParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSetChainParams>): EventSetChainParams {
    const message = createBaseEventSetChainParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.chainParams = (object.chainParams !== undefined && object.chainParams !== null)
      ? Chain.fromPartial(object.chainParams)
      : undefined;
    return message;
  },
};

function createBaseEventAddChain(): EventAddChain {
  return { sender: "", chain: undefined };
}

export const EventAddChain: MessageFns<EventAddChain> = {
  encode(message: EventAddChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chain !== undefined) {
      Chain.encode(message.chain, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAddChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAddChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chain = Chain.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAddChain {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chain: isSet(object.chain) ? Chain.fromJSON(object.chain) : undefined,
    };
  },

  toJSON(message: EventAddChain): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chain !== undefined) {
      obj.chain = Chain.toJSON(message.chain);
    }
    return obj;
  },

  create(base?: DeepPartial<EventAddChain>): EventAddChain {
    return EventAddChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventAddChain>): EventAddChain {
    const message = createBaseEventAddChain();
    message.sender = object.sender ?? "";
    message.chain = (object.chain !== undefined && object.chain !== null) ? Chain.fromPartial(object.chain) : undefined;
    return message;
  },
};

function createBaseEventRemoveChain(): EventRemoveChain {
  return { sender: "", chainId: "" };
}

export const EventRemoveChain: MessageFns<EventRemoveChain> = {
  encode(message: EventRemoveChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventRemoveChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRemoveChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventRemoveChain {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
    };
  },

  toJSON(message: EventRemoveChain): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create(base?: DeepPartial<EventRemoveChain>): EventRemoveChain {
    return EventRemoveChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventRemoveChain>): EventRemoveChain {
    const message = createBaseEventRemoveChain();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseEventUpdateChainStatus(): EventUpdateChainStatus {
  return { sender: "", chainId: "", status: 0 };
}

export const EventUpdateChainStatus: MessageFns<EventUpdateChainStatus> = {
  encode(message: EventUpdateChainStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateChainStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateChainStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateChainStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? chainStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EventUpdateChainStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = chainStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateChainStatus>): EventUpdateChainStatus {
    return EventUpdateChainStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateChainStatus>): EventUpdateChainStatus {
    const message = createBaseEventUpdateChainStatus();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseEventUpdateChainRetryParams(): EventUpdateChainRetryParams {
  return { sender: "", chainId: "", retryParams: undefined };
}

export const EventUpdateChainRetryParams: MessageFns<EventUpdateChainRetryParams> = {
  encode(message: EventUpdateChainRetryParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.retryParams !== undefined) {
      ChainRetryParams.encode(message.retryParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateChainRetryParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateChainRetryParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryParams = ChainRetryParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateChainRetryParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      retryParams: isSet(object.retryParams) ? ChainRetryParams.fromJSON(object.retryParams) : undefined,
    };
  },

  toJSON(message: EventUpdateChainRetryParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.retryParams !== undefined) {
      obj.retryParams = ChainRetryParams.toJSON(message.retryParams);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateChainRetryParams>): EventUpdateChainRetryParams {
    return EventUpdateChainRetryParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateChainRetryParams>): EventUpdateChainRetryParams {
    const message = createBaseEventUpdateChainRetryParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.retryParams = (object.retryParams !== undefined && object.retryParams !== null)
      ? ChainRetryParams.fromPartial(object.retryParams)
      : undefined;
    return message;
  },
};

function createBaseEventUpdateChainAssetStatus(): EventUpdateChainAssetStatus {
  return { sender: "", chainId: "", assetId: undefined, status: 0 };
}

export const EventUpdateChainAssetStatus: MessageFns<EventUpdateChainAssetStatus> = {
  encode(message: EventUpdateChainAssetStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateChainAssetStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateChainAssetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateChainAssetStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      status: isSet(object.status) ? chainAssetStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EventUpdateChainAssetStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.status !== 0) {
      obj.status = chainAssetStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateChainAssetStatus>): EventUpdateChainAssetStatus {
    return EventUpdateChainAssetStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateChainAssetStatus>): EventUpdateChainAssetStatus {
    const message = createBaseEventUpdateChainAssetStatus();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseEventAddChainAsset(): EventAddChainAsset {
  return { sender: "", chainId: "", asset: undefined };
}

export const EventAddChainAsset: MessageFns<EventAddChainAsset> = {
  encode(message: EventAddChainAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      Any.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAddChainAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAddChainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAddChainAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? Any.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventAddChainAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = Any.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventAddChainAsset>): EventAddChainAsset {
    return EventAddChainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventAddChainAsset>): EventAddChainAsset {
    const message = createBaseEventAddChainAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Any.fromPartial(object.asset) : undefined;
    return message;
  },
};

function createBaseEventRemoveChainAsset(): EventRemoveChainAsset {
  return { sender: "", chainId: "", assetId: undefined };
}

export const EventRemoveChainAsset: MessageFns<EventRemoveChainAsset> = {
  encode(message: EventRemoveChainAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventRemoveChainAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRemoveChainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventRemoveChainAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
    };
  },

  toJSON(message: EventRemoveChainAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    return obj;
  },

  create(base?: DeepPartial<EventRemoveChainAsset>): EventRemoveChainAsset {
    return EventRemoveChainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventRemoveChainAsset>): EventRemoveChainAsset {
    const message = createBaseEventRemoveChainAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    return message;
  },
};

function createBaseEventSetChainSigners(): EventSetChainSigners {
  return { sender: "", chainId: "", signers: [] };
}

export const EventSetChainSigners: MessageFns<EventSetChainSigners> = {
  encode(message: EventSetChainSigners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.signers) {
      Signer.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetChainSigners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetChainSigners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signers.push(Signer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetChainSigners {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => Signer.fromJSON(e)) : [],
    };
  },

  toJSON(message: EventSetChainSigners): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventSetChainSigners>): EventSetChainSigners {
    return EventSetChainSigners.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSetChainSigners>): EventSetChainSigners {
    const message = createBaseEventSetChainSigners();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventSetChainGasParams(): EventSetChainGasParams {
  return { sender: "", chainId: "", gasParams: undefined };
}

export const EventSetChainGasParams: MessageFns<EventSetChainGasParams> = {
  encode(message: EventSetChainGasParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.gasParams !== undefined) {
      GasParams.encode(message.gasParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetChainGasParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetChainGasParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gasParams = GasParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetChainGasParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      gasParams: isSet(object.gasParams) ? GasParams.fromJSON(object.gasParams) : undefined,
    };
  },

  toJSON(message: EventSetChainGasParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.gasParams !== undefined) {
      obj.gasParams = GasParams.toJSON(message.gasParams);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSetChainGasParams>): EventSetChainGasParams {
    return EventSetChainGasParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSetChainGasParams>): EventSetChainGasParams {
    const message = createBaseEventSetChainGasParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.gasParams = (object.gasParams !== undefined && object.gasParams !== null)
      ? GasParams.fromPartial(object.gasParams)
      : undefined;
    return message;
  },
};

function createBaseEventSetChainConfirmationsRequired(): EventSetChainConfirmationsRequired {
  return { sender: "", chainId: "", confirmations: Long.UZERO };
}

export const EventSetChainConfirmationsRequired: MessageFns<EventSetChainConfirmationsRequired> = {
  encode(message: EventSetChainConfirmationsRequired, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.confirmations.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.confirmations.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetChainConfirmationsRequired {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetChainConfirmationsRequired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.confirmations = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetChainConfirmationsRequired {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      confirmations: isSet(object.confirmations) ? Long.fromValue(object.confirmations) : Long.UZERO,
    };
  },

  toJSON(message: EventSetChainConfirmationsRequired): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.confirmations.equals(Long.UZERO)) {
      obj.confirmations = (message.confirmations || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventSetChainConfirmationsRequired>): EventSetChainConfirmationsRequired {
    return EventSetChainConfirmationsRequired.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSetChainConfirmationsRequired>): EventSetChainConfirmationsRequired {
    const message = createBaseEventSetChainConfirmationsRequired();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.confirmations = (object.confirmations !== undefined && object.confirmations !== null)
      ? Long.fromValue(object.confirmations)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventSubmitProposalResult(): EventSubmitProposalResult {
  return { sender: "", proposalId: Long.UZERO, chainId: "", result: 0 };
}

export const EventSubmitProposalResult: MessageFns<EventSubmitProposalResult> = {
  encode(message: EventSubmitProposalResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.proposalId.toString());
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.result !== 0) {
      writer.uint32(32).int32(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitProposalResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitProposalResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.proposalId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitProposalResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      proposalId: isSet(object.proposalId) ? Long.fromValue(object.proposalId) : Long.UZERO,
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      result: isSet(object.result) ? proposalResultFromJSON(object.result) : 0,
    };
  },

  toJSON(message: EventSubmitProposalResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      obj.proposalId = (message.proposalId || Long.UZERO).toString();
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.result !== 0) {
      obj.result = proposalResultToJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitProposalResult>): EventSubmitProposalResult {
    return EventSubmitProposalResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitProposalResult>): EventSubmitProposalResult {
    const message = createBaseEventSubmitProposalResult();
    message.sender = object.sender ?? "";
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.UZERO;
    message.chainId = object.chainId ?? "";
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseEventSubmitProposalResultFinalized(): EventSubmitProposalResultFinalized {
  return { sender: "", proposalId: Long.UZERO, status: 0 };
}

export const EventSubmitProposalResultFinalized: MessageFns<EventSubmitProposalResultFinalized> = {
  encode(message: EventSubmitProposalResultFinalized, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.proposalId.toString());
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitProposalResultFinalized {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitProposalResultFinalized();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.proposalId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitProposalResultFinalized {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      proposalId: isSet(object.proposalId) ? Long.fromValue(object.proposalId) : Long.UZERO,
      status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EventSubmitProposalResultFinalized): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      obj.proposalId = (message.proposalId || Long.UZERO).toString();
    }
    if (message.status !== 0) {
      obj.status = proposalStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitProposalResultFinalized>): EventSubmitProposalResultFinalized {
    return EventSubmitProposalResultFinalized.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitProposalResultFinalized>): EventSubmitProposalResultFinalized {
    const message = createBaseEventSubmitProposalResultFinalized();
    message.sender = object.sender ?? "";
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.UZERO;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseEventSetUtxoChainRelayerParams(): EventSetUtxoChainRelayerParams {
  return { sender: "", chainId: "", relayerParams: undefined };
}

export const EventSetUtxoChainRelayerParams: MessageFns<EventSetUtxoChainRelayerParams> = {
  encode(message: EventSetUtxoChainRelayerParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.relayerParams !== undefined) {
      UtxoRelayerParams.encode(message.relayerParams, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetUtxoChainRelayerParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetUtxoChainRelayerParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relayerParams = UtxoRelayerParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetUtxoChainRelayerParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      relayerParams: isSet(object.relayerParams) ? UtxoRelayerParams.fromJSON(object.relayerParams) : undefined,
    };
  },

  toJSON(message: EventSetUtxoChainRelayerParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.relayerParams !== undefined) {
      obj.relayerParams = UtxoRelayerParams.toJSON(message.relayerParams);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSetUtxoChainRelayerParams>): EventSetUtxoChainRelayerParams {
    return EventSetUtxoChainRelayerParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSetUtxoChainRelayerParams>): EventSetUtxoChainRelayerParams {
    const message = createBaseEventSetUtxoChainRelayerParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.relayerParams = (object.relayerParams !== undefined && object.relayerParams !== null)
      ? UtxoRelayerParams.fromPartial(object.relayerParams)
      : undefined;
    return message;
  },
};

function createBaseEventAddUtxoChainAsset(): EventAddUtxoChainAsset {
  return { sender: "", asset: undefined };
}

export const EventAddUtxoChainAsset: MessageFns<EventAddUtxoChainAsset> = {
  encode(message: EventAddUtxoChainAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.asset !== undefined) {
      UtxoAsset.encode(message.asset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAddUtxoChainAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAddUtxoChainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.asset = UtxoAsset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAddUtxoChainAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      asset: isSet(object.asset) ? UtxoAsset.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventAddUtxoChainAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.asset !== undefined) {
      obj.asset = UtxoAsset.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventAddUtxoChainAsset>): EventAddUtxoChainAsset {
    return EventAddUtxoChainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventAddUtxoChainAsset>): EventAddUtxoChainAsset {
    const message = createBaseEventAddUtxoChainAsset();
    message.sender = object.sender ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? UtxoAsset.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseEventTssKeyGen(): EventTssKeyGen {
  return { sender: "", tssSigners: [], randomness: Long.UZERO };
}

export const EventTssKeyGen: MessageFns<EventTssKeyGen> = {
  encode(message: EventTssKeyGen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.tssSigners) {
      writer.uint32(18).string(v!);
    }
    if (!message.randomness.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.randomness.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventTssKeyGen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTssKeyGen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tssSigners.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.randomness = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTssKeyGen {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      tssSigners: globalThis.Array.isArray(object?.tssSigners)
        ? object.tssSigners.map((e: any) => globalThis.String(e))
        : [],
      randomness: isSet(object.randomness) ? Long.fromValue(object.randomness) : Long.UZERO,
    };
  },

  toJSON(message: EventTssKeyGen): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.tssSigners?.length) {
      obj.tssSigners = message.tssSigners;
    }
    if (!message.randomness.equals(Long.UZERO)) {
      obj.randomness = (message.randomness || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventTssKeyGen>): EventTssKeyGen {
    return EventTssKeyGen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventTssKeyGen>): EventTssKeyGen {
    const message = createBaseEventTssKeyGen();
    message.sender = object.sender ?? "";
    message.tssSigners = object.tssSigners?.map((e) => e) || [];
    message.randomness = (object.randomness !== undefined && object.randomness !== null)
      ? Long.fromValue(object.randomness)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventTssKeyGenResult(): EventTssKeyGenResult {
  return { sender: "", keygenId: "", tssSigners: [], tssPoolPk: "" };
}

export const EventTssKeyGenResult: MessageFns<EventTssKeyGenResult> = {
  encode(message: EventTssKeyGenResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.keygenId !== "") {
      writer.uint32(18).string(message.keygenId);
    }
    for (const v of message.tssSigners) {
      writer.uint32(26).string(v!);
    }
    if (message.tssPoolPk !== "") {
      writer.uint32(34).string(message.tssPoolPk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventTssKeyGenResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTssKeyGenResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tssSigners.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tssPoolPk = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTssKeyGenResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
      tssSigners: globalThis.Array.isArray(object?.tssSigners)
        ? object.tssSigners.map((e: any) => globalThis.String(e))
        : [],
      tssPoolPk: isSet(object.tssPoolPk) ? globalThis.String(object.tssPoolPk) : "",
    };
  },

  toJSON(message: EventTssKeyGenResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    if (message.tssSigners?.length) {
      obj.tssSigners = message.tssSigners;
    }
    if (message.tssPoolPk !== "") {
      obj.tssPoolPk = message.tssPoolPk;
    }
    return obj;
  },

  create(base?: DeepPartial<EventTssKeyGenResult>): EventTssKeyGenResult {
    return EventTssKeyGenResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventTssKeyGenResult>): EventTssKeyGenResult {
    const message = createBaseEventTssKeyGenResult();
    message.sender = object.sender ?? "";
    message.keygenId = object.keygenId ?? "";
    message.tssSigners = object.tssSigners?.map((e) => e) || [];
    message.tssPoolPk = object.tssPoolPk ?? "";
    return message;
  },
};

function createBaseEventTssVaultMigration(): EventTssVaultMigration {
  return { sender: "", chains: [], keygenId: "", skipVaultUpdate: false };
}

export const EventTssVaultMigration: MessageFns<EventTssVaultMigration> = {
  encode(message: EventTssVaultMigration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.chains) {
      TssChainToMigrate.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.keygenId !== "") {
      writer.uint32(26).string(message.keygenId);
    }
    if (message.skipVaultUpdate !== false) {
      writer.uint32(32).bool(message.skipVaultUpdate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventTssVaultMigration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTssVaultMigration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chains.push(TssChainToMigrate.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skipVaultUpdate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTssVaultMigration {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chains: globalThis.Array.isArray(object?.chains)
        ? object.chains.map((e: any) => TssChainToMigrate.fromJSON(e))
        : [],
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
      skipVaultUpdate: isSet(object.skipVaultUpdate) ? globalThis.Boolean(object.skipVaultUpdate) : false,
    };
  },

  toJSON(message: EventTssVaultMigration): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => TssChainToMigrate.toJSON(e));
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    if (message.skipVaultUpdate !== false) {
      obj.skipVaultUpdate = message.skipVaultUpdate;
    }
    return obj;
  },

  create(base?: DeepPartial<EventTssVaultMigration>): EventTssVaultMigration {
    return EventTssVaultMigration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventTssVaultMigration>): EventTssVaultMigration {
    const message = createBaseEventTssVaultMigration();
    message.sender = object.sender ?? "";
    message.chains = object.chains?.map((e) => TssChainToMigrate.fromPartial(e)) || [];
    message.keygenId = object.keygenId ?? "";
    message.skipVaultUpdate = object.skipVaultUpdate ?? false;
    return message;
  },
};

function createBaseEventTssVaultUpdate(): EventTssVaultUpdate {
  return { sender: "", chainIds: [], keygenId: "" };
}

export const EventTssVaultUpdate: MessageFns<EventTssVaultUpdate> = {
  encode(message: EventTssVaultUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.chainIds) {
      writer.uint32(18).string(v!);
    }
    if (message.keygenId !== "") {
      writer.uint32(26).string(message.keygenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventTssVaultUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTssVaultUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTssVaultUpdate {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainIds: globalThis.Array.isArray(object?.chainIds) ? object.chainIds.map((e: any) => globalThis.String(e)) : [],
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
    };
  },

  toJSON(message: EventTssVaultUpdate): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainIds?.length) {
      obj.chainIds = message.chainIds;
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    return obj;
  },

  create(base?: DeepPartial<EventTssVaultUpdate>): EventTssVaultUpdate {
    return EventTssVaultUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventTssVaultUpdate>): EventTssVaultUpdate {
    const message = createBaseEventTssVaultUpdate();
    message.sender = object.sender ?? "";
    message.chainIds = object.chainIds?.map((e) => e) || [];
    message.keygenId = object.keygenId ?? "";
    return message;
  },
};

function createBaseEventPruneSmartContractChainContract(): EventPruneSmartContractChainContract {
  return { sender: "", chainId: "", pruneBefore: Long.UZERO };
}

export const EventPruneSmartContractChainContract: MessageFns<EventPruneSmartContractChainContract> = {
  encode(message: EventPruneSmartContractChainContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pruneBefore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventPruneSmartContractChainContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPruneSmartContractChainContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPruneSmartContractChainContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
    };
  },

  toJSON(message: EventPruneSmartContractChainContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventPruneSmartContractChainContract>): EventPruneSmartContractChainContract {
    return EventPruneSmartContractChainContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventPruneSmartContractChainContract>): EventPruneSmartContractChainContract {
    const message = createBaseEventPruneSmartContractChainContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventUpgradeSmartContractChainContract(): EventUpgradeSmartContractChainContract {
  return { sender: "", chainId: "", upgradeData: undefined };
}

export const EventUpgradeSmartContractChainContract: MessageFns<EventUpgradeSmartContractChainContract> = {
  encode(message: EventUpgradeSmartContractChainContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpgradeSmartContractChainContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpgradeSmartContractChainContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpgradeSmartContractChainContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
    };
  },

  toJSON(message: EventUpgradeSmartContractChainContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpgradeSmartContractChainContract>): EventUpgradeSmartContractChainContract {
    return EventUpgradeSmartContractChainContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpgradeSmartContractChainContract>): EventUpgradeSmartContractChainContract {
    const message = createBaseEventUpgradeSmartContractChainContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    return message;
  },
};

function createBaseEventSetSmartContractChainAssetsDestChainIds(): EventSetSmartContractChainAssetsDestChainIds {
  return { sender: "", chainId: "", assets: [] };
}

export const EventSetSmartContractChainAssetsDestChainIds: MessageFns<EventSetSmartContractChainAssetsDestChainIds> = {
  encode(
    message: EventSetSmartContractChainAssetsDestChainIds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.assets) {
      AssetDestChainIds.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetSmartContractChainAssetsDestChainIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetSmartContractChainAssetsDestChainIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assets.push(AssetDestChainIds.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetSmartContractChainAssetsDestChainIds {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assets: globalThis.Array.isArray(object?.assets)
        ? object.assets.map((e: any) => AssetDestChainIds.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventSetSmartContractChainAssetsDestChainIds): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => AssetDestChainIds.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<EventSetSmartContractChainAssetsDestChainIds>,
  ): EventSetSmartContractChainAssetsDestChainIds {
    return EventSetSmartContractChainAssetsDestChainIds.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<EventSetSmartContractChainAssetsDestChainIds>,
  ): EventSetSmartContractChainAssetsDestChainIds {
    const message = createBaseEventSetSmartContractChainAssetsDestChainIds();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assets = object.assets?.map((e) => AssetDestChainIds.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventAddSmartContractChainAsset(): EventAddSmartContractChainAsset {
  return { sender: "", asset: undefined };
}

export const EventAddSmartContractChainAsset: MessageFns<EventAddSmartContractChainAsset> = {
  encode(message: EventAddSmartContractChainAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.asset !== undefined) {
      SmartContractAsset.encode(message.asset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAddSmartContractChainAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAddSmartContractChainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.asset = SmartContractAsset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAddSmartContractChainAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      asset: isSet(object.asset) ? SmartContractAsset.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventAddSmartContractChainAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.asset !== undefined) {
      obj.asset = SmartContractAsset.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventAddSmartContractChainAsset>): EventAddSmartContractChainAsset {
    return EventAddSmartContractChainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventAddSmartContractChainAsset>): EventAddSmartContractChainAsset {
    const message = createBaseEventAddSmartContractChainAsset();
    message.sender = object.sender ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? SmartContractAsset.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseEventUpdateIbcChainParams(): EventUpdateIbcChainParams {
  return { sender: "", chainId: "", channelId: "", portId: "", timeout: Long.UZERO };
}

export const EventUpdateIbcChainParams: MessageFns<EventUpdateIbcChainParams> = {
  encode(message: EventUpdateIbcChainParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.channelId !== "") {
      writer.uint32(26).string(message.channelId);
    }
    if (message.portId !== "") {
      writer.uint32(34).string(message.portId);
    }
    if (!message.timeout.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.timeout.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateIbcChainParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateIbcChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.portId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timeout = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateIbcChainParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      portId: isSet(object.portId) ? globalThis.String(object.portId) : "",
      timeout: isSet(object.timeout) ? Long.fromValue(object.timeout) : Long.UZERO,
    };
  },

  toJSON(message: EventUpdateIbcChainParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.portId !== "") {
      obj.portId = message.portId;
    }
    if (!message.timeout.equals(Long.UZERO)) {
      obj.timeout = (message.timeout || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateIbcChainParams>): EventUpdateIbcChainParams {
    return EventUpdateIbcChainParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateIbcChainParams>): EventUpdateIbcChainParams {
    const message = createBaseEventUpdateIbcChainParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.channelId = object.channelId ?? "";
    message.portId = object.portId ?? "";
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Long.fromValue(object.timeout)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventAddIbcChainAsset(): EventAddIbcChainAsset {
  return { sender: "", chainId: "", asset: undefined };
}

export const EventAddIbcChainAsset: MessageFns<EventAddIbcChainAsset> = {
  encode(message: EventAddIbcChainAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      IbcAsset.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAddIbcChainAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAddIbcChainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = IbcAsset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAddIbcChainAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? IbcAsset.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventAddIbcChainAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = IbcAsset.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventAddIbcChainAsset>): EventAddIbcChainAsset {
    return EventAddIbcChainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventAddIbcChainAsset>): EventAddIbcChainAsset {
    const message = createBaseEventAddIbcChainAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? IbcAsset.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseEventUpdateIbcChainAssetParams(): EventUpdateIbcChainAssetParams {
  return { sender: "", chainId: "", assetId: undefined, localIbcDenom: "", externalIbcDenom: "", swap: undefined };
}

export const EventUpdateIbcChainAssetParams: MessageFns<EventUpdateIbcChainAssetParams> = {
  encode(message: EventUpdateIbcChainAssetParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.localIbcDenom !== "") {
      writer.uint32(34).string(message.localIbcDenom);
    }
    if (message.externalIbcDenom !== "") {
      writer.uint32(42).string(message.externalIbcDenom);
    }
    if (message.swap !== undefined) {
      IbcAssetSwap.encode(message.swap, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateIbcChainAssetParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateIbcChainAssetParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.localIbcDenom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalIbcDenom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.swap = IbcAssetSwap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateIbcChainAssetParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      localIbcDenom: isSet(object.localIbcDenom) ? globalThis.String(object.localIbcDenom) : "",
      externalIbcDenom: isSet(object.externalIbcDenom) ? globalThis.String(object.externalIbcDenom) : "",
      swap: isSet(object.swap) ? IbcAssetSwap.fromJSON(object.swap) : undefined,
    };
  },

  toJSON(message: EventUpdateIbcChainAssetParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.localIbcDenom !== "") {
      obj.localIbcDenom = message.localIbcDenom;
    }
    if (message.externalIbcDenom !== "") {
      obj.externalIbcDenom = message.externalIbcDenom;
    }
    if (message.swap !== undefined) {
      obj.swap = IbcAssetSwap.toJSON(message.swap);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateIbcChainAssetParams>): EventUpdateIbcChainAssetParams {
    return EventUpdateIbcChainAssetParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateIbcChainAssetParams>): EventUpdateIbcChainAssetParams {
    const message = createBaseEventUpdateIbcChainAssetParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.localIbcDenom = object.localIbcDenom ?? "";
    message.externalIbcDenom = object.externalIbcDenom ?? "";
    message.swap = (object.swap !== undefined && object.swap !== null)
      ? IbcAssetSwap.fromPartial(object.swap)
      : undefined;
    return message;
  },
};

function createBaseEventChangeAssetStatus(): EventChangeAssetStatus {
  return { sender: "", assetId: undefined, oldStatus: 0, newStatus: 0 };
}

export const EventChangeAssetStatus: MessageFns<EventChangeAssetStatus> = {
  encode(message: EventChangeAssetStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(18).fork()).join();
    }
    if (message.oldStatus !== 0) {
      writer.uint32(24).int32(message.oldStatus);
    }
    if (message.newStatus !== 0) {
      writer.uint32(32).int32(message.newStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventChangeAssetStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventChangeAssetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.oldStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventChangeAssetStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      oldStatus: isSet(object.oldStatus) ? assetStatusFromJSON(object.oldStatus) : 0,
      newStatus: isSet(object.newStatus) ? assetStatusFromJSON(object.newStatus) : 0,
    };
  },

  toJSON(message: EventChangeAssetStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.oldStatus !== 0) {
      obj.oldStatus = assetStatusToJSON(message.oldStatus);
    }
    if (message.newStatus !== 0) {
      obj.newStatus = assetStatusToJSON(message.newStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<EventChangeAssetStatus>): EventChangeAssetStatus {
    return EventChangeAssetStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventChangeAssetStatus>): EventChangeAssetStatus {
    const message = createBaseEventChangeAssetStatus();
    message.sender = object.sender ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.oldStatus = object.oldStatus ?? 0;
    message.newStatus = object.newStatus ?? 0;
    return message;
  },
};

function createBaseEventUpdateSigners(): EventUpdateSigners {
  return { sender: "", CreatedSigners: [], DeletedSigners: [] };
}

export const EventUpdateSigners: MessageFns<EventUpdateSigners> = {
  encode(message: EventUpdateSigners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.CreatedSigners) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.DeletedSigners) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateSigners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateSigners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.CreatedSigners.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.DeletedSigners.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateSigners {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      CreatedSigners: globalThis.Array.isArray(object?.CreatedSigners)
        ? object.CreatedSigners.map((e: any) => globalThis.String(e))
        : [],
      DeletedSigners: globalThis.Array.isArray(object?.DeletedSigners)
        ? object.DeletedSigners.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EventUpdateSigners): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.CreatedSigners?.length) {
      obj.CreatedSigners = message.CreatedSigners;
    }
    if (message.DeletedSigners?.length) {
      obj.DeletedSigners = message.DeletedSigners;
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateSigners>): EventUpdateSigners {
    return EventUpdateSigners.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateSigners>): EventUpdateSigners {
    const message = createBaseEventUpdateSigners();
    message.sender = object.sender ?? "";
    message.CreatedSigners = object.CreatedSigners?.map((e) => e) || [];
    message.DeletedSigners = object.DeletedSigners?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventUpdateParams(): EventUpdateParams {
  return { sender: "", newVotesNeeded: Long.UZERO, newFee: "" };
}

export const EventUpdateParams: MessageFns<EventUpdateParams> = {
  encode(message: EventUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (!message.newVotesNeeded.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.newVotesNeeded.toString());
    }
    if (message.newFee !== "") {
      writer.uint32(26).string(message.newFee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newVotesNeeded = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newFee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      newVotesNeeded: isSet(object.newVotesNeeded) ? Long.fromValue(object.newVotesNeeded) : Long.UZERO,
      newFee: isSet(object.newFee) ? globalThis.String(object.newFee) : "",
    };
  },

  toJSON(message: EventUpdateParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (!message.newVotesNeeded.equals(Long.UZERO)) {
      obj.newVotesNeeded = (message.newVotesNeeded || Long.UZERO).toString();
    }
    if (message.newFee !== "") {
      obj.newFee = message.newFee;
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateParams>): EventUpdateParams {
    return EventUpdateParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateParams>): EventUpdateParams {
    const message = createBaseEventUpdateParams();
    message.sender = object.sender ?? "";
    message.newVotesNeeded = (object.newVotesNeeded !== undefined && object.newVotesNeeded !== null)
      ? Long.fromValue(object.newVotesNeeded)
      : Long.UZERO;
    message.newFee = object.newFee ?? "";
    return message;
  },
};

function createBaseEventUpdateIbcForwardingParams(): EventUpdateIbcForwardingParams {
  return { sender: "", params: [] };
}

export const EventUpdateIbcForwardingParams: MessageFns<EventUpdateIbcForwardingParams> = {
  encode(message: EventUpdateIbcForwardingParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.params) {
      IbcForwardingParams.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateIbcForwardingParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateIbcForwardingParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params.push(IbcForwardingParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateIbcForwardingParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => IbcForwardingParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventUpdateIbcForwardingParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => IbcForwardingParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateIbcForwardingParams>): EventUpdateIbcForwardingParams {
    return EventUpdateIbcForwardingParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateIbcForwardingParams>): EventUpdateIbcForwardingParams {
    const message = createBaseEventUpdateIbcForwardingParams();
    message.sender = object.sender ?? "";
    message.params = object.params?.map((e) => IbcForwardingParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventUpdateContractSigners(): EventUpdateContractSigners {
  return { sender: "", signers: [] };
}

export const EventUpdateContractSigners: MessageFns<EventUpdateContractSigners> = {
  encode(message: EventUpdateContractSigners, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.signers) {
      ContractSigners.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateContractSigners {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateContractSigners();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signers.push(ContractSigners.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateContractSigners {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => ContractSigners.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventUpdateContractSigners): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => ContractSigners.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateContractSigners>): EventUpdateContractSigners {
    return EventUpdateContractSigners.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateContractSigners>): EventUpdateContractSigners {
    const message = createBaseEventUpdateContractSigners();
    message.sender = object.sender ?? "";
    message.signers = object.signers?.map((e) => ContractSigners.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventSubmitUpdateContractSignersResult(): EventSubmitUpdateContractSignersResult {
  return { sender: "", updateId: "", signers: [] };
}

export const EventSubmitUpdateContractSignersResult: MessageFns<EventSubmitUpdateContractSignersResult> = {
  encode(message: EventSubmitUpdateContractSignersResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.updateId !== "") {
      writer.uint32(18).string(message.updateId);
    }
    for (const v of message.signers) {
      ContractSigners.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitUpdateContractSignersResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitUpdateContractSignersResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signers.push(ContractSigners.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitUpdateContractSignersResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => ContractSigners.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventSubmitUpdateContractSignersResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => ContractSigners.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitUpdateContractSignersResult>): EventSubmitUpdateContractSignersResult {
    return EventSubmitUpdateContractSignersResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitUpdateContractSignersResult>): EventSubmitUpdateContractSignersResult {
    const message = createBaseEventSubmitUpdateContractSignersResult();
    message.sender = object.sender ?? "";
    message.updateId = object.updateId ?? "";
    message.signers = object.signers?.map((e) => ContractSigners.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventUpdateContractParams(): EventUpdateContractParams {
  return { sender: "", chainId: "", contractAddress: "", fees: [], assetParams: [] };
}

export const EventUpdateContractParams: MessageFns<EventUpdateContractParams> = {
  encode(message: EventUpdateContractParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateContractParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateContractParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateContractParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventUpdateContractParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateContractParams>): EventUpdateContractParams {
    return EventUpdateContractParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateContractParams>): EventUpdateContractParams {
    const message = createBaseEventUpdateContractParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventSubmitUpdateContractParamsResult(): EventSubmitUpdateContractParamsResult {
  return { sender: "", updateId: "", chainId: "", contractAddress: "", fees: [], assetParams: [] };
}

export const EventSubmitUpdateContractParamsResult: MessageFns<EventSubmitUpdateContractParamsResult> = {
  encode(message: EventSubmitUpdateContractParamsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.updateId !== "") {
      writer.uint32(18).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.contractAddress !== "") {
      writer.uint32(34).string(message.contractAddress);
    }
    for (const v of message.fees) {
      ContractFee.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.assetParams) {
      ContractAssetParams.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitUpdateContractParamsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitUpdateContractParamsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fees.push(ContractFee.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetParams.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitUpdateContractParamsResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => ContractFee.fromJSON(e)) : [],
      assetParams: globalThis.Array.isArray(object?.assetParams)
        ? object.assetParams.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventSubmitUpdateContractParamsResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => ContractFee.toJSON(e));
    }
    if (message.assetParams?.length) {
      obj.assetParams = message.assetParams.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitUpdateContractParamsResult>): EventSubmitUpdateContractParamsResult {
    return EventSubmitUpdateContractParamsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitUpdateContractParamsResult>): EventSubmitUpdateContractParamsResult {
    const message = createBaseEventSubmitUpdateContractParamsResult();
    message.sender = object.sender ?? "";
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.fees = object.fees?.map((e) => ContractFee.fromPartial(e)) || [];
    message.assetParams = object.assetParams?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventUpdateContractStatus(): EventUpdateContractStatus {
  return { sender: "", chainId: "", status: 0 };
}

export const EventUpdateContractStatus: MessageFns<EventUpdateContractStatus> = {
  encode(message: EventUpdateContractStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateContractStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateContractStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateContractStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? contractStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EventUpdateContractStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = contractStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateContractStatus>): EventUpdateContractStatus {
    return EventUpdateContractStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateContractStatus>): EventUpdateContractStatus {
    const message = createBaseEventUpdateContractStatus();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseEventSubmitUpdateContractStatusResult(): EventSubmitUpdateContractStatusResult {
  return { sender: "", updateId: "", chainId: "", status: 0 };
}

export const EventSubmitUpdateContractStatusResult: MessageFns<EventSubmitUpdateContractStatusResult> = {
  encode(message: EventSubmitUpdateContractStatusResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.updateId !== "") {
      writer.uint32(18).string(message.updateId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitUpdateContractStatusResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitUpdateContractStatusResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitUpdateContractStatusResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      status: isSet(object.status) ? contractStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EventSubmitUpdateContractStatusResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.status !== 0) {
      obj.status = contractStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitUpdateContractStatusResult>): EventSubmitUpdateContractStatusResult {
    return EventSubmitUpdateContractStatusResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitUpdateContractStatusResult>): EventSubmitUpdateContractStatusResult {
    const message = createBaseEventSubmitUpdateContractStatusResult();
    message.sender = object.sender ?? "";
    message.updateId = object.updateId ?? "";
    message.chainId = object.chainId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseEventPruneContract(): EventPruneContract {
  return { sender: "", chainId: "", pruneBefore: Long.UZERO };
}

export const EventPruneContract: MessageFns<EventPruneContract> = {
  encode(message: EventPruneContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.pruneBefore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventPruneContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPruneContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPruneContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
    };
  },

  toJSON(message: EventPruneContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventPruneContract>): EventPruneContract {
    return EventPruneContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventPruneContract>): EventPruneContract {
    const message = createBaseEventPruneContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventSubmitPruneContractResult(): EventSubmitPruneContractResult {
  return { sender: "", pruneId: "", chainId: "", pruneBefore: Long.UZERO };
}

export const EventSubmitPruneContractResult: MessageFns<EventSubmitPruneContractResult> = {
  encode(message: EventSubmitPruneContractResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.pruneId !== "") {
      writer.uint32(18).string(message.pruneId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.pruneBefore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitPruneContractResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitPruneContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pruneId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pruneBefore = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitPruneContractResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      pruneId: isSet(object.pruneId) ? globalThis.String(object.pruneId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      pruneBefore: isSet(object.pruneBefore) ? Long.fromValue(object.pruneBefore) : Long.UZERO,
    };
  },

  toJSON(message: EventSubmitPruneContractResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.pruneId !== "") {
      obj.pruneId = message.pruneId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (!message.pruneBefore.equals(Long.UZERO)) {
      obj.pruneBefore = (message.pruneBefore || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitPruneContractResult>): EventSubmitPruneContractResult {
    return EventSubmitPruneContractResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitPruneContractResult>): EventSubmitPruneContractResult {
    const message = createBaseEventSubmitPruneContractResult();
    message.sender = object.sender ?? "";
    message.pruneId = object.pruneId ?? "";
    message.chainId = object.chainId ?? "";
    message.pruneBefore = (object.pruneBefore !== undefined && object.pruneBefore !== null)
      ? Long.fromValue(object.pruneBefore)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventUpgradeContract(): EventUpgradeContract {
  return { sender: "", chainId: "", upgradeData: undefined };
}

export const EventUpgradeContract: MessageFns<EventUpgradeContract> = {
  encode(message: EventUpgradeContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpgradeContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpgradeContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpgradeContract {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
    };
  },

  toJSON(message: EventUpgradeContract): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpgradeContract>): EventUpgradeContract {
    return EventUpgradeContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpgradeContract>): EventUpgradeContract {
    const message = createBaseEventUpgradeContract();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    return message;
  },
};

function createBaseEventSubmitUpgradeContractResult(): EventSubmitUpgradeContractResult {
  return { sender: "", upgradeId: "", chainId: "", upgradeData: undefined };
}

export const EventSubmitUpgradeContractResult: MessageFns<EventSubmitUpgradeContractResult> = {
  encode(message: EventSubmitUpgradeContractResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.upgradeId !== "") {
      writer.uint32(18).string(message.upgradeId);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.upgradeData !== undefined) {
      ContractUpgradeData.encode(message.upgradeData, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitUpgradeContractResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitUpgradeContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.upgradeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.upgradeData = ContractUpgradeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitUpgradeContractResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      upgradeId: isSet(object.upgradeId) ? globalThis.String(object.upgradeId) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      upgradeData: isSet(object.upgradeData) ? ContractUpgradeData.fromJSON(object.upgradeData) : undefined,
    };
  },

  toJSON(message: EventSubmitUpgradeContractResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.upgradeId !== "") {
      obj.upgradeId = message.upgradeId;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.upgradeData !== undefined) {
      obj.upgradeData = ContractUpgradeData.toJSON(message.upgradeData);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitUpgradeContractResult>): EventSubmitUpgradeContractResult {
    return EventSubmitUpgradeContractResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitUpgradeContractResult>): EventSubmitUpgradeContractResult {
    const message = createBaseEventSubmitUpgradeContractResult();
    message.sender = object.sender ?? "";
    message.upgradeId = object.upgradeId ?? "";
    message.chainId = object.chainId ?? "";
    message.upgradeData = (object.upgradeData !== undefined && object.upgradeData !== null)
      ? ContractUpgradeData.fromPartial(object.upgradeData)
      : undefined;
    return message;
  },
};

function createBaseEventAddContractAssets(): EventAddContractAssets {
  return { sender: "", chainId: "", newAssets: [] };
}

export const EventAddContractAssets: MessageFns<EventAddContractAssets> = {
  encode(message: EventAddContractAssets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    for (const v of message.newAssets) {
      ContractAssetParams.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAddContractAssets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAddContractAssets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAssets.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAddContractAssets {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      newAssets: globalThis.Array.isArray(object?.newAssets)
        ? object.newAssets.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventAddContractAssets): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.newAssets?.length) {
      obj.newAssets = message.newAssets.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventAddContractAssets>): EventAddContractAssets {
    return EventAddContractAssets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventAddContractAssets>): EventAddContractAssets {
    const message = createBaseEventAddContractAssets();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.newAssets = object.newAssets?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventSubmitAddContractAssetsResult(): EventSubmitAddContractAssetsResult {
  return { sender: "", id: "", chainId: "", newAssets: [] };
}

export const EventSubmitAddContractAssetsResult: MessageFns<EventSubmitAddContractAssetsResult> = {
  encode(message: EventSubmitAddContractAssetsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    for (const v of message.newAssets) {
      ContractAssetParams.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitAddContractAssetsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitAddContractAssetsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newAssets.push(ContractAssetParams.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitAddContractAssetsResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      newAssets: globalThis.Array.isArray(object?.newAssets)
        ? object.newAssets.map((e: any) => ContractAssetParams.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventSubmitAddContractAssetsResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.newAssets?.length) {
      obj.newAssets = message.newAssets.map((e) => ContractAssetParams.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitAddContractAssetsResult>): EventSubmitAddContractAssetsResult {
    return EventSubmitAddContractAssetsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitAddContractAssetsResult>): EventSubmitAddContractAssetsResult {
    const message = createBaseEventSubmitAddContractAssetsResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.newAssets = object.newAssets?.map((e) => ContractAssetParams.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventDeleteContractAsset(): EventDeleteContractAsset {
  return { sender: "", chainId: "", assetAddress: "" };
}

export const EventDeleteContractAsset: MessageFns<EventDeleteContractAsset> = {
  encode(message: EventDeleteContractAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetAddress !== "") {
      writer.uint32(26).string(message.assetAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventDeleteContractAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDeleteContractAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventDeleteContractAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetAddress: isSet(object.assetAddress) ? globalThis.String(object.assetAddress) : "",
    };
  },

  toJSON(message: EventDeleteContractAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetAddress !== "") {
      obj.assetAddress = message.assetAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<EventDeleteContractAsset>): EventDeleteContractAsset {
    return EventDeleteContractAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventDeleteContractAsset>): EventDeleteContractAsset {
    const message = createBaseEventDeleteContractAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetAddress = object.assetAddress ?? "";
    return message;
  },
};

function createBaseEventSubmitDeleteContractAssetResult(): EventSubmitDeleteContractAssetResult {
  return { sender: "", id: "", chainId: "", assetAddress: "" };
}

export const EventSubmitDeleteContractAssetResult: MessageFns<EventSubmitDeleteContractAssetResult> = {
  encode(message: EventSubmitDeleteContractAssetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.assetAddress !== "") {
      writer.uint32(34).string(message.assetAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitDeleteContractAssetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitDeleteContractAssetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assetAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitDeleteContractAssetResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetAddress: isSet(object.assetAddress) ? globalThis.String(object.assetAddress) : "",
    };
  },

  toJSON(message: EventSubmitDeleteContractAssetResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetAddress !== "") {
      obj.assetAddress = message.assetAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitDeleteContractAssetResult>): EventSubmitDeleteContractAssetResult {
    return EventSubmitDeleteContractAssetResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitDeleteContractAssetResult>): EventSubmitDeleteContractAssetResult {
    const message = createBaseEventSubmitDeleteContractAssetResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.assetAddress = object.assetAddress ?? "";
    return message;
  },
};

function createBaseEventWhitelistContractAsset(): EventWhitelistContractAsset {
  return { sender: "", chainId: "", asset: undefined };
}

export const EventWhitelistContractAsset: MessageFns<EventWhitelistContractAsset> = {
  encode(message: EventWhitelistContractAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventWhitelistContractAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventWhitelistContractAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventWhitelistContractAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventWhitelistContractAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventWhitelistContractAsset>): EventWhitelistContractAsset {
    return EventWhitelistContractAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventWhitelistContractAsset>): EventWhitelistContractAsset {
    const message = createBaseEventWhitelistContractAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseEventSubmitWhitelistContractAssetResult(): EventSubmitWhitelistContractAssetResult {
  return { sender: "", id: "", chainId: "", asset: undefined };
}

export const EventSubmitWhitelistContractAssetResult: MessageFns<EventSubmitWhitelistContractAssetResult> = {
  encode(message: EventSubmitWhitelistContractAssetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitWhitelistContractAssetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitWhitelistContractAssetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitWhitelistContractAssetResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventSubmitWhitelistContractAssetResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitWhitelistContractAssetResult>): EventSubmitWhitelistContractAssetResult {
    return EventSubmitWhitelistContractAssetResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSubmitWhitelistContractAssetResult>): EventSubmitWhitelistContractAssetResult {
    const message = createBaseEventSubmitWhitelistContractAssetResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseEventUnwhitelistContractAsset(): EventUnwhitelistContractAsset {
  return { sender: "", chainId: "", asset: undefined };
}

export const EventUnwhitelistContractAsset: MessageFns<EventUnwhitelistContractAsset> = {
  encode(message: EventUnwhitelistContractAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUnwhitelistContractAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUnwhitelistContractAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUnwhitelistContractAsset {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventUnwhitelistContractAsset): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventUnwhitelistContractAsset>): EventUnwhitelistContractAsset {
    return EventUnwhitelistContractAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUnwhitelistContractAsset>): EventUnwhitelistContractAsset {
    const message = createBaseEventUnwhitelistContractAsset();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseEventSubmitUnwhitelistContractAssetResult(): EventSubmitUnwhitelistContractAssetResult {
  return { sender: "", id: "", chainId: "", asset: undefined };
}

export const EventSubmitUnwhitelistContractAssetResult: MessageFns<EventSubmitUnwhitelistContractAssetResult> = {
  encode(message: EventSubmitUnwhitelistContractAssetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.asset !== undefined) {
      ContractAssetId.encode(message.asset, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSubmitUnwhitelistContractAssetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSubmitUnwhitelistContractAssetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.asset = ContractAssetId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSubmitUnwhitelistContractAssetResult {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      asset: isSet(object.asset) ? ContractAssetId.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: EventSubmitUnwhitelistContractAssetResult): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.asset !== undefined) {
      obj.asset = ContractAssetId.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<EventSubmitUnwhitelistContractAssetResult>): EventSubmitUnwhitelistContractAssetResult {
    return EventSubmitUnwhitelistContractAssetResult.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<EventSubmitUnwhitelistContractAssetResult>,
  ): EventSubmitUnwhitelistContractAssetResult {
    const message = createBaseEventSubmitUnwhitelistContractAssetResult();
    message.sender = object.sender ?? "";
    message.id = object.id ?? "";
    message.chainId = object.chainId ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? ContractAssetId.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseEventUpdateNttChainParams(): EventUpdateNttChainParams {
  return { sender: "", chainId: "", wormholeProgram: "", nttChainId: Long.UZERO };
}

export const EventUpdateNttChainParams: MessageFns<EventUpdateNttChainParams> = {
  encode(message: EventUpdateNttChainParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.wormholeProgram !== "") {
      writer.uint32(26).string(message.wormholeProgram);
    }
    if (!message.nttChainId.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.nttChainId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateNttChainParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateNttChainParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wormholeProgram = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nttChainId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateNttChainParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      wormholeProgram: isSet(object.wormholeProgram) ? globalThis.String(object.wormholeProgram) : "",
      nttChainId: isSet(object.nttChainId) ? Long.fromValue(object.nttChainId) : Long.UZERO,
    };
  },

  toJSON(message: EventUpdateNttChainParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.wormholeProgram !== "") {
      obj.wormholeProgram = message.wormholeProgram;
    }
    if (!message.nttChainId.equals(Long.UZERO)) {
      obj.nttChainId = (message.nttChainId || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateNttChainParams>): EventUpdateNttChainParams {
    return EventUpdateNttChainParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateNttChainParams>): EventUpdateNttChainParams {
    const message = createBaseEventUpdateNttChainParams();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.wormholeProgram = object.wormholeProgram ?? "";
    message.nttChainId = (object.nttChainId !== undefined && object.nttChainId !== null)
      ? Long.fromValue(object.nttChainId)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventUpdateNttChainAssetAddresses(): EventUpdateNttChainAssetAddresses {
  return {
    sender: "",
    chainId: "",
    assetId: undefined,
    nttManagerAddress: "",
    externalNttManagerAddress: "",
    externalTokenAddress: "",
    nttTransceivers: [],
    externalNttTransceivers: [],
  };
}

export const EventUpdateNttChainAssetAddresses: MessageFns<EventUpdateNttChainAssetAddresses> = {
  encode(message: EventUpdateNttChainAssetAddresses, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.assetId !== undefined) {
      AssetID.encode(message.assetId, writer.uint32(26).fork()).join();
    }
    if (message.nttManagerAddress !== "") {
      writer.uint32(34).string(message.nttManagerAddress);
    }
    if (message.externalNttManagerAddress !== "") {
      writer.uint32(42).string(message.externalNttManagerAddress);
    }
    if (message.externalTokenAddress !== "") {
      writer.uint32(50).string(message.externalTokenAddress);
    }
    for (const v of message.nttTransceivers) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.externalNttTransceivers) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdateNttChainAssetAddresses {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateNttChainAssetAddresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = AssetID.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nttManagerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalNttManagerAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalTokenAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nttTransceivers.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.externalNttTransceivers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdateNttChainAssetAddresses {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      assetId: isSet(object.assetId) ? AssetID.fromJSON(object.assetId) : undefined,
      nttManagerAddress: isSet(object.nttManagerAddress) ? globalThis.String(object.nttManagerAddress) : "",
      externalNttManagerAddress: isSet(object.externalNttManagerAddress)
        ? globalThis.String(object.externalNttManagerAddress)
        : "",
      externalTokenAddress: isSet(object.externalTokenAddress) ? globalThis.String(object.externalTokenAddress) : "",
      nttTransceivers: globalThis.Array.isArray(object?.nttTransceivers)
        ? object.nttTransceivers.map((e: any) => globalThis.String(e))
        : [],
      externalNttTransceivers: globalThis.Array.isArray(object?.externalNttTransceivers)
        ? object.externalNttTransceivers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EventUpdateNttChainAssetAddresses): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.assetId !== undefined) {
      obj.assetId = AssetID.toJSON(message.assetId);
    }
    if (message.nttManagerAddress !== "") {
      obj.nttManagerAddress = message.nttManagerAddress;
    }
    if (message.externalNttManagerAddress !== "") {
      obj.externalNttManagerAddress = message.externalNttManagerAddress;
    }
    if (message.externalTokenAddress !== "") {
      obj.externalTokenAddress = message.externalTokenAddress;
    }
    if (message.nttTransceivers?.length) {
      obj.nttTransceivers = message.nttTransceivers;
    }
    if (message.externalNttTransceivers?.length) {
      obj.externalNttTransceivers = message.externalNttTransceivers;
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdateNttChainAssetAddresses>): EventUpdateNttChainAssetAddresses {
    return EventUpdateNttChainAssetAddresses.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdateNttChainAssetAddresses>): EventUpdateNttChainAssetAddresses {
    const message = createBaseEventUpdateNttChainAssetAddresses();
    message.sender = object.sender ?? "";
    message.chainId = object.chainId ?? "";
    message.assetId = (object.assetId !== undefined && object.assetId !== null)
      ? AssetID.fromPartial(object.assetId)
      : undefined;
    message.nttManagerAddress = object.nttManagerAddress ?? "";
    message.externalNttManagerAddress = object.externalNttManagerAddress ?? "";
    message.externalTokenAddress = object.externalTokenAddress ?? "";
    message.nttTransceivers = object.nttTransceivers?.map((e) => e) || [];
    message.externalNttTransceivers = object.externalNttTransceivers?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventVoteQuarantinedEntity(): EventVoteQuarantinedEntity {
  return { sender: "", entityId: "", votingResult: 0 };
}

export const EventVoteQuarantinedEntity: MessageFns<EventVoteQuarantinedEntity> = {
  encode(message: EventVoteQuarantinedEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.entityId !== "") {
      writer.uint32(18).string(message.entityId);
    }
    if (message.votingResult !== 0) {
      writer.uint32(24).int32(message.votingResult);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventVoteQuarantinedEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventVoteQuarantinedEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.votingResult = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventVoteQuarantinedEntity {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      votingResult: isSet(object.votingResult) ? quarantineVotingResultFromJSON(object.votingResult) : 0,
    };
  },

  toJSON(message: EventVoteQuarantinedEntity): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.votingResult !== 0) {
      obj.votingResult = quarantineVotingResultToJSON(message.votingResult);
    }
    return obj;
  },

  create(base?: DeepPartial<EventVoteQuarantinedEntity>): EventVoteQuarantinedEntity {
    return EventVoteQuarantinedEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventVoteQuarantinedEntity>): EventVoteQuarantinedEntity {
    const message = createBaseEventVoteQuarantinedEntity();
    message.sender = object.sender ?? "";
    message.entityId = object.entityId ?? "";
    message.votingResult = object.votingResult ?? 0;
    return message;
  },
};

function createBaseEventSetTssVaultFromKeygen(): EventSetTssVaultFromKeygen {
  return { sender: "", chainIds: [], keygenId: "" };
}

export const EventSetTssVaultFromKeygen: MessageFns<EventSetTssVaultFromKeygen> = {
  encode(message: EventSetTssVaultFromKeygen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.chainIds) {
      writer.uint32(18).string(v!);
    }
    if (message.keygenId !== "") {
      writer.uint32(26).string(message.keygenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetTssVaultFromKeygen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetTssVaultFromKeygen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keygenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetTssVaultFromKeygen {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      chainIds: globalThis.Array.isArray(object?.chainIds) ? object.chainIds.map((e: any) => globalThis.String(e)) : [],
      keygenId: isSet(object.keygenId) ? globalThis.String(object.keygenId) : "",
    };
  },

  toJSON(message: EventSetTssVaultFromKeygen): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.chainIds?.length) {
      obj.chainIds = message.chainIds;
    }
    if (message.keygenId !== "") {
      obj.keygenId = message.keygenId;
    }
    return obj;
  },

  create(base?: DeepPartial<EventSetTssVaultFromKeygen>): EventSetTssVaultFromKeygen {
    return EventSetTssVaultFromKeygen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventSetTssVaultFromKeygen>): EventSetTssVaultFromKeygen {
    const message = createBaseEventSetTssVaultFromKeygen();
    message.sender = object.sender ?? "";
    message.chainIds = object.chainIds?.map((e) => e) || [];
    message.keygenId = object.keygenId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
